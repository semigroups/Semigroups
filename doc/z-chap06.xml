<Chapter Label = "Creating semigroups and monoids">
  <Heading>
    Creating semigroups and monoids
  </Heading>

  In this chapter we describe the various ways that semigroups and monoids can
  be created in &Semigroups;, the options that are available at the time of
  creation.
 
  <Section Label = "Acting semigroups"><!--TODOFIXME: move this-->
    <Heading>Acting semigroups</Heading>
    It is harder for &Semigroups; to compute Green's &L;- and &H;-classes of a
    transformation semigroup and the methods used to compute with Green's &R;-
    and &D;-classes are the most efficient in &Semigroups;.  Thus, if you are
    computing with a transformation semigroup, wherever possible, it is advisable
    to use the commands relating to Green's &R;- or &D;-classes rather than
    those relating to Green's &L;-  or &H;-classes. No such difficulties are
    present when computing with semigroups of partial permutations,
    bipartitions, or subsemigroups of a regular Rees 0-matrix semigroup over a
    group.<P/>

    The methods in &Semigroups; allow the computation of individual Green's
    classes without computing the entire data structure of the underlying
    semigroup; see <Ref Oper = "GreensRClassOfElementNC"/>.  It is also
    possible to compute the &R;-classes, the number of elements and test
    membership in a semigroup without computing all the elements; see, for
    example, <Ref Oper = "GreensRClasses"/>, <Ref Attr = "RClassReps"/>, <Ref
      Func = "IteratorOfRClassReps"/>, <Ref Func = "IteratorOfRClasses"/>, or
    <Ref Func = "NrRClasses"/>.  This may be useful if you want to study a very
    large semigroup where computing all the elements of the semigroup is not
    feasible.<P/>
  </Section>

  <Section>
    <Heading>New semigroups from old</Heading>

    <#Include Label = "ClosureInverseSemigroup">
    <#Include Label = "ClosureSemigroup">
    <#Include Label = "SubsemigroupByProperty">
    <#Include Label = "InverseSubsemigroupByProperty">
  </Section>
 
  <Section>
    <Heading>Random semigroups</Heading>

    <#Include Label = "RandomSemigroup">
  </Section>
 
  <Section Label = "Options when creating semigroups">
    <Heading>Options when creating semigroups</Heading>

    When using any of the functions:
    <List>
      <Item><Ref Func = "InverseSemigroup"  BookName = "ref"/>, </Item>
      <Item><Ref Func = "InverseMonoid" BookName = "ref"/>, </Item>
      <Item><Ref Func = "Semigroup" BookName = "ref"/>, </Item>
      <Item><Ref Func = "Monoid" BookName = "ref"/>, </Item>
      <Item><Ref Meth = "SemigroupByGenerators" BookName = "ref"/>, </Item>
      <Item><Ref Meth = "MonoidByGenerators" BookName = "ref"/>, </Item>
      <Item><Ref Oper = "ClosureInverseSemigroup"/>, </Item>
      <Item><Ref Oper = "ClosureSemigroup"/>, </Item>
      <Item><Ref Func = "SemigroupIdeal"/></Item>
    </List>
    a record can be given as an optional final argument. The components of this
    record specify the values of certain options for the semigroup being
    created. A list of these options and their default values is given below.
    <P/>

    Assume that <A>S</A> is the semigroup created by one of the functions given
    above and that either: <A>S</A> is generated by a collection <A>gens</A>; or
    <A>S</A> is an ideal of such a semigroup.
 
    <List>
      <Mark><C>acting</C></Mark>
      <Item>
        this component should be <K>true</K> or <K>false</K>.
 
        Roughly speaking, there are two types of methods in the &Semigroups;
        package: those for semigroups which have to be fully enumerated, and
        those for semigroups that do not; see Section <Ref Sect =
          "Introduction"/>.
        In order for a semigroup to use the latter methods in
        &Semigroups; it must satisfy <Ref Prop="IsActingSemigroup"/>.  By
        default any semigroup or monoid of transformations, partial
        permutations, Rees 0-matrix elements, or bipartitions satisfies
        <C>IsActingSemigroup</C>.<P/>

        There are cases (such as when it is known <E>a priori</E> that the
        semigroup is &D;-trivial), when it might be preferable to use the
        methods that involve fully enumerating a semigroup. In other words, it
        might be desirable to disable the more sophisticated methods for acting
        semigroups.  If this is the case, then the value of this component can
        be set <K>false</K> when the semigroup is created.  Following this none
        of the special methods for acting semigroup will be used to compute
        anything about the semigroup.
      </Item>

      <Mark><C>regular</C></Mark>
      <Item>
        this component should be <K>true</K> or <K>false</K>. If it is known
        <E>a priori</E> that the semigroup <C>S</C> being created is a regular
        semigroup, then this component can be set to <K>true</K>. In this case,
        <C>S</C> knows it is a regular semigroup and can take advantage of the
        methods for regular semigroups in &Semigroups;. It is usually much more
        efficient to compute with a regular semigroup that to compute with a
        non-regular semigroup.<P/>

        If this option is set to <K>true</K> when the semigroup being defined
        is <B>not</B> regular, then the results might be unpredictable. <P/>

        The default value for this option is <K>false</K>.
      </Item>
 
      <Mark><C>hashlen</C></Mark>
      <Item>
        this component should be a positive integer, which roughly specifies the
        lengths of the hash tables used internally by &Semigroups;.  &Semigroups;
        uses hash tables in several fundamental methods.  The lengths of these
        tables are a compromise between performance and memory usage; larger
        tables provide better performance for large computations but use more
        memory.  Note that it is unlikely that you will need to specify this
        option unless you find that &GAP; runs out of memory unexpectedly or that
        the performance of &Semigroups; is poorer than expected. If you find that
        &GAP; runs out of memory unexpectedly, or you plan to do a large number
        of computations with relatively small semigroups (say with tens of
        thousands of elements), then you might consider setting <C>hashlen</C> to
        be less than the default value of <C>25013</C> for each of these
        semigroups.  If you find that the performance of &Semigroups; is
        unexpectedly poor, or you plan to do a computation with a very large
        semigroup (say, more than 10 million elements), then you might consider
        setting <C>hashlen</C> to be greater than the default value of
        <C>25013</C>. <P/>

        You might find it useful to set the info level of the info class
        <C>InfoOrb</C> to 2 or higher since this will indicate when hash tables
        used by &Semigroups; are being grown; see <Ref Oper = "SetInfoLevel"
        BookName = "ref"/>.
      </Item>
 
      <Mark><C>small</C></Mark> <Item>if this component is set to <K>true</K>,
        then &Semigroups; will compute a small subset of <A>gens</A> that
        generates <A>S</A> at the time that <A>S</A> is created. This will
        increase the amount of time required to create <A>S</A> substantially,
        but may decrease the amount of time required for subsequent
        calculations with <A>S</A>. If this component is set to <K>false</K>,
        then &Semigroups; will return the semigroup generated by <A>gens</A>
        without modifying <A>gens</A>. The default value for this component is
        <K>false</K>.<P/>

        This option is ignored when passed to <Ref Oper = "ClosureSemigroup"/>
        or <Ref Oper = "ClosureInverseSemigroup"/>.
    </Item>

    <Mark><C>cong_by_ker_trace_threshold</C></Mark>
    <Item>this should be a positive integer, which specifies a semigroup size.
        If <A>S</A> is a semigroup with inverse op, and <A>S</A> has a size
        greater than or equal to this threshold, then any congruence defined on
        it may use the "kernel and trace" method to perform calculations.  If
        its size is less than the threshold, then other methods will be used
        instead.  The "kernel and trace" method has better complexity than the
        generic method, but has large overheads which make it a poor choice for
        small semigroups.  The default value for this component is <C>10 ^
        5</C>.  See Section <Ref Sect = "Congruences on inverse semigroups"/>
        for more information about the "kernel and trace" method.
    </Item>
</List>

    <Example><![CDATA[
gap> S := Semigroup(Transformation([1, 2, 3, 3]),
>                   rec(hashlen := 100003, small := false));
<commutative transformation semigroup of degree 4 with 1 generator>]]></Example>

      The default values of the options described above are stored in a global
      variable named <Ref Var = "SEMIGROUPS.DefaultOptionsRec"/>. If you want to
      change the default values of these options for a single &GAP; session,
      then you can simply redefine the value in &GAP;. For example, to change
      the option <C>small</C> from the default value of <A>false</A> use:

<Log><![CDATA[
gap> SEMIGROUPS.DefaultOptionsRec.small := true;
true]]></Log>

    If you want to change the default values of the options stored in <Ref
      Var = "SEMIGROUPS.DefaultOptionsRec"/> for all &GAP; sessions, then you can
    edit these values in the file <C>semigroups/gap/options.g</C>. <P/>

    <#Include Label = "SEMIGROUPS.DefaultOptionsRec">

   </Section>
 
   <Section Label = "Changing the representation of a semigroup">
     <Heading>Changing the representation of a semigroup</Heading>
 
     The &Semigroups; package provides two convenient constructors
     <Ref Oper = "IsomorphismSemigroup"/> and
     <Ref Oper = "IsomorphismMonoid"/> for changing the representation of a given
     semigroup or monoid. These methods can be used to
     find an isomorphism from any semigroup to a semigroup of any other type,
     provided such an isomorphism exists. <P/>

     Note that at present neither <Ref Oper = "IsomorphismSemigroup"/> nor
     <Ref Oper = "IsomorphismMonoid"/> can be used to determine whether two
     given semigroups, or monoids, are isomorphic.<P/>

     Some methods for <Ref Oper = "IsomorphismSemigroup"/> and
     <Ref Oper = "IsomorphismMonoid"/> are based on
     methods for the &GAP; library operations:
     <List>
       <Item>
         <Ref Oper = "IsomorphismReesMatrixSemigroup" BookName = "ref"/>,
       </Item>
       <Item>
         <Ref Oper = "AntiIsomorphismTransformationSemigroup" BookName = "ref"/>,
       </Item>
       <Item>
         <Ref Oper = "IsomorphismTransformationSemigroup" BookName = "ref"/>
         and
         <Ref Oper = "IsomorphismTransformationMonoid" BookName = "ref"/>,
       </Item>
       <Item>
         <Ref Oper = "IsomorphismPartialPermSemigroup" BookName = "ref"/>
         and
         <Ref Oper = "IsomorphismPartialPermMonoid" BookName = "ref"/>,
       </Item>
       <Item>
         <Ref Oper = "IsomorphismFpSemigroup" BookName = "ref"/>
         and <C>IsomorphismFpMonoid</C>.
       </Item>
     </List>

     The operation <Ref Oper = "IsomorphismMonoid"/> can be used to return an
     isomorphism from a semigroup which is mathematically a monoid (but does not
     below to the category of monoids in &GAP; <Ref Filt = "IsMonoid" BookName
       = "ref"/>) into a monoid. This is the primary purpose of the operation
     <Ref Oper = "IsomorphismMonoid"/>. Either
     <Ref Oper = "IsomorphismSemigroup"/> or <Ref Oper = "IsomorphismMonoid"/>
     can be used to change the representation of a monoid, but only the latter
     is guaranteed to return an object in the category of monoids.
     <P/>
 
     <Example><![CDATA[
gap> S := Monoid(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),
>                Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;
gap> AsSemigroup(IsBooleanMatSemigroup, S);
<monoid of 10x10 boolean matrices with 2 generators>
gap> AsMonoid(IsBooleanMatMonoid, S);
<monoid of 10x10 boolean matrices with 2 generators>
gap> S := Semigroup(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),
>                   Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;
gap> AsSemigroup(IsBooleanMatSemigroup, S);
<semigroup of 10x10 boolean matrices with 2 generators>
gap> AsMonoid(IsBooleanMatMonoid, S);
<monoid of 8x8 boolean matrices with 2 generators>
gap> M := Monoid([
> Bipartition([[1, -3], [2, 3, 6], [4, 7, -6], [5, -8], [8, -4, -5],
>              [-1], [-2], [-7]]),
> Bipartition([[1, 3, -6], [2, -8], [4, 8, -1], [5], [6, -3, -4],
>              [7], [-2], [-5], [-7]]),
> Bipartition([[1, 2, 4, -3, -7, -8], [3, 5, 6, 8, -4, -6],
>              [7, -1, -2, -5]])]);;
gap> AsMonoid(IsPBRMonoid, M);
<pbr monoid of size 163, degree 163 with 3 generators>
gap> AsSemigroup(IsPBRSemigroup, M);
<pbr semigroup of size 163, degree 8 with 4 generators>]]></Example>

     There are some further methods in &Semigroups; for obtaining an isomorphism
     from a Rees matrix, or 0-matrix, semigroup to another such semigroup with
     particular properties; <Ref Attr = "RMSNormalization"/> and
     <Ref Attr = "RZMSNormalization"/>.

     <#Include Label = "IsomorphismSemigroup">
     <#Include Label = "IsomorphismMonoid">
     <#Include Label = "AsSemigroup">
     <#Include Label = "AsMonoid">
     <#Include Label = "RZMSNormalization">
     <#Include Label = "RMSNormalization">
  </Section>
 
</Chapter>
