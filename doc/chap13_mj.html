<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (Semigroups) - Chapter 13: Congruences</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap13"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap12_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap14_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap13.html">[MathJax off]</a></p>
<p><a id="X82BD951079E3C349" name="X82BD951079E3C349"></a></p>
<div class="ChapSects"><a href="chap13_mj.html#X82BD951079E3C349">13 <span class="Heading">Congruences</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X784770137D98FEB9">13.1 <span class="Heading">Semigroup congruence objects</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X78E34B737F0E009F">13.1-1 IsSemigroupCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7E909A78830D42A6">13.1-2 IsLeftSemigroupCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X839EEA797B1CCB67">13.1-3 IsRightSemigroupCongruence</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X7D49787B7B2589B2">13.2 <span class="Heading">
      Creating congruences
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X85CE56AC84FA5D33">13.2-1 SemigroupCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X8757DB087BE7E55A">13.2-2 LeftSemigroupCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7D01176B788FEE60">13.2-3 RightSemigroupCongruence</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X7D65BB067A762CD6">13.3 <span class="Heading">
      Congruence classes
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7B1F67A97E23E6A4">13.3-1 IsCongruenceClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7C803E8C84E81A0B">13.3-2 IsLeftCongruenceClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7D2F11C28470BC5A">13.3-3 IsRightCongruenceClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X86C05F31797C1D6D">13.3-4 NonTrivialEquivalenceClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7DA4BABC7891A7F1">13.3-5 EquivalenceRelationLookup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X8022B7898553F624">13.3-6 EquivalenceRelationCanonicalLookup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X842D567F79648FEB">13.3-7 EquivalenceRelationCanonicalPartition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X85400841879E41A5">13.3-8 OnLeftCongruenceClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7D66F8607B4F0D8F">13.3-9 OnRightCongruenceClasses</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X806DEBC07E6D8FCA">13.4 <span class="Heading">
      Finding the congruences of a semigroup
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7E8D5BA27CB5A4DA">13.4-1 CongruencesOfSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7838738987B2DB41">13.4-2 MinimalCongruencesOfSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7986F3597F9DF7AF">13.4-3 PrincipalCongruencesOfSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X8195D6F47EE52806">13.4-4 IsCongruencePoset</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X86C9C5BA7FE93F4C">13.4-5 LatticeOfCongruences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X784CFDE37A0B4F84">13.4-6 CayleyDigraphOfCongruences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X83ACF2C0789F621B">13.4-7 PosetOfPrincipalCongruences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7B2E2CEE8626FBC3">13.4-8 CongruencesOfPoset</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X830F42B582A2FAA0">13.4-9 UnderlyingSemigroupOfCongruencePoset</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X78A91138818A4FAE">13.4-10 PosetOfCongruences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X87CF25A178B7F1AF">13.4-11 JoinSemilatticeOfCongruences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7ECE04727B6A58A3">13.4-12 GeneratingCongruencesOfJoinSemilattice</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X780E2B3F8509CE32">13.4-13 MinimalCongruences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7AE16F237E862934">13.4-14 NumberOfRightCongruences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X807A5FCC87661FA4">13.4-15 IteratorOfRightCongruences</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X857D750579B87DBF">13.5 <span class="Heading">
      Comparing congruences
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X85075F1D878512F5">13.5-1 IsSubrelation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X83878AED7A8E75BE">13.5-2 IsSuperrelation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7952A5A5789C6F60">13.5-3 MeetSemigroupCongruences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X8262D5207DBF3C5B">13.5-4 JoinSemigroupCongruences</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X7A6478D1831DD787">13.6 <span class="Heading">Congruences on Rees matrix semigroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7F4AFD7F7E163022">13.6-1 IsRMSCongruenceByLinkedTriple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X87A475E4847D3C96">13.6-2 RMSCongruenceByLinkedTriple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X79E4CF7B79B25AE3">13.6-3 IsRMSCongruenceClassByLinkedTriple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7E9AB940868FCC9D">13.6-4 RMSCongruenceClassByLinkedTriple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7B19CACF7A37ADBC">13.6-5 IsLinkedTriple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7DB7E32E865AD95D">13.6-6 AsSemigroupCongruenceByGeneratingPairs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X7BFDC38178940AE6">13.7 <span class="Heading">
      Congruences on inverse semigroups
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X8546E48E85A2A7E8">13.7-1 IsInverseSemigroupCongruenceByKernelTrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7A588B737CEEB104">13.7-2 InverseSemigroupCongruenceByKernelTrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X87916D4E854F1F6B">13.7-3 AsInverseSemigroupCongruenceByKernelTrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7D521AFF7876CBC7">13.7-4 KernelOfSemigroupCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X80972A5B82D88F89">13.7-5 TraceOfSemigroupCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X8049A0E780A7A8D9">13.7-6 IsInverseSemigroupCongruenceClassByKernelTrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X857495647F9A9579">13.7-7 MinimumGroupCongruence</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X8036DAA287C71CAC">13.8 <span class="Heading">
      Congruences on graph inverse semigroups
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7AEB7DA27E76145B">13.8-1 IsCongruenceByWangPair</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7F30D10F7BEEEBB9">13.8-2 CongruenceByWangPair</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X817F4FC27E9BACD8">13.8-3 AsCongruenceByWangPair</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X858AE13379B5C380">13.8-4 GeneratingCongruencesOfLattice</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X7CE483078769A4D6">13.9 <span class="Heading">Rees congruences</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7BC02E08840E0AF4">13.9-1 SemigroupIdealOfReesCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7E15F66A8029C64A">13.9-2 IsReesCongruenceClass</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap13_mj.html#X7C6B4A2980BE9B03">13.10 <span class="Heading">Universal and trivial congruences</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X8751EF557A81A2B1">13.10-1 IsUniversalSemigroupCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X8646253C86AFFA29">13.10-2 IsUniversalSemigroupCongruenceClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7B99C6A47F3D375F">13.10-3 UniversalSemigroupCongruence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap13_mj.html#X7A9B483B7B4E0E27">13.10-4 TrivialCongruence</a></span>
</div></div>
</div>

<h3>13 <span class="Heading">Congruences</span></h3>

<p>Congruences in <strong class="pkg">Semigroups</strong> can be described in several different ways:</p>


<ul>
<li><p>Generating pairs -- the minimal congruence which contains these pairs</p>

</li>
<li><p>Rees congruences -- the congruence specified by a given ideal</p>

</li>
<li><p>Universal congruences -- the unique congruence with only one class</p>

</li>
<li><p>Linked triples -- only for simple or 0-simple semigroups (see below)</p>

</li>
<li><p>Kernel and trace -- only for inverse semigroups</p>

</li>
<li><p>Word graph -- only for congruences created via <code class="func">IteratorOfLeftCongruences</code> (<a href="chap13_mj.html#X807A5FCC87661FA4"><span class="RefLink">13.4-15</span></a>) or <code class="func">IteratorOfRightCongruences</code> (<a href="chap13_mj.html#X807A5FCC87661FA4"><span class="RefLink">13.4-15</span></a>)</p>

</li>
<li><p>Wang pairs -- only for graph inverse semigroup</p>

</li>
</ul>
<p>The operation <code class="func">SemigroupCongruence</code> (<a href="chap13_mj.html#X85CE56AC84FA5D33"><span class="RefLink">13.2-1</span></a>) can be used to create any of these, interpreting the arguments in a smart way. The usual way of specifying a congruence will be by giving a set of generating pairs, but a user with an ideal could instead create a Rees congruence or universal congruence.</p>

<p>If a congruence is specified by generating pairs on a simple, 0-simple, or inverse semigroup, then the congruence may be converted automatically to one of the last two items in the above list, to reduce the complexity of any calculations to be performed. The user need not manually specify, or even be aware of, the congruence's linked triple or kernel and trace.</p>

<p>We can also create left congruences and right congruences, using the <code class="func">LeftSemigroupCongruence</code> (<a href="chap13_mj.html#X8757DB087BE7E55A"><span class="RefLink">13.2-2</span></a>) and <code class="func">RightSemigroupCongruence</code> (<a href="chap13_mj.html#X7D01176B788FEE60"><span class="RefLink">13.2-3</span></a>) functions.</p>

<p>Please note that congruence objects made in <strong class="pkg">GAP</strong> before loading the <strong class="pkg">Semigroups</strong> package may not behave correctly after <strong class="pkg">Semigroups</strong> is loaded. If <strong class="pkg">Semigroups</strong> is loaded at the beginning of the session, or before any congruence work is done, then the objects should behave correctly.</p>

<p><a id="X784770137D98FEB9" name="X784770137D98FEB9"></a></p>

<h4>13.1 <span class="Heading">Semigroup congruence objects</span></h4>

<p><a id="X78E34B737F0E009F" name="X78E34B737F0E009F"></a></p>

<h5>13.1-1 IsSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSemigroupCongruence</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A semigroup congruence <code class="code">cong</code> is an equivalence relation on a semigroup <code class="code">S</code> which respects left and right multiplication.</p>

<p>That is, if <span class="SimpleMath">\((a,b)\)</span> is a pair in <code class="code">cong</code>, and <span class="SimpleMath">\(x\)</span> is an element of <code class="code">S</code>, then <span class="SimpleMath">\((ax,bx)\)</span> and <span class="SimpleMath">\((xa,xb)\)</span> are both in <code class="code">cong</code>.</p>

<p>The simplest way of creating a congruence in <strong class="pkg">Semigroups</strong> is by a set of <em>generating pairs</em>. See <code class="func">SemigroupCongruence</code> (<a href="chap13_mj.html#X85CE56AC84FA5D33"><span class="RefLink">13.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([2, 1, 1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([4, 3, 3, 4, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([1, 2, 1, 2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [Transformation([4, 3, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([3, 4, 3, 4, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(S, [pair1, pair2]);</span>
&lt;semigroup congruence over &lt;simple transformation semigroup of
 degree 5 with 4 generators&gt; with linked triple (2,4,1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSemigroupCongruence(cong);</span>
true</pre></div>

<p><a id="X7E909A78830D42A6" name="X7E909A78830D42A6"></a></p>

<h5>13.1-2 IsLeftSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLeftSemigroupCongruence</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A left semigroup congruence <code class="code">cong</code> is an equivalence relation on a semigroup <code class="code">S</code> which respects left multiplication.</p>

<p>That is, if <span class="SimpleMath">\((a,b)\)</span> is a pair in <code class="code">cong</code>, and <span class="SimpleMath">\(x\)</span> is an element of <code class="code">S</code>, then <span class="SimpleMath">\((xa,xb)\)</span> is also in <code class="code">cong</code>.</p>

<p>The simplest way of creating a left congruence in <strong class="pkg">Semigroups</strong> is by a set of <em>generating pairs</em>. See <code class="func">LeftSemigroupCongruence</code> (<a href="chap13_mj.html#X8757DB087BE7E55A"><span class="RefLink">13.2-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([2, 1, 1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([4, 3, 3, 4, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([1, 2, 1, 2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [Transformation([4, 3, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([3, 4, 3, 4, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := LeftSemigroupCongruence(S, [pair1, pair2]);</span>
&lt;left semigroup congruence over &lt;transformation semigroup of degree 5
 with 4 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLeftSemigroupCongruence(cong);</span>
true</pre></div>

<p><a id="X839EEA797B1CCB67" name="X839EEA797B1CCB67"></a></p>

<h5>13.1-3 IsRightSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRightSemigroupCongruence</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A right semigroup congruence <code class="code">cong</code> is an equivalence relation on a semigroup <code class="code">S</code> which respects right multiplication.</p>

<p>That is, if <span class="SimpleMath">\((a,b)\)</span> is a pair in <code class="code">cong</code>, and <span class="SimpleMath">\(x\)</span> is an element of <code class="code">S</code>, then <span class="SimpleMath">\((ax,bx)\)</span> is also in <code class="code">cong</code>.</p>

<p>The simplest way of creating a right congruence in <strong class="pkg">Semigroups</strong> is by a set of <em>generating pairs</em>. See <code class="func">RightSemigroupCongruence</code> (<a href="chap13_mj.html#X7D01176B788FEE60"><span class="RefLink">13.2-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([2, 1, 1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([4, 3, 3, 4, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([1, 2, 1, 2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [Transformation([4, 3, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([3, 4, 3, 4, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightSemigroupCongruence(S, [pair1, pair2]);</span>
&lt;right semigroup congruence over &lt;transformation semigroup of
 degree 5 with 4 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRightSemigroupCongruence(cong);</span>
true</pre></div>

<p><a id="X7D49787B7B2589B2" name="X7D49787B7B2589B2"></a></p>

<h4>13.2 <span class="Heading">
      Creating congruences
    </span></h4>

<p><a id="X85CE56AC84FA5D33" name="X85CE56AC84FA5D33"></a></p>

<h5>13.2-1 SemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemigroupCongruence</code>( <var class="Arg">S</var>, <var class="Arg">pairs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup congruence.</p>

<p>This function returns a semigroup congruence over the semigroup <var class="Arg">S</var>.</p>

<p>If <var class="Arg">pairs</var> is a list of lists of size 2 with elements from <var class="Arg">S</var>, then this function will return the semigroup congruence defined by these generating pairs. The individual pairs may instead be given as separate arguments.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([2, 1, 1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([4, 3, 3, 4, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([1, 2, 1, 2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [Transformation([4, 3, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([3, 4, 3, 4, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SemigroupCongruence(S, [pair1, pair2]);</span>
&lt;semigroup congruence over &lt;simple transformation semigroup of
 degree 5 with 4 generators&gt; with linked triple (2,4,1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SemigroupCongruence(S, pair1, pair2);</span>
&lt;semigroup congruence over &lt;simple transformation semigroup of
 degree 5 with 4 generators&gt; with linked triple (2,4,1)&gt;</pre></div>

<p><a id="X8757DB087BE7E55A" name="X8757DB087BE7E55A"></a></p>

<h5>13.2-2 LeftSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftSemigroupCongruence</code>( <var class="Arg">S</var>, <var class="Arg">pairs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: A left semigroup congruence.</p>

<p>This function returns a left semigroup congruence over the semigroup <var class="Arg">S</var>.</p>

<p>If <var class="Arg">pairs</var> is a list of lists of size 2 with elements from <var class="Arg">S</var>, then this function will return the least left semigroup congruence on <var class="Arg">S</var> which contains these generating pairs. The individual pairs may instead be given as separate arguments.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([2, 1, 1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([4, 3, 3, 4, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([1, 2, 1, 2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [Transformation([4, 3, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([3, 4, 3, 4, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftSemigroupCongruence(S, [pair1, pair2]);</span>
&lt;left semigroup congruence over &lt;transformation semigroup of degree 5
 with 4 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftSemigroupCongruence(S, pair1, pair2);</span>
&lt;left semigroup congruence over &lt;transformation semigroup of degree 5
 with 4 generators&gt; with 2 generating pairs&gt;</pre></div>

<p><a id="X7D01176B788FEE60" name="X7D01176B788FEE60"></a></p>

<h5>13.2-3 RightSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightSemigroupCongruence</code>( <var class="Arg">S</var>, <var class="Arg">pairs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: A right semigroup congruence.</p>

<p>This function returns a right semigroup congruence over the semigroup <var class="Arg">S</var>.</p>

<p>If <var class="Arg">pairs</var> is a list of lists of size 2 with elements from <var class="Arg">S</var>, then this function will return the least right semigroup congruence on <var class="Arg">S</var> which contains these generating pairs. The individual pairs may instead be given as separate arguments.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([2, 1, 1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([4, 3, 3, 4, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([1, 2, 1, 2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [Transformation([4, 3, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([3, 4, 3, 4, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightSemigroupCongruence(S, [pair1, pair2]);</span>
&lt;right semigroup congruence over &lt;transformation semigroup of
 degree 5 with 4 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightSemigroupCongruence(S, pair1, pair2);</span>
&lt;right semigroup congruence over &lt;transformation semigroup of
 degree 5 with 4 generators&gt; with 2 generating pairs&gt;</pre></div>

<p><a id="X7D65BB067A762CD6" name="X7D65BB067A762CD6"></a></p>

<h4>13.3 <span class="Heading">
      Congruence classes
    </span></h4>

<p>The main operations and attributes for congruences in the <strong class="pkg">GAP</strong> library are:</p>


<ul>
<li><p><code class="func">EquivalenceClasses</code> (<a href="https://docs.gap-system.org/doc/ref/chap33_mj.html#X879439897EF4D728"><span class="RefLink">Reference: EquivalenceClasses attribute</span></a>)</p>

</li>
<li><p><code class="code">NrEquivalenceClasses</code></p>

</li>
<li><p><code class="func">EquivalenceClassOfElement</code> (<a href="https://docs.gap-system.org/doc/ref/chap33_mj.html#X7BB985BA7FD7A82E"><span class="RefLink">Reference: EquivalenceClassOfElement</span></a>)</p>

</li>
</ul>
<p><a id="X7B1F67A97E23E6A4" name="X7B1F67A97E23E6A4"></a></p>

<h5>13.3-1 IsCongruenceClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCongruenceClass</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>This category contains any object which is an equivalence class of a semigroup congruence (see <code class="func">IsSemigroupCongruence</code> (<a href="chap13_mj.html#X78E34B737F0E009F"><span class="RefLink">13.1-1</span></a>)). An object will only be in this category if the relation is known to be a semigroup congruence when the congruence class is created.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation([1, 2, 2]), Transformation([3, 1, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(S, [Transformation([1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   Transformation([2, 1, 2])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">class := EquivalenceClassOfElement(cong,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                      Transformation([3, 1, 1]));</span>
&lt;2-sided congruence class of Transformation( [ 3, 1, 1 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruenceClass(class);</span>
true</pre></div>

<p><a id="X7C803E8C84E81A0B" name="X7C803E8C84E81A0B"></a></p>

<h5>13.3-2 IsLeftCongruenceClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLeftCongruenceClass</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>This category contains any object which is an equivalence class of a left semigroup congruence (see <code class="func">IsLeftSemigroupCongruence</code> (<a href="chap13_mj.html#X7E909A78830D42A6"><span class="RefLink">13.1-2</span></a>)). An object will only be in this category if the relation is known to be a left semigroup congruence when the class is created.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation([1, 2, 2]), Transformation([3, 1, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pairs := [Transformation([1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([2, 1, 2])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := LeftSemigroupCongruence(S, pairs);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">class := EquivalenceClassOfElement(cong,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                      Transformation([3, 1, 1]));</span>
&lt;left congruence class of Transformation( [ 3, 1, 1 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLeftCongruenceClass(class);</span>
true</pre></div>

<p><a id="X7D2F11C28470BC5A" name="X7D2F11C28470BC5A"></a></p>

<h5>13.3-3 IsRightCongruenceClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRightCongruenceClass</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>This category contains any object which is an equivalence class of a right semigroup congruence (see <code class="func">IsRightSemigroupCongruence</code> (<a href="chap13_mj.html#X839EEA797B1CCB67"><span class="RefLink">13.1-3</span></a>)). An object will only be in this category if the relation is known to be a right semigroup congruence when the class is created.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation([1, 2, 2]), Transformation([3, 1, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pairs := [Transformation([1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([2, 1, 2])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := RightSemigroupCongruence(S, pairs);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">class := EquivalenceClassOfElement(cong,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                      Transformation([3, 1, 1]));</span>
&lt;right congruence class of Transformation( [ 3, 1, 1 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRightCongruenceClass(class);</span>
true</pre></div>

<p><a id="X86C05F31797C1D6D" name="X86C05F31797C1D6D"></a></p>

<h5>13.3-4 NonTrivialEquivalenceClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonTrivialEquivalenceClasses</code>( <var class="Arg">eq</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of equivalence classes.</p>

<p>If <var class="Arg">eq</var> is an equivalence relation, then this attribute returns a list of all equivalence classes of <var class="Arg">eq</var> which contain more than one element.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid([Transformation([1, 2, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                Transformation([3, 1, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(S, [Transformation([1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   Transformation([2, 1, 2])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classes := NonTrivialEquivalenceClasses(cong);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set(classes);</span>
[ &lt;2-sided congruence class of Transformation( [ 1, 2, 2 ] )&gt;,
  &lt;2-sided congruence class of Transformation( [ 3, 1, 3 ] )&gt;,
  &lt;2-sided congruence class of Transformation( [ 3, 1, 1 ] )&gt;,
  &lt;2-sided congruence class of Transformation( [ 2, 1, 2 ] )&gt;,
  &lt;2-sided congruence class of Transformation( [ 3, 3, 3 ] )&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := RightSemigroupCongruence(S, [Transformation([1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                        Transformation([2, 1, 2])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classes := NonTrivialEquivalenceClasses(cong);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set(classes);</span>
[ &lt;right congruence class of Transformation( [ 3, 1, 3 ] )&gt;,
  &lt;right congruence class of Transformation( [ 2, 1, 2 ] )&gt; ]</pre></div>

<p><a id="X7DA4BABC7891A7F1" name="X7DA4BABC7891A7F1"></a></p>

<h5>13.3-5 EquivalenceRelationLookup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EquivalenceRelationLookup</code>( <var class="Arg">equiv</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>This attribute describes the equivalence relation <var class="Arg">equiv</var>, defined over a finite semigroup, as a list of positive integers of length the size of the finite semigroup over which <var class="Arg">equiv</var> is defined.</p>

<p>Each position in the list corresponds to an element of the semigroup (in a consistent canonical order) and the integer at that position is a unique identifier for that element's equivalence class under <var class="Arg">equiv</var>. Two elements of the semigroup on which the equivalence is defined are related in the equivalence if and only if they have the same number at their respective positions in the lookup.</p>

<p>Note that the order in which numbers appear in the list is non-deterministic, and two equivalence relations describing the same mathematical relation might therefore have different lookups. Note also that the maximum value of the list may not be the number of classes of <var class="Arg">equiv</var>, and that any integer might not be included. However, see <code class="func">EquivalenceRelationCanonicalLookup</code> (<a href="chap13_mj.html#X8022B7898553F624"><span class="RefLink">13.3-6</span></a>).</p>

<p>See also <code class="func">EquivalenceRelationPartition</code> (<a href="https://docs.gap-system.org/doc/ref/chap33_mj.html#X877389B683DD8F1A"><span class="RefLink">Reference: EquivalenceRelationPartition</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation([1, 2, 2]), Transformation([3, 1, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(S,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[Transformation([1, 2, 1]), Transformation([2, 1, 2])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lookup := EquivalenceRelationLookup(cong);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lookup[3] = lookup[8];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lookup[2] = lookup[9];</span>
false</pre></div>

<p><a id="X8022B7898553F624" name="X8022B7898553F624"></a></p>

<h5>13.3-6 EquivalenceRelationCanonicalLookup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EquivalenceRelationCanonicalLookup</code>( <var class="Arg">equiv</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>This attribute describes the equivalence relation <var class="Arg">equiv</var>, defined over a finite semigroup, as a list of positive integers of length the size of the semigroup.</p>

<p>Each position in the list corresponds to an element of the semigroup (in a consistent canonical order as defined by <code class="func">PositionCanonical</code> (<a href="chap11_mj.html#X7B4B10AE81602D4E"><span class="RefLink">11.1-2</span></a>)) and the integer at that position is a unique identifier for that element's equivalence class under <var class="Arg">equiv</var>. The value of <code class="code">EquivalenceRelationCanonicalLookup</code> has the property that the first appearance of the value <code class="code">i</code> is strictly later than the first appearance of <code class="code">i-1</code>, and that all entries in the list will be from the range <code class="code">[1 .. NrEquivalenceClasses(<var class="Arg">equiv</var>)]</code>. As such, two equivalence relations on a given semigroup are equal if and only if their canonical lookups are equal.</p>

<p>Two elements of the semigroup on which the equivalence relation is defined are related in the equivalence relation if and only if they have the same number at their respective positions in the lookup.</p>

<p>See also <code class="func">EquivalenceRelationLookup</code> (<a href="chap13_mj.html#X7DA4BABC7891A7F1"><span class="RefLink">13.3-5</span></a>) and <code class="func">EquivalenceRelationPartition</code> (<a href="https://docs.gap-system.org/doc/ref/chap33_mj.html#X877389B683DD8F1A"><span class="RefLink">Reference: EquivalenceRelationPartition</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation([1, 2, 2]), Transformation([3, 1, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(S,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[Transformation([1, 2, 1]), Transformation([2, 1, 2])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquivalenceRelationCanonicalLookup(cong);</span>
[ 1, 2, 3, 4, 5, 6, 2, 3, 6, 4, 5, 6 ]</pre></div>

<p><a id="X842D567F79648FEB" name="X842D567F79648FEB"></a></p>

<h5>13.3-7 EquivalenceRelationCanonicalPartition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EquivalenceRelationCanonicalPartition</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists.</p>

<p>This attribute returns a list of lists of elements of the underlying set of the semigroup congruence <var class="Arg">cong</var>. These lists are precisely the nontrivial equivalence classes of <var class="Arg">cong</var>. The order in which the classes appear is deterministic, and the order of the elements inside each class is also deterministic. Hence, two congruence objects have the same <code class="code">EquivalenceRelationCanonicalPartition</code> if and only if they describe the same relation.</p>

<p>See also <code class="func">EquivalenceRelationPartition</code> (<a href="https://docs.gap-system.org/doc/ref/chap33_mj.html#X877389B683DD8F1A"><span class="RefLink">Reference: EquivalenceRelationPartition</span></a>), a similar attribute which does not have canonical ordering, but which is likely to be faster.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 4, 3, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([2, 4, 3, 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(S, [Transformation([1, 4, 3, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   Transformation([1, 3, 3, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquivalenceRelationCanonicalPartition(cong);</span>
[ [ Transformation( [ 1, 4, 3, 3 ] ),
      Transformation( [ 1, 3, 3, 3 ] ) ],
  [ Transformation( [ 4, 3, 3, 3 ] ),
      Transformation( [ 3, 3, 3, 3 ] ) ] ]
</pre></div>

<p><a id="X85400841879E41A5" name="X85400841879E41A5"></a></p>

<h5>13.3-8 OnLeftCongruenceClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OnLeftCongruenceClasses</code>( <var class="Arg">class</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A left congruence class.</p>

<p>If <var class="Arg">class</var> is an equivalence class of the left semigroup congruence <code class="code">cong</code> on the semigroup <code class="code">S</code>, and <var class="Arg">elm</var> is an element of <code class="code">S</code>, then this operation returns the equivalence class of <code class="code">cong</code> containing the element <code class="code"><var class="Arg">elm</var> * x</code>, where <code class="code">x</code> is any element of <var class="Arg">class</var>. The result is well-defined by the definition of a left congruence.</p>

<p>See <code class="func">IsLeftSemigroupCongruence</code> (<a href="chap13_mj.html#X7E909A78830D42A6"><span class="RefLink">13.1-2</span></a>) and <code class="func">IsLeftCongruenceClass</code> (<a href="chap13_mj.html#X7C803E8C84E81A0B"><span class="RefLink">13.3-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([2, 1, 1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([4, 3, 3, 4, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([1, 2, 1, 2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [Transformation([4, 3, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([3, 4, 3, 4, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := LeftSemigroupCongruence(S, [pair1, pair2]);</span>
&lt;left semigroup congruence over &lt;transformation semigroup of degree 5
 with 4 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Transformation([3, 4, 3, 4, 3]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">class := EquivalenceClassOfElement(cong, x);</span>
&lt;left congruence class of Transformation( [ 3, 4, 3, 4, 3 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elm := Transformation([1, 2, 2, 1, 2]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnLeftCongruenceClasses(class, elm);</span>
&lt;left congruence class of Transformation( [ 3, 4, 4, 3, 4 ] )&gt;
</pre></div>

<p><a id="X7D66F8607B4F0D8F" name="X7D66F8607B4F0D8F"></a></p>

<h5>13.3-9 OnRightCongruenceClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OnRightCongruenceClasses</code>( <var class="Arg">class</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A right congruence class.</p>

<p>If <var class="Arg">class</var> is an equivalence class of the right semigroup congruence <code class="code">cong</code> on the semigroup <code class="code">S</code>, and <var class="Arg">elm</var> is an element of <code class="code">S</code>, then this operation returns the equivalence class of <code class="code">cong</code> containing the element <code class="code">x * <var class="Arg">elm</var></code>, where <code class="code">x</code> is any element of <var class="Arg">class</var>. The result is well-defined by the definition of a right congruence.</p>

<p>See <code class="func">IsRightSemigroupCongruence</code> (<a href="chap13_mj.html#X839EEA797B1CCB67"><span class="RefLink">13.1-3</span></a>) and <code class="func">IsRightCongruenceClass</code> (<a href="chap13_mj.html#X7D2F11C28470BC5A"><span class="RefLink">13.3-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([2, 1, 1, 2, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Transformation([4, 3, 3, 4, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([3, 4, 3, 4, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([1, 2, 1, 2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [Transformation([4, 3, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Transformation([3, 4, 3, 4, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := RightSemigroupCongruence(S, [pair1, pair2]);</span>
&lt;right semigroup congruence over &lt;transformation semigroup of
 degree 5 with 4 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Transformation([3, 4, 3, 4, 3]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">class := EquivalenceClassOfElement(cong, x);</span>
&lt;right congruence class of Transformation( [ 3, 4, 3, 4, 3 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elm := Transformation([1, 2, 2, 1, 2]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnRightCongruenceClasses(class, elm);</span>
&lt;right congruence class of Transformation( [ 2, 1, 2, 1, 2 ] )&gt;
</pre></div>

<p><a id="X806DEBC07E6D8FCA" name="X806DEBC07E6D8FCA"></a></p>

<h4>13.4 <span class="Heading">
      Finding the congruences of a semigroup
    </span></h4>

<p><a id="X7E8D5BA27CB5A4DA" name="X7E8D5BA27CB5A4DA"></a></p>

<h5>13.4-1 CongruencesOfSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightCongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightCongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The congruences of a semigroup.</p>

<p>This attribute gives a list of the left, right, or 2-sided congruences of the semigroup <var class="Arg">S</var>.</p>

<p>If <var class="Arg">restriction</var> is specified and is a collection of elements from <var class="Arg">S</var>, then the result will only include congruences generated by pairs of elements from <var class="Arg">restriction</var>. Otherwise, all congruences will be calculated.</p>

<p>See also <code class="func">LatticeOfCongruences</code> (<a href="chap13_mj.html#X86C9C5BA7FE93F4C"><span class="RefLink">13.4-5</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(SymmetricGroup(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                [[(), (1, 3, 2)], [(1, 2), 0]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">congs := CongruencesOfSemigroup(S);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(congs);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set(congs, NrEquivalenceClasses);</span>
[ 1, 5, 9, 25 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos := Position(congs, UniversalSemigroupCongruence(S));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">congs[pos];</span>
&lt;universal semigroup congruence over
&lt;Rees 0-matrix semigroup 2x2 over Sym( [ 1 .. 3 ] )&gt;&gt;</pre></div>

<p><a id="X7838738987B2DB41" name="X7838738987B2DB41"></a></p>

<h5>13.4-2 MinimalCongruencesOfSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalCongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalLeftCongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalRightCongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalCongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalLeftCongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalRightCongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The congruences of a semigroup.</p>

<p>If <var class="Arg">S</var> is a semigroup, then the attribute <code class="code">MinimalCongruencesOfSemigroup</code> gives a list of all the congruences on <var class="Arg">S</var> which are <em>minimal</em>. A congruence is minimal iff it is non-trivial and contains no other congruences as subrelations (apart from the trivial congruence).</p>

<p><code class="code">MinimalLeftCongruencesOfSemigroup</code> and <code class="code">MinimalRightCongruencesOfSemigroup</code> do the same thing, but for left congruences and right congruences respectively. Note that any congruence is also a left congruence, but that a minimal congruence may not be a minimal left congruence.</p>

<p>If <var class="Arg">restriction</var> is specified and is a collection of elements from <var class="Arg">S</var>, then the result will only include congruences generated by pairs of elements from <var class="Arg">restriction</var>. Otherwise, all congruences will be calculated.</p>

<p>See also <code class="func">CongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7E8D5BA27CB5A4DA"><span class="RefLink">13.4-1</span></a>) and <code class="func">PrincipalCongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7986F3597F9DF7AF"><span class="RefLink">13.4-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 3, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([3, 1, 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">min := MinimalCongruencesOfSemigroup(S);</span>
[ &lt;2-sided semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt; with 1 generating pairs&gt;
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">minl := MinimalLeftCongruencesOfSemigroup(S);</span>
[ &lt;left semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt; with 1 generating pairs&gt;,
  &lt;left semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt; with 1 generating pairs&gt;,
  &lt;left semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt; with 1 generating pairs&gt;
 ]
</pre></div>

<p><a id="X7986F3597F9DF7AF" name="X7986F3597F9DF7AF"></a></p>

<h5>13.4-3 PrincipalCongruencesOfSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrincipalCongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrincipalLeftCongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrincipalRightCongruencesOfSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrincipalCongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrincipalLeftCongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrincipalRightCongruencesOfSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>If <var class="Arg">S</var> is a semigroup, then the attribute <code class="code">PrincipalCongruencesOfSemigroup</code> gives a list of all the congruences on <var class="Arg">S</var> which are <em>principal</em>. A congruence is principal if and only if it is non-trivial and can be defined by a single generating pair.</p>

<p><code class="code">PrincipalLeftCongruencesOfSemigroup</code> and <code class="code">PrincipalRightCongruencesOfSemigroup</code> do the same thing, but for left congruences and right congruences respectively. Note that any congruence is a left congruence and a right congruence, but that a principal congruence may not be a principal left congruence or a principal right congruence.</p>

<p>If <var class="Arg">restriction</var> is specified and is a collection of elements from <var class="Arg">S</var>, then the result will only include congruences generated by pairs of elements from <var class="Arg">restriction</var>. Otherwise, all congruences will be calculated.</p>

<p>See also <code class="func">CongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7E8D5BA27CB5A4DA"><span class="RefLink">13.4-1</span></a>) and <code class="func">MinimalCongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7838738987B2DB41"><span class="RefLink">13.4-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 3, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([3, 1, 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">congs := PrincipalCongruencesOfSemigroup(S);</span>
[ &lt;universal semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt;&gt;,
  &lt;2-sided semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt; with 1 generating pairs&gt;,
  &lt;2-sided semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt; with 1 generating pairs&gt;,
  &lt;2-sided semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt; with 1 generating pairs&gt;,
  &lt;2-sided semigroup congruence over &lt;transformation semigroup
     of size 13, degree 3 with 2 generators&gt; with 1 generating pairs&gt;
 ]
</pre></div>

<p><a id="X8195D6F47EE52806" name="X8195D6F47EE52806"></a></p>

<h5>13.4-4 IsCongruencePoset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCongruencePoset</code>( <var class="Arg">poset</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCayleyDigraphOfCongruences</code>( <var class="Arg">poset</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This category contains all congruence posets. A <em>congruence poset</em> is a partially ordered set of congruences over a specific semigroup, where the ordering is defined by containment according to <code class="func">IsSubrelation</code> (<a href="chap13_mj.html#X85075F1D878512F5"><span class="RefLink">13.5-1</span></a>): given two congruences <code class="code">cong1</code> and <code class="code">cong2</code>, we say that <code class="code">cong1</code> &lt; <code class="code">cong2</code> if and only if <code class="code">cong1</code> is a subrelation (a refinement) of <code class="code">cong2</code>. The congruences in a congruence poset can be left, right, or two-sided.</p>

<p>A congruence poset is a digraph (see <code class="func">IsDigraph</code> (<a href="https://gap-packages.github.io/io/doc/chap3_mj.html#X7877ADC77F85E630"><span class="RefLink">Digraphs: IsDigraph</span></a>)) with a vertex for each congruence, and an edge from vertex <code class="code">i</code> to vertex <code class="code">j</code> only if the congruence numbered <code class="code">i</code> is a subrelation of the congruence numbered <code class="code">j</code>. To avoid using an unnecessarily large amount of memory in some cases, a congruence poset does not necessarily belong to <code class="func">IsPartialOrderDigraph</code> (<a href="https://gap-packages.github.io/io/doc/chap6_mj.html#X82BAE6D37D49A145"><span class="RefLink">Digraphs: IsPartialOrderDigraph</span></a>). In other words, although every congruence poset represents a partial order it is not necessarily the case that there is an edge from vertex <code class="code">i</code> to vertex <code class="code">j</code> if and only if the congruence numbered <code class="code">i</code> is a subrelation of the congruence numbered <code class="code">j</code>.</p>

<p>The list of congruences can be obtained using <code class="func">CongruencesOfPoset</code> (<a href="chap13_mj.html#X7B2E2CEE8626FBC3"><span class="RefLink">13.4-8</span></a>); and the underlying semigroup of the poset can be obtained using <code class="func">UnderlyingSemigroupOfCongruencePoset</code> (<a href="chap13_mj.html#X830F42B582A2FAA0"><span class="RefLink">13.4-9</span></a>).</p>

<p>Congruence posets can be created using any of:</p>


<ul>
<li><p><code class="func">PosetOfCongruences</code> (<a href="chap13_mj.html#X78A91138818A4FAE"><span class="RefLink">13.4-10</span></a>),</p>

</li>
<li><p><code class="func">JoinSemilatticeOfCongruences</code> (<a href="chap13_mj.html#X87CF25A178B7F1AF"><span class="RefLink">13.4-11</span></a>)</p>

</li>
<li><p><code class="func">LatticeOfCongruences</code> (<a href="chap13_mj.html#X86C9C5BA7FE93F4C"><span class="RefLink">13.4-5</span></a>), <code class="func">LatticeOfLeftCongruences</code> (<a href="chap13_mj.html#X86C9C5BA7FE93F4C"><span class="RefLink">13.4-5</span></a>), or <code class="func">LatticeOfRightCongruences</code> (<a href="chap13_mj.html#X86C9C5BA7FE93F4C"><span class="RefLink">13.4-5</span></a>)</p>

</li>
<li><p><code class="func">CayleyDigraphOfCongruences</code> (<a href="chap13_mj.html#X784CFDE37A0B4F84"><span class="RefLink">13.4-6</span></a>), <code class="func">CayleyDigraphOfLeftCongruences</code> (<a href="chap13_mj.html#X784CFDE37A0B4F84"><span class="RefLink">13.4-6</span></a>), or <code class="func">CayleyDigraphOfRightCongruences</code> (<a href="chap13_mj.html#X784CFDE37A0B4F84"><span class="RefLink">13.4-6</span></a>).</p>

</li>
</ul>
<p><code class="code">IsCayleyDigraphOfCongruences</code> only applies to the output of <code class="func">JoinSemilatticeOfCongruences</code> (<a href="chap13_mj.html#X87CF25A178B7F1AF"><span class="RefLink">13.4-11</span></a>), <code class="func">CayleyDigraphOfCongruences</code> (<a href="chap13_mj.html#X784CFDE37A0B4F84"><span class="RefLink">13.4-6</span></a>), <code class="func">CayleyDigraphOfLeftCongruences</code> (<a href="chap13_mj.html#X784CFDE37A0B4F84"><span class="RefLink">13.4-6</span></a>), and <code class="func">CayleyDigraphOfRightCongruences</code> (<a href="chap13_mj.html#X784CFDE37A0B4F84"><span class="RefLink">13.4-6</span></a>). The congruences used as the generating set for these operations can be obtained using <code class="func">GeneratingCongruencesOfJoinSemilattice</code> (<a href="chap13_mj.html#X7ECE04727B6A58A3"><span class="RefLink">13.4-12</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricInverseMonoid(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poset := LatticeOfCongruences(S);</span>
&lt;lattice of 4 two-sided congruences over
 &lt;symmetric inverse monoid of degree 2&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruencePoset(poset);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraph(poset);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(poset,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Digraph([[1, 2, 3, 4], [2], [2, 3], [2, 3, 4]]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := FullTransformationMonoid(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">congs := PrincipalCongruencesOfSemigroup(T);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poset := JoinSemilatticeOfCongruences(PosetOfCongruences(congs));</span>
&lt;lattice of 6 two-sided congruences over
 &lt;full transformation monoid of degree 3&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCayleyDigraphOfCongruences(poset);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruencePoset(poset);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(poset);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poset := CayleyDigraphOfCongruences(T);</span>
&lt;poset of 7 two-sided congruences over
 &lt;full transformation monoid of degree 3&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCayleyDigraphOfCongruences(poset);</span>
true
</pre></div>

<p><a id="X86C9C5BA7FE93F4C" name="X86C9C5BA7FE93F4C"></a></p>

<h5>13.4-5 LatticeOfCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticeOfCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticeOfLeftCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticeOfRightCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticeOfCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticeOfLeftCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticeOfRightCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A lattice digraph.</p>

<p>If <var class="Arg">S</var> is a semigroup, then <code class="code">LatticeOfCongruences</code> returns a congruence poset object containing all the congruences of <var class="Arg">S</var> and information about how they are contained in each other. See <code class="func">IsCongruencePoset</code> (<a href="chap13_mj.html#X8195D6F47EE52806"><span class="RefLink">13.4-4</span></a>) for more details.</p>

<p><code class="code">LatticeOfLeftCongruences</code> and <code class="code">LatticeOfRightCongruences</code> do the same thing for left and right congruences, respectively.</p>

<p>If <var class="Arg">restriction</var> is specified and is a collection of elements from <var class="Arg">S</var>, then the result will only include congruences generated by pairs of elements from <var class="Arg">restriction</var>. Otherwise, all congruences will be calculated.</p>

<p>See <code class="func">CongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7E8D5BA27CB5A4DA"><span class="RefLink">13.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := OrderEndomorphisms(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LatticeOfCongruences(S);</span>
&lt;lattice of 3 two-sided congruences over &lt;regular transformation
 monoid of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LatticeOfLeftCongruences(S);</span>
&lt;lattice of 3 left congruences over &lt;regular transformation monoid
 of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LatticeOfRightCongruences(S);</span>
&lt;lattice of 5 right congruences over &lt;regular transformation monoid
 of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(LatticeOfRightCongruences(S),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Digraph([[1, 2, 3, 4, 5], [2], [2, 3], [2, 4], [2, 5]]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := FullTransformationMonoid(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">restriction := [Transformation([1, 1, 1, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Transformation([1, 1, 1, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Transformation([1, 1, 1, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">latt := LatticeOfCongruences(S, Combinations(restriction, 2));</span>
&lt;lattice of 2 two-sided congruences over
 &lt;full transformation monoid of degree 4&gt;&gt;
</pre></div>

<p><a id="X784CFDE37A0B4F84" name="X784CFDE37A0B4F84"></a></p>

<h5>13.4-6 CayleyDigraphOfCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CayleyDigraphOfCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CayleyDigraphOfLeftCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CayleyDigraphOfRightCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CayleyDigraphOfCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CayleyDigraphOfLeftCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CayleyDigraphOfRightCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A digraph.</p>

<p>If <var class="Arg">S</var> is a semigroup, then <code class="code">CayleyDigraphOfCongruences</code> returns the right Cayley graph of the semilattice of congruences of <var class="Arg">S</var> with respect to the generating set consisting of the principal congruences congruence poset. See <code class="func">IsCayleyDigraphOfCongruences</code> (<a href="chap13_mj.html#X8195D6F47EE52806"><span class="RefLink">13.4-4</span></a>) for more details.</p>

<p><code class="code">CayleyDigraphOfLeftCongruences</code> and <code class="code">CayleyDigraphOfRightCongruences</code> do the same thing for left and right congruences, respectively.</p>

<p>If <var class="Arg">restriction</var> is specified and is a collection of elements from <var class="Arg">S</var>, then the result will only include congruences generated by pairs of elements from <var class="Arg">restriction</var>. Otherwise, all congruences will be calculated.</p>

<p>Note that <code class="func">LatticeOfCongruences</code> (<a href="chap13_mj.html#X86C9C5BA7FE93F4C"><span class="RefLink">13.4-5</span></a>), and its analogues for right and left congruences, return the reflexive transitive closure of the digraph returned by this function (with any multiple edges removed). If there are a large number of congruences, then it might be the case that forming the reflexive transitive closure takes a significant amount of time, and so it might be desirable to use this function instead.</p>

<p>See <code class="func">CongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7E8D5BA27CB5A4DA"><span class="RefLink">13.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := OrderEndomorphisms(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CayleyDigraphOfCongruences(S);</span>
&lt;poset of 3 two-sided congruences over &lt;regular transformation monoid
 of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CayleyDigraphOfLeftCongruences(S);</span>
&lt;poset of 3 left congruences over &lt;regular transformation monoid
 of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CayleyDigraphOfRightCongruences(S);</span>
&lt;poset of 5 right congruences over &lt;regular transformation monoid
 of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(CayleyDigraphOfRightCongruences(S),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Digraph([[2, 3, 4], [2, 5, 5], [5, 3, 5], [5, 5, 4], [5, 5, 5]]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := FullTransformationMonoid(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">restriction := [Transformation([1, 1, 1, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Transformation([1, 1, 1, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Transformation([1, 1, 1, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CayleyDigraphOfCongruences(S, Combinations(restriction, 2));</span>
&lt;poset of 2 two-sided congruences over
 &lt;full transformation monoid of degree 4&gt;&gt;
</pre></div>

<p><a id="X83ACF2C0789F621B" name="X83ACF2C0789F621B"></a></p>

<h5>13.4-7 PosetOfPrincipalCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PosetOfPrincipalCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PosetOfPrincipalLeftCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PosetOfPrincipalRightCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PosetOfPrincipalCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PosetOfPrincipalLeftCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PosetOfPrincipalRightCongruences</code>( <var class="Arg">S</var>, <var class="Arg">restriction</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A congruence poset.</p>

<p>If <var class="Arg">S</var> is a semigroup, then <code class="code">PosetOfPrincipalCongruences</code> returns a congruence poset object which contains all the principal congruences of <var class="Arg">S</var>, ordered by containment according to <code class="func">IsSubrelation</code> (<a href="chap13_mj.html#X85075F1D878512F5"><span class="RefLink">13.5-1</span></a>). A congruence is <em>principal</em> if it can be defined by a single generating pair. <code class="code">PosetOfPrincipalLeftCongruences</code> and <code class="code">PosetOfPrincipalRightCongruences</code> do the same thing for left and right congruences respectively.</p>

<p>If <var class="Arg">restriction</var> is specified and is a collection of elements from <var class="Arg">S</var>, then the result will only include principal congruences generated by pairs of elements from <var class="Arg">restriction</var>. Otherwise, all principal congruences will be calculated.</p>

<p>See also <code class="func">LatticeOfCongruences</code> (<a href="chap13_mj.html#X86C9C5BA7FE93F4C"><span class="RefLink">13.4-5</span></a>) and <code class="func">PrincipalCongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7986F3597F9DF7AF"><span class="RefLink">13.4-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 3, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([2, 3, 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PosetOfPrincipalLeftCongruences(S);</span>
&lt;poset of 12 left congruences over &lt;transformation semigroup
 of size 11, degree 3 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PosetOfPrincipalCongruences(S);</span>
&lt;lattice of 3 two-sided congruences over &lt;transformation semigroup
 of size 11, degree 3 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">restriction := [Transformation([3, 2, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Transformation([3, 1, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Transformation([2, 2, 2])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poset := PosetOfPrincipalRightCongruences(S,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Combinations(restriction, 2));</span>
&lt;poset of 3 right congruences over &lt;transformation semigroup
 of size 11, degree 3 with 2 generators&gt;&gt;
</pre></div>

<p><a id="X7B2E2CEE8626FBC3" name="X7B2E2CEE8626FBC3"></a></p>

<h5>13.4-8 CongruencesOfPoset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CongruencesOfPoset</code>( <var class="Arg">poset</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>If <var class="Arg">poset</var> is a congruence poset object, then this attribute returns a list of all the congruence objects in the poset (these may be left, right, or two-sided). The order of this list corresponds to the order of the entries in the poset.</p>

<p>See also <code class="func">LatticeOfCongruences</code> (<a href="chap13_mj.html#X86C9C5BA7FE93F4C"><span class="RefLink">13.4-5</span></a>) and <code class="func">CongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7E8D5BA27CB5A4DA"><span class="RefLink">13.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := OrderEndomorphisms(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">latt := LatticeOfRightCongruences(S);</span>
&lt;lattice of 5 right congruences over &lt;regular transformation monoid
 of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CongruencesOfPoset(latt);</span>
[ &lt;2-sided semigroup congruence over &lt;regular transformation monoid
     of size 3, degree 2 with 2 generators&gt; with 0 generating pairs&gt;,
  &lt;right semigroup congruence over &lt;regular transformation monoid
     of size 3, degree 2 with 2 generators&gt; with 1 generating pairs&gt;,
  &lt;right semigroup congruence over &lt;regular transformation monoid
     of size 3, degree 2 with 2 generators&gt; with 1 generating pairs&gt;,
  &lt;right semigroup congruence over &lt;regular transformation monoid
     of size 3, degree 2 with 2 generators&gt; with 1 generating pairs&gt;,
  &lt;right semigroup congruence over &lt;regular transformation monoid
     of size 3, degree 2 with 2 generators&gt; with 2 generating pairs&gt; ]
</pre></div>

<p><a id="X830F42B582A2FAA0" name="X830F42B582A2FAA0"></a></p>

<h5>13.4-9 UnderlyingSemigroupOfCongruencePoset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingSemigroupOfCongruencePoset</code>( <var class="Arg">poset</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup.</p>

<p>If <var class="Arg">poset</var> is a congruence poset object, then this attribute returns the semigroup on which all its congruences are defined.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := OrderEndomorphisms(2);</span>
&lt;regular transformation monoid of degree 2 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">latt := LatticeOfRightCongruences(S);</span>
&lt;lattice of 5 right congruences over &lt;regular transformation monoid
 of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingSemigroupOfCongruencePoset(latt) = S;</span>
true
</pre></div>

<p><a id="X78A91138818A4FAE" name="X78A91138818A4FAE"></a></p>

<h5>13.4-10 PosetOfCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PosetOfCongruences</code>( <var class="Arg">coll</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A congruence poset.</p>

<p>If <var class="Arg">coll</var> is a list or collection of semigroup congruences (which may be left, right, or two-sided) then this operation returns the congruence poset formed by these congruences partially ordered by containment.</p>

<p>This operation does not create any new congruences or take any joins. See also <code class="func">JoinSemilatticeOfCongruences</code> (<a href="chap13_mj.html#X87CF25A178B7F1AF"><span class="RefLink">13.4-11</span></a>), <code class="func">IsCongruencePoset</code> (<a href="chap13_mj.html#X8195D6F47EE52806"><span class="RefLink">13.4-4</span></a>), and <code class="func">LatticeOfCongruences</code> (<a href="chap13_mj.html#X86C9C5BA7FE93F4C"><span class="RefLink">13.4-5</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := OrderEndomorphisms(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [Transformation([1, 1]), IdentityTransformation];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [IdentityTransformation, Transformation([2, 2])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := [RightSemigroupCongruence(S, pair1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            RightSemigroupCongruence(S, pair2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            RightSemigroupCongruence(S, [])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poset := PosetOfCongruences(coll);</span>
&lt;poset of 3 right congruences over &lt;regular transformation monoid
 of size 3, degree 2 with 2 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(poset);</span>
[ [ 1 ], [ 2 ], [ 1, 2, 3 ] ]
</pre></div>

<p><a id="X87CF25A178B7F1AF" name="X87CF25A178B7F1AF"></a></p>

<h5>13.4-11 JoinSemilatticeOfCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JoinSemilatticeOfCongruences</code>( <var class="Arg">poset</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A congruence poset.</p>

<p>If <var class="Arg">poset</var> is a congruence poset (i.e. it satisfies <code class="func">IsCongruencePoset</code> (<a href="chap13_mj.html#X8195D6F47EE52806"><span class="RefLink">13.4-4</span></a>)), then this function returns the congruence poset formed by these congruences partially ordered by containment, along with all their joins. This includes the empty join which equals the trivial congruence.</p>

<p>The digraph returned by this function represents the Cayley graph of the semilattice generated by <code class="func">CongruencesOfPoset</code> (<a href="chap13_mj.html#X7B2E2CEE8626FBC3"><span class="RefLink">13.4-8</span></a>) with identity adjoined. The reflexive transitive closure of this digraph is a join semillatice in the sense of <code class="func">IsJoinSemilatticeDigraph</code> (<a href="https://gap-packages.github.io/io/doc/chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">Digraphs: IsJoinSemilatticeDigraph</span></a>).</p>

<p>See also <code class="func">IsCongruencePoset</code> (<a href="chap13_mj.html#X8195D6F47EE52806"><span class="RefLink">13.4-4</span></a>) and <code class="func">PosetOfCongruences</code> (<a href="chap13_mj.html#X78A91138818A4FAE"><span class="RefLink">13.4-10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricInverseMonoid(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [PartialPerm([1], [1]), PartialPerm([2], [1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [PartialPerm([1], [1]), PartialPerm([1, 2], [1, 2])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair3 := [PartialPerm([1, 2], [1, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             PartialPerm([1, 2], [2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := [RightSemigroupCongruence(S, pair1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            RightSemigroupCongruence(S, pair2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            RightSemigroupCongruence(S, pair3)];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := JoinSemilatticeOfCongruences(PosetOfCongruences(coll));</span>
&lt;poset of 4 right congruences over
 &lt;symmetric inverse monoid of degree 2&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsJoinSemilatticeDigraph(DigraphReflexiveTransitiveClosure(D));</span>
true</pre></div>

<p><a id="X7ECE04727B6A58A3" name="X7ECE04727B6A58A3"></a></p>

<h5>13.4-12 GeneratingCongruencesOfJoinSemilattice</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneratingCongruencesOfJoinSemilattice</code>( <var class="Arg">poset</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of congruences.</p>

<p>If <var class="Arg">poset</var> satisfies <code class="func">IsCayleyDigraphOfCongruences</code> (<a href="chap13_mj.html#X8195D6F47EE52806"><span class="RefLink">13.4-4</span></a>), then this attribute holds the generating set for the semilattice of congruences (where the operation is join).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := OrderEndomorphisms(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CayleyDigraphOfCongruences(S);</span>
&lt;poset of 4 two-sided congruences over &lt;regular transformation monoid
 of size 10, degree 3 with 3 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratingCongruencesOfJoinSemilattice(D);</span>
[ &lt;universal semigroup congruence over &lt;regular transformation monoid
     of size 10, degree 3 with 3 generators&gt;&gt;,
  &lt;2-sided semigroup congruence over &lt;regular transformation monoid
     of size 10, degree 3 with 3 generators&gt; with 1 generating pairs&gt;,
  &lt;2-sided semigroup congruence over &lt;regular transformation monoid
     of size 10, degree 3 with 3 generators&gt; with 1 generating pairs&gt;
 ]
</pre></div>

<p><a id="X780E2B3F8509CE32" name="X780E2B3F8509CE32"></a></p>

<h5>13.4-13 MinimalCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalCongruences</code>( <var class="Arg">coll</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalCongruences</code>( <var class="Arg">poset</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>If <var class="Arg">coll</var> is a list or collection of semigroup congruences (which may be left, right, or two-sided) then this attribute returns a list of all the congruences from <var class="Arg">coll</var> which do not contain any of the others as subrelations.</p>

<p>Alternatively, a congruence poset <var class="Arg">poset</var> can be specified; in this case, the congruences contained in <var class="Arg">poset</var> will be used in place of <var class="Arg">coll</var>, and information already known about their containments will be used.</p>

<p>This function should not be confused with <code class="func">MinimalCongruencesOfSemigroup</code> (<a href="chap13_mj.html#X7838738987B2DB41"><span class="RefLink">13.4-2</span></a>). See also <code class="func">IsCongruencePoset</code> (<a href="chap13_mj.html#X8195D6F47EE52806"><span class="RefLink">13.4-4</span></a>) and <code class="func">PosetOfCongruences</code> (<a href="chap13_mj.html#X78A91138818A4FAE"><span class="RefLink">13.4-10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricInverseMonoid(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair1 := [PartialPerm([1], [1]), PartialPerm([2], [1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair2 := [PartialPerm([1], [1]), PartialPerm([1, 2], [1, 2])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pair3 := [PartialPerm([1, 2], [1, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             PartialPerm([1, 2], [2, 1])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := [RightSemigroupCongruence(S, pair1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            RightSemigroupCongruence(S, pair2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            RightSemigroupCongruence(S, pair3)];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalCongruences(PosetOfCongruences(coll));</span>
[ &lt;right semigroup congruence over &lt;symmetric inverse monoid of degree\
 2&gt; with 1 generating pairs&gt;,
  &lt;right semigroup congruence over &lt;symmetric inverse monoid of degree\
 2&gt; with 1 generating pairs&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poset := LatticeOfCongruences(S);</span>
&lt;lattice of 4 two-sided congruences over
 &lt;symmetric inverse monoid of degree 2&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalCongruences(poset);</span>
[ &lt;2-sided semigroup congruence over &lt;symmetric inverse monoid of degr\
ee 2&gt; with 0 generating pairs&gt; ]
</pre></div>

<p><a id="X7AE16F237E862934" name="X7AE16F237E862934"></a></p>

<h5>13.4-14 NumberOfRightCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfRightCongruences</code>( <var class="Arg">S</var>, <var class="Arg">n</var>, <var class="Arg">extra</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfLeftCongruences</code>( <var class="Arg">S</var>, <var class="Arg">n</var>, <var class="Arg">extra</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfRightCongruences</code>( <var class="Arg">S</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfLeftCongruences</code>( <var class="Arg">S</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfRightCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfLeftCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A non-negative integer.</p>

<p><code class="code">NumberOfRightCongruences</code> returns the number of right congruences of the semigroup <var class="Arg">S</var> with at most <var class="Arg">n</var> classes that contain the pairs in <var class="Arg">extra</var>; <code class="code">NumberOfLeftCongruences</code> is defined dually for left congruences rather than right congruences.</p>

<p>If the optional third argument <var class="Arg">extra</var> is not present, then <code class="code">NumberOfRightCongruences</code> returns the number of right congruences of <var class="Arg">S</var> with at most <var class="Arg">n</var> classes.</p>

<p>If the optional second argument <var class="Arg">n</var> is not present, then <code class="code">NumberOfRightCongruences</code> returns the number of right congruences of <var class="Arg">S</var>.</p>

<p>Note that the 2 and 3 argument variants of this function can be applied to infinite semigroups, but the 1 argument variant cannot.</p>

<p>If the lattice of right or left congruences of <var class="Arg">S</var> is known, then that is used by <code class="code">NumberOfRightCongruences</code>. If this lattice is not known, then Sim's low index congruence algorithm is used.</p>

<p>See <code class="func">IteratorOfRightCongruences</code> (<a href="chap13_mj.html#X807A5FCC87661FA4"><span class="RefLink">13.4-15</span></a>) to actually obtain the congruences counted by this function.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := PartitionMonoid(2);</span>
&lt;regular bipartition *-monoid of size 15, degree 2 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfRightCongruences(S, 10);</span>
86
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfLeftCongruences(S, 10);</span>
86
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfRightCongruences(S, Size(S), [[S.1, S.2], [S.1, S.3]]);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfLeftCongruences(S, Size(S), [[S.1, S.2], [S.1, S.3]]);</span>
1
</pre></div>

<p><a id="X807A5FCC87661FA4" name="X807A5FCC87661FA4"></a></p>

<h5>13.4-15 IteratorOfRightCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorOfRightCongruences</code>( <var class="Arg">S</var>, <var class="Arg">n</var>, <var class="Arg">extra</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorOfLeftCongruences</code>( <var class="Arg">S</var>, <var class="Arg">n</var>, <var class="Arg">extra</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorOfRightCongruences</code>( <var class="Arg">S</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorOfLeftCongruences</code>( <var class="Arg">S</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorOfRightCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorOfLeftCongruences</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An iterator.</p>

<p><code class="code">IteratorOfRightCongruences</code> returns an iterator where calling <code class="func">NextIterator</code> (<a href="https://docs.gap-system.org/doc/ref/chap30_mj.html#X879F62F77D1D1179"><span class="RefLink">Reference: NextIterator</span></a>) returns the next right congruence of the semigroup <var class="Arg">S</var> with at most <var class="Arg">n</var> classes that contain the pairs in <var class="Arg">extra</var>; <code class="code">IteratorOfLeftCongruences</code> is defined dually for left congruences rather than right congruences.</p>

<p>If the optional third argument <var class="Arg">extra</var> is not present, then <code class="code">IteratorOfRightCongruences</code> uses an empty list by default.</p>

<p>If the optional second argument <var class="Arg">n</var> is not present, then <code class="code">IteratorOfRightCongruences</code> uses <code class="code">Size(<var class="Arg">S</var>)</code> by default.</p>

<p>Note that the 2 and 3 argument variants of this function can be applied to infinite semigroups, but the 1 argument variant cannot.</p>

<p>If the lattice of right or left congruences of <var class="Arg">S</var> is known, then that is used by <code class="code">IteratorOfRightCongruences</code>. If this lattice is not known, then Sim's low index congruence algorithm is used.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeMonoidAndAssignGeneratorVars("a", "b");</span>
&lt;free monoid on the generators [ a, b ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := [[a ^ 3, a], [b ^ 2, b], [(a * b) ^ 2, a]];</span>
[ [ a^3, a ], [ b^2, b ], [ (a*b)^2, a ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := F / R;</span>
&lt;fp monoid with 2 generators and 3 relations of length 14&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfRightCongruences(S);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">it := IteratorOfRightCongruences(S);</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(WordGraph(NextIterator(it)));</span>
[ [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(WordGraph(NextIterator(it)));</span>
[ [ 2, 1 ], [ 2, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(WordGraph(NextIterator(it)));</span>
[ [ 2, 2 ], [ 2, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(WordGraph(NextIterator(it)));</span>
[ [ 2, 3 ], [ 2, 2 ], [ 2, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(WordGraph(NextIterator(it)));</span>
[ [ 2, 3 ], [ 2, 2 ], [ 3, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(WordGraph(NextIterator(it)));</span>
[ [ 2, 3 ], [ 2, 2 ], [ 4, 3 ], [ 4, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(it);</span>
fail</pre></div>

<p><a id="X857D750579B87DBF" name="X857D750579B87DBF"></a></p>

<h4>13.5 <span class="Heading">
      Comparing congruences
    </span></h4>

<p><a id="X85075F1D878512F5" name="X85075F1D878512F5"></a></p>

<h5>13.5-1 IsSubrelation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubrelation</code>( <var class="Arg">cong1</var>, <var class="Arg">cong2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: True or false.</p>

<p>If <var class="Arg">cong1</var> and <var class="Arg">cong2</var> are congruences over the same semigroup, then this operation returns whether <var class="Arg">cong2</var> is a refinement of <var class="Arg">cong1</var>, i.e. whether every pair in <var class="Arg">cong2</var> is contained in <var class="Arg">cong1</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(SymmetricGroup(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[(), (1, 3, 2)], [(1, 2), 0]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong1 := SemigroupCongruence(S, [RMSElement(S, 1, (1, 2, 3), 1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    RMSElement(S, 1, (), 1)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong2 := SemigroupCongruence(S, []);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubrelation(cong1, cong2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubrelation(cong2, cong1);</span>
false</pre></div>

<p><a id="X83878AED7A8E75BE" name="X83878AED7A8E75BE"></a></p>

<h5>13.5-2 IsSuperrelation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSuperrelation</code>( <var class="Arg">cong1</var>, <var class="Arg">cong2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: True or false.</p>

<p>If <var class="Arg">cong1</var> and <var class="Arg">cong2</var> are congruences over the same semigroup, then this operation returns whether <var class="Arg">cong1</var> is a refinement of <var class="Arg">cong2</var>, i.e. whether every pair in <var class="Arg">cong1</var> is contained in <var class="Arg">cong2</var>.</p>

<p>See <code class="func">IsSubrelation</code> (<a href="chap13_mj.html#X85075F1D878512F5"><span class="RefLink">13.5-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(SymmetricGroup(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[(), (1, 3, 2)], [(1, 2), 0]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong1 := SemigroupCongruence(S, [RMSElement(S, 1, (1, 2, 3), 1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    RMSElement(S, 1, (), 1)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong2 := SemigroupCongruence(S, []);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSuperrelation(cong1, cong2);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSuperrelation(cong2, cong1);</span>
true</pre></div>

<p><a id="X7952A5A5789C6F60" name="X7952A5A5789C6F60"></a></p>

<h5>13.5-3 MeetSemigroupCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MeetSemigroupCongruences</code>( <var class="Arg">c1</var>, <var class="Arg">c2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MeetLeftSemigroupCongruences</code>( <var class="Arg">c1</var>, <var class="Arg">c2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MeetRightSemigroupCongruences</code>( <var class="Arg">c1</var>, <var class="Arg">c2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup congruence.</p>

<p>This operation returns the <em>meet</em> of the two semigroup congruences <var class="Arg">c1</var> and <var class="Arg">c2</var> -- that is, the largest semigroup congruence contained in both <var class="Arg">c1</var> and <var class="Arg">c2</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(SymmetricGroup(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[(), (1, 3, 2)], [(1, 2), 0]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong1 := SemigroupCongruence(S, [RMSElement(S, 1, (1, 2, 3), 1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    RMSElement(S, 1, (), 1)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong2 := SemigroupCongruence(S, []);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MeetSemigroupCongruences(cong1, cong2);</span>
&lt;semigroup congruence over &lt;Rees 0-matrix semigroup 2x2 over
  Sym( [ 1 .. 3 ] )&gt; with linked triple (1,2,2)&gt;</pre></div>

<p><a id="X8262D5207DBF3C5B" name="X8262D5207DBF3C5B"></a></p>

<h5>13.5-4 JoinSemigroupCongruences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JoinSemigroupCongruences</code>( <var class="Arg">c1</var>, <var class="Arg">c2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JoinLeftSemigroupCongruences</code>( <var class="Arg">c1</var>, <var class="Arg">c2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JoinRightSemigroupCongruences</code>( <var class="Arg">c1</var>, <var class="Arg">c2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup congruence.</p>

<p>This operation returns the <em>join</em> of the two semigroup congruences <var class="Arg">c1</var> and <var class="Arg">c2</var> -- that is, the smallest semigroup congruence containing all the relations in both <var class="Arg">c1</var> and <var class="Arg">c2</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(SymmetricGroup(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[(), (1, 3, 2)], [(1, 2), 0]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong1 := SemigroupCongruence(S, [RMSElement(S, 1, (1, 2, 3), 1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    RMSElement(S, 1, (), 1)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong2 := SemigroupCongruence(S, []);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">JoinSemigroupCongruences(cong1, cong2);</span>
&lt;semigroup congruence over &lt;Rees 0-matrix semigroup 2x2 over
  Sym( [ 1 .. 3 ] )&gt; with linked triple (3,2,2)&gt;</pre></div>

<p><a id="X7A6478D1831DD787" name="X7A6478D1831DD787"></a></p>

<h4>13.6 <span class="Heading">Congruences on Rees matrix semigroups</span></h4>

<p>This section describes the implementation of congruences of simple and 0-simple semigroups in the <strong class="pkg">Semigroups</strong> package, and the functions associated with them. This code and this part of the manual were written by Michael Young. Most of the theorems used in this chapter are from Section 3.5 of <a href="chapBib_mj.html#biBHowie1995aa">[How95]</a>.</p>

<p>By the Rees Theorem, any 0-simple semigroup <span class="SimpleMath">\(S\)</span> is isomorphic to a <em>Rees 0-matrix semigroup</em> (see <a href="https://docs.gap-system.org/doc/ref/chap51_mj.html#X8225A9EC87A255E6"><span class="RefLink">Reference: Rees Matrix Semigroups</span></a>) over a group, with a regular sandwich matrix. That is,</p>

<p class="center">\[S \cong \mathcal{M} ^ 0[G; I, \Lambda; P], \]</p>

<p>where <span class="SimpleMath">\(G\)</span> is a group, <span class="SimpleMath">\(\Lambda\)</span> and <span class="SimpleMath">\(I\)</span> are non-empty sets, and <span class="SimpleMath">\(P\)</span> is regular in the sense that it has no rows or columns consisting solely of zeroes.</p>

<p>The congruences of a Rees 0-matrix semigroup are in 1-1 correspondence with the <em>linked triple</em>, which is a triple of the form <code class="code">[N, S, T]</code> where:</p>


<ul>
<li><p><code class="code">N</code> is a normal subgroup of the underlying group <code class="code">G</code>,</p>

</li>
<li><p><code class="code">S</code> is an equivalence relation on the columns of <code class="code">P</code>,</p>

</li>
<li><p><code class="code">T</code> is an equivalence relation on the rows of <code class="code">P</code>,</p>

</li>
</ul>
<p>satisfying the following conditions:</p>


<ul>
<li><p>a pair of <code class="code">S</code>-related columns must contain zeroes in precisely the same rows,</p>

</li>
<li><p>a pair of <code class="code">T</code>-related rows must contain zeroes in precisely the same columns,</p>

</li>
<li><p>if <code class="code">i</code> and <code class="code">j</code> are <code class="code">S</code>-related, <code class="code">k</code> and <code class="code">l</code> are <code class="code">T</code>-related and the matrix entries <span class="SimpleMath">\(p_{k, i}, p_{k, j}, p_{l, i}, p_{l, j} \neq 0\)</span>, then <span class="SimpleMath">\(q_{k, l, i, j} \in N\)</span>, where</p>

<p class="center">\[q_{k, l, i, j} = p_{k, i}
        p_{l, i} ^ {-1} p_{l, j} p_{k, j} ^ {-1}.\]</p>

</li>
</ul>
<p>By Theorem 3.5.9 in <a href="chapBib_mj.html#biBHowie1995aa">[How95]</a>, for any finite 0-simple Rees 0-matrix semigroup, there is a bijection between its non-universal congruences and its linked triples. In this way, we can internally represent any congruence of such a semigroup by storing its associated linked triple instead of a set of generating pairs, and thus perform many calculations on it more efficiently.</p>

<p>If a congruence is defined by a linked triple <code class="code">(N, S, T)</code>, then a single class of that congruence can be defined by a triple <code class="code">(Nx, i / S, k / S)</code>, where <code class="code">Nx</code> is a right coset of <code class="code">N</code>, <code class="code">i / S</code> is the equivalence class of <code class="code">i</code> in <code class="code">S</code>, and <code class="code">k / S</code> is the equivalence class of <code class="code">k</code> in <code class="code">T</code>. Thus we can internally represent any class of such a congruence as a triple simply consisting of a right coset and two positive integers.</p>

<p>An analogous condition exists for finite simple Rees matrix semigroups without zero.</p>

<p><a id="X7F4AFD7F7E163022" name="X7F4AFD7F7E163022"></a></p>

<h5>13.6-1 IsRMSCongruenceByLinkedTriple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRMSCongruenceByLinkedTriple</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRZMSCongruenceByLinkedTriple</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>These categories describe a type of semigroup congruence over a Rees matrix or 0-matrix semigroup. Externally, an object of this type may be used in the same way as any other object in the category <code class="func">IsSemigroupCongruence</code> (<a href="https://docs.gap-system.org/doc/ref/chap51_mj.html#X78E34B737F0E009F"><span class="RefLink">Reference: IsSemigroupCongruence</span></a>) but it is represented internally by its <em>linked triple</em>, and certain functions may take advantage of this information to reduce computation times.</p>

<p>An object of this type may be constructed with <code class="code">RMSCongruenceByLinkedTriple</code> or <code class="code">RZMSCongruenceByLinkedTriple</code>, or this representation may be selected automatically by <code class="func">SemigroupCongruence</code> (<a href="chap13_mj.html#X85CE56AC84FA5D33"><span class="RefLink">13.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group([(1, 4, 5), (1, 5, 3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0, 0, (1, 4, 5), 0, 0, (1, 4, 3, 5)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [0, (), 0, 0, (3, 5), 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [(), 0, 0, (3, 5), 0, 0]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(G, mat);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := Group([(1, 4)(3, 5), (1, 5)(3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colBlocks := [[1], [2, 5], [3, 6], [4]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rowBlocks := [[1], [2], [3]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := RZMSCongruenceByLinkedTriple(S, N, colBlocks, rowBlocks);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRZMSCongruenceByLinkedTriple(cong);</span>
true</pre></div>

<p><a id="X87A475E4847D3C96" name="X87A475E4847D3C96"></a></p>

<h5>13.6-2 RMSCongruenceByLinkedTriple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RMSCongruenceByLinkedTriple</code>( <var class="Arg">S</var>, <var class="Arg">N</var>, <var class="Arg">colBlocks</var>, <var class="Arg">rowBlocks</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RZMSCongruenceByLinkedTriple</code>( <var class="Arg">S</var>, <var class="Arg">N</var>, <var class="Arg">colBlocks</var>, <var class="Arg">rowBlocks</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: A Rees matrix or 0-matrix semigroup congruence by linked triple.</p>

<p>This function returns a semigroup congruence over the Rees matrix or 0-matrix semigroup <var class="Arg">S</var> corresponding to the linked triple (<var class="Arg">N</var>, <var class="Arg">colBlocks</var>, <var class="Arg">rowBlocks</var>). The argument <var class="Arg">N</var> should be a normal subgroup of the underlying semigroup of <var class="Arg">S</var>; <var class="Arg">colBlocks</var> should be a partition of the columns of the matrix of <var class="Arg">S</var>; and <var class="Arg">rowBlocks</var> should be a partition of the rows of the matrix of <var class="Arg">S</var>. For example, if the matrix has 5 rows, then a possibility for <var class="Arg">rowBlocks</var> might be <code class="code">[[1, 3], [2, 5], [4]]</code>.</p>

<p>If the arguments describe a valid linked triple on <var class="Arg">S</var>, then an object in the category <code class="code">IsRZMSCongruenceByLinkedTriple</code> is returned. This object can be used like any other semigroup congruence in <strong class="pkg">GAP</strong>.</p>

<p>If the arguments describe a triple which is not <em>linked</em> in the sense described above, then this function returns an error.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group([(1, 4, 5), (1, 5, 3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0, 0, (1, 4, 5), 0, 0, (1, 4, 3, 5)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [0, (), 0, 0, (3, 5), 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [(), 0, 0, (3, 5), 0, 0]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(G, mat);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := Group([(1, 4)(3, 5), (1, 5)(3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colBlocks := [[1], [2, 5], [3, 6], [4]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rowBlocks := [[1], [2], [3]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := RZMSCongruenceByLinkedTriple(S, N, colBlocks, rowBlocks);;</span>
</pre></div>

<p><a id="X79E4CF7B79B25AE3" name="X79E4CF7B79B25AE3"></a></p>

<h5>13.6-3 IsRMSCongruenceClassByLinkedTriple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRMSCongruenceClassByLinkedTriple</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRZMSCongruenceClassByLinkedTriple</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>These categories contain the congruence classes of a semigroup congruence of the categories <code class="func">IsRMSCongruenceByLinkedTriple</code> (<a href="chap13_mj.html#X7F4AFD7F7E163022"><span class="RefLink">13.6-1</span></a>) and <code class="func">IsRZMSCongruenceByLinkedTriple</code> (<a href="chap13_mj.html#X7F4AFD7F7E163022"><span class="RefLink">13.6-1</span></a>) respectively.</p>

<p>An object of one of these types may be used in the same way as any other object in the category <code class="func">IsCongruenceClass</code> (<a href="chap13_mj.html#X7B1F67A97E23E6A4"><span class="RefLink">13.3-1</span></a>), but the class is represented internally by information related to the congruence's <em>linked triple</em>, and certain functions may take advantage of this information to reduce computation times.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group([(1, 4, 5), (1, 5, 3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0, 0, (1, 4, 5), 0, 0, (1, 4, 3, 5)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [0, (), 0, 0, (3, 5), 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [(), 0, 0, (3, 5), 0, 0]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(G, mat);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := Group([(1, 4)(3, 5), (1, 5)(3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colBlocks := [[1], [2, 5], [3, 6], [4]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rowBlocks := [[1], [2], [3]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := RZMSCongruenceByLinkedTriple(S, N, colBlocks, rowBlocks);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classes := EquivalenceClasses(cong);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRZMSCongruenceClassByLinkedTriple(classes[1]);</span>
true</pre></div>

<p><a id="X7E9AB940868FCC9D" name="X7E9AB940868FCC9D"></a></p>

<h5>13.6-4 RMSCongruenceClassByLinkedTriple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RMSCongruenceClassByLinkedTriple</code>( <var class="Arg">cong</var>, <var class="Arg">nCoset</var>, <var class="Arg">colClass</var>, <var class="Arg">rowClass</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RZMSCongruenceClassByLinkedTriple</code>( <var class="Arg">cong</var>, <var class="Arg">nCoset</var>, <var class="Arg">colClass</var>, <var class="Arg">rowClass</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A Rees matrix or 0-matrix semigroup congruence class by linked triple.</p>

<p>This operation returns one congruence class of the congruence <var class="Arg">cong</var>, as defined by the other three parameters.</p>

<p>The argument <var class="Arg">cong</var> must be a Rees matrix or 0-matrix semigroup congruence by linked triple. If the linked triple consists of the three parameters <code class="code">N</code>, <code class="code">colBlocks</code> and <code class="code">rowBlocks</code>, then <var class="Arg">nCoset</var> must be a right coset of <code class="code">N</code>, <var class="Arg">colClass</var> must be a positive integer corresponding to a position in the list <code class="code">colBlocks</code>, and <var class="Arg">rowClass</var> must be a positive integer corresponding to a position in the list <code class="code">rowBlocks</code>.</p>

<p>If the arguments are valid, an <code class="code">IsRMSCongruenceClassByLinkedTriple</code> or <code class="code">IsRZMSCongruenceClassByLinkedTriple</code> object is returned, which can be used like any other equivalence class in <strong class="pkg">GAP</strong>. Otherwise, an error is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group([(1, 4, 5), (1, 5, 3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0, 0, (1, 4, 5), 0, 0, (1, 4, 3, 5)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [0, (), 0, 0, (3, 5), 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [(), 0, 0, (3, 5), 0, 0]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(G, mat);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := Group([(1, 4)(3, 5), (1, 5)(3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colBlocks := [[1], [2, 5], [3, 6], [4]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rowBlocks := [[1], [2], [3]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := RZMSCongruenceByLinkedTriple(S, N, colBlocks, rowBlocks);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">class := RZMSCongruenceClassByLinkedTriple(cong,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">RightCoset(N, (1, 5)), 2, 3);</span>
&lt;2-sided congruence class of (2,(3,4),3)&gt;</pre></div>

<p><a id="X7B19CACF7A37ADBC" name="X7B19CACF7A37ADBC"></a></p>

<h5>13.6-5 IsLinkedTriple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLinkedTriple</code>( <var class="Arg">S</var>, <var class="Arg">N</var>, <var class="Arg">colBlocks</var>, <var class="Arg">rowBlocks</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This operation returns true if and only if the arguments (<var class="Arg">N</var>, <var class="Arg">colBlocks</var>, <var class="Arg">rowBlocks</var>) describe a linked triple of the Rees matrix or 0-matrix semigroup <var class="Arg">S</var>, as described above.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group([(1, 4, 5), (1, 5, 3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0, 0, (1, 4, 5), 0, 0, (1, 4, 3, 5)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [0, (), 0, 0, (3, 5), 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [(), 0, 0, (3, 5), 0, 0]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(G, mat);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := Group([(1, 4)(3, 5), (1, 5)(3, 4)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colBlocks := [[1], [2, 5], [3, 6], [4]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rowBlocks := [[1], [2], [3]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLinkedTriple(S, N, colBlocks, rowBlocks);</span>
true</pre></div>

<p><a id="X7DB7E32E865AD95D" name="X7DB7E32E865AD95D"></a></p>

<h5>13.6-6 AsSemigroupCongruenceByGeneratingPairs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSemigroupCongruenceByGeneratingPairs</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup congruence.</p>

<p>This operation takes <var class="Arg">cong</var>, a semigroup congruence, and returns the same congruence relation, but described by <strong class="pkg">GAP</strong>'s default method of defining semigroup congruences: a set of generating pairs for the congruence.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(SymmetricGroup(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                [[(), (1, 3, 2)], [(1, 2), 0]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := CongruencesOfSemigroup(S)[3];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSemigroupCongruenceByGeneratingPairs(cong);</span>
&lt;semigroup congruence over &lt;Rees 0-matrix semigroup 2x2 over
  Sym( [ 1 .. 3 ] )&gt; with linked triple (3,2,2)&gt;</pre></div>

<p><a id="X7BFDC38178940AE6" name="X7BFDC38178940AE6"></a></p>

<h4>13.7 <span class="Heading">
      Congruences on inverse semigroups
    </span></h4>

<p>This section describes the implementation of congruences of inverse semigroups in the <strong class="pkg">Semigroups</strong> package, and the functions associated with them. This code and this part of the manual were written by Michael Young. Most of the theorems used in this chapter are from Section 5.3 of <a href="chapBib_mj.html#biBHowie1995aa">[How95]</a>.</p>

<p>The congruences of an inverse semigroup are in 1-1 correspondence with its <em>congruence pairs</em>. A congruence pair is a pair <code class="code">(N, t)</code> such that:</p>


<ul>
<li><p><code class="code">N</code> is a normal subsemigroup of <code class="code">S</code> -- that is, a self-conjugate subsemigroup which contains all the idempotents of <code class="code">S</code>,</p>

</li>
<li><p><code class="code">t</code> is a normal congruence on <code class="code">E</code>, the subsemigroup of all idempotents in <code class="code">S</code> -- that is, a congruence on <code class="code">E</code> such that if <span class="SimpleMath">\((e, f)\)</span> is a pair in <code class="code">t</code>, then the pair <span class="SimpleMath">\((a ^ {-1} e a, a ^ {-1} f a)\)</span> is also in <code class="code">t</code>,</p>

</li>
</ul>
<p>satisfying the following conditions:</p>


<ul>
<li><p>If <span class="SimpleMath">\(ae \in N\)</span> and <span class="SimpleMath">\((e, a ^ {-1} a) \in t\)</span>, then <span class="SimpleMath">\(a \in N\)</span>,</p>

</li>
<li><p>If <span class="SimpleMath">\(a \in N\)</span>, then <span class="SimpleMath">\((aa ^ {-1} , a ^ {-1} a) \in t\)</span>.</p>

</li>
</ul>
<p>By Theorem 5.3.3 in <a href="chapBib_mj.html#biBHowie1995aa">[How95]</a>, for any inverse semigroup, there is a bijection between its congruences and its congruence pairs. In this way, we can internally represent any congruence of such a semigroup by storing its associated congruence pair instead of a set of generating pairs, and thus perform many calculations on it more efficiently.</p>

<p>If we have a congruence <code class="code">C</code> with congruence pair <code class="code">(N, t)</code>, it turns out that <code class="code">N</code> is its <em>kernel</em> (that is, the set of all elements congruent to an idempotent) and that <code class="code">t</code> is its <em>trace</em> (that is, the restriction of <code class="code">C</code> to the idempotents). Hence, we refer to a congruence stored in this format as a "congruence by kernel and trace".</p>

<p>See <code class="code">cong_by_ker_trace_threshold</code> in Section <a href="chap6_mj.html#X799EBA2F819D8867"><span class="RefLink">6.3</span></a> for details on when this method is used.</p>

<p><a id="X8546E48E85A2A7E8" name="X8546E48E85A2A7E8"></a></p>

<h5>13.7-1 IsInverseSemigroupCongruenceByKernelTrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsInverseSemigroupCongruenceByKernelTrace</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This category contains any inverse semigroup congruence <var class="Arg">cong</var> which is represented internally by its kernel and trace. The <code class="func">SemigroupCongruence</code> (<a href="chap13_mj.html#X85CE56AC84FA5D33"><span class="RefLink">13.2-1</span></a>) function may create an object of this category if its first argument <var class="Arg">S</var> is an inverse semigroup and has sufficiently large size. It can be treated like any other semigroup congruence object.</p>

<p>See <a href="chapBib_mj.html#biBHowie1995aa">[How95]</a> Section 5.3 for more details. See also <code class="func">InverseSemigroupCongruenceByKernelTrace</code> (<a href="chap13_mj.html#X7A588B737CEEB104"><span class="RefLink">13.7-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([4, 3, 1, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([1, 4, 2, 0, 3])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> rec(cong_by_ker_trace_threshold := 0));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(S, []);</span>
&lt;semigroup congruence over &lt;inverse partial perm semigroup
 of size 351, rank 5 with 2 generators&gt; with congruence pair (24,24)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInverseSemigroupCongruenceByKernelTrace(cong);</span>
true</pre></div>

<p><a id="X7A588B737CEEB104" name="X7A588B737CEEB104"></a></p>

<h5>13.7-2 InverseSemigroupCongruenceByKernelTrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseSemigroupCongruenceByKernelTrace</code>( <var class="Arg">S</var>, <var class="Arg">kernel</var>, <var class="Arg">traceBlocks</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: An inverse semigroup congruence by kernel and trace.</p>

<p>If <var class="Arg">S</var> is an inverse semigroup, <var class="Arg">kernel</var> is a subsemigroup of <var class="Arg">S</var>, <var class="Arg">traceBlocks</var> is a list of lists describing a congruence on the idempotents of <var class="Arg">S</var>, and <span class="SimpleMath">\((\textit{kernel}, \textit{trace})\)</span> describes a valid congruence pair for <var class="Arg">S</var> (see <a href="chapBib_mj.html#biBHowie1995aa">[How95]</a> Section 5.3) then this function returns the semigroup congruence defined by that congruence pair.</p>

<p>See also <code class="func">KernelOfSemigroupCongruence</code> (<a href="chap13_mj.html#X7D521AFF7876CBC7"><span class="RefLink">13.7-4</span></a>) and <code class="func">TraceOfSemigroupCongruence</code> (<a href="chap13_mj.html#X80972A5B82D88F89"><span class="RefLink">13.7-5</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PartialPerm([2, 3]), PartialPerm([2, 0, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kernel := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PartialPerm([1, 0, 3]), PartialPerm([0, 2, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PartialPerm([1, 2]), PartialPerm([3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PartialPerm([2])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">trace := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [PartialPerm([0, 2, 3])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [PartialPerm([1, 2])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [PartialPerm([1, 0, 3])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [PartialPerm([0, 0, 3]), PartialPerm([0, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PartialPerm([1]), PartialPerm([], [])]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := InverseSemigroupCongruenceByKernelTrace(S, kernel, trace);</span>
&lt;semigroup congruence over &lt;inverse partial perm semigroup of rank 3
 with 2 generators&gt; with congruence pair (13,4)&gt;</pre></div>

<p><a id="X87916D4E854F1F6B" name="X87916D4E854F1F6B"></a></p>

<h5>13.7-3 AsInverseSemigroupCongruenceByKernelTrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsInverseSemigroupCongruenceByKernelTrace</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An inverse semigroup congruence by kernel and trace.</p>

<p>If <var class="Arg">cong</var> is a semigroup congruence over an inverse semigroup, then this attribute returns an object which describes the same congruence, but with an internal representation defined by that congruence's kernel and trace.</p>

<p>See <a href="chapBib_mj.html#biBHowie1995aa">[How95]</a> section 5.3 for more details.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([2, 3]), PartialPerm([2, 0, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruenceByGeneratingPairs(I,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[PartialPerm([0, 1, 3]), PartialPerm([0, 1])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [PartialPerm([]), PartialPerm([1, 2])]]);</span>
&lt;2-sided semigroup congruence over &lt;inverse partial perm semigroup of
 rank 3 with 2 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong2 := AsInverseSemigroupCongruenceByKernelTrace(cong);</span>
&lt;semigroup congruence over &lt;inverse partial perm semigroup
 of size 19, rank 3 with 2 generators&gt; with congruence pair (19,1)&gt;</pre></div>

<p><a id="X7D521AFF7876CBC7" name="X7D521AFF7876CBC7"></a></p>

<h5>13.7-4 KernelOfSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KernelOfSemigroupCongruence</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An inverse semigroup.</p>

<p>If <var class="Arg">cong</var> is a congruence over a semigroup with inverse op, then this attribute returns the <em>kernel</em> of that congruence; that is, the inverse subsemigroup consisting of all elements which are related to an idempotent by <var class="Arg">cong</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([2, 3]), PartialPerm([2, 0, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(I,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[PartialPerm([0, 1, 3]), PartialPerm([0, 1])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [PartialPerm([]), PartialPerm([1, 2])]]);</span>
&lt;2-sided semigroup congruence over &lt;inverse partial perm semigroup
 of size 19, rank 3 with 2 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KernelOfSemigroupCongruence(cong);</span>
&lt;inverse partial perm semigroup of size 19, rank 3 with 5 generators&gt;
</pre></div>

<p><a id="X80972A5B82D88F89" name="X80972A5B82D88F89"></a></p>

<h5>13.7-5 TraceOfSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TraceOfSemigroupCongruence</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists.</p>

<p>If <var class="Arg">cong</var> is an inverse semigroup congruence by kernel and trace, then this attribute returns the restriction of <var class="Arg">cong</var> to the idempotents of the semigroup. This is in block form: each idempotent will appear in precisely one list, and two idempotents will be in the same list if and only if they are related by <var class="Arg">cong</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([2, 3]), PartialPerm([2, 0, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(I,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[PartialPerm([0, 1, 3]), PartialPerm([0, 1])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [PartialPerm([]), PartialPerm([1, 2])]]);</span>
&lt;2-sided semigroup congruence over &lt;inverse partial perm semigroup
 of size 19, rank 3 with 2 generators&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TraceOfSemigroupCongruence(cong);</span>
[ [ &lt;empty partial perm&gt;, &lt;identity partial perm on [ 1 ]&gt;,
      &lt;identity partial perm on [ 2 ]&gt;,
      &lt;identity partial perm on [ 1, 2 ]&gt;,
      &lt;identity partial perm on [ 3 ]&gt;,
      &lt;identity partial perm on [ 2, 3 ]&gt;,
      &lt;identity partial perm on [ 1, 3 ]&gt; ] ]</pre></div>

<p><a id="X8049A0E780A7A8D9" name="X8049A0E780A7A8D9"></a></p>

<h5>13.7-6 IsInverseSemigroupCongruenceClassByKernelTrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsInverseSemigroupCongruenceClassByKernelTrace</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This category contains any congruence class which belongs to a congruence which is represented internally by its kernel and trace. See <code class="func">InverseSemigroupCongruenceByKernelTrace</code> (<a href="chap13_mj.html#X7A588B737CEEB104"><span class="RefLink">13.7-2</span></a>).</p>

<p>See <a href="chapBib_mj.html#biBHowie1995aa">[How95]</a> Section 5.3 for more details.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([2, 3]), PartialPerm([2, 0, 3])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">rec(cong_by_ker_trace_threshold := 0));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(I,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[PartialPerm([0, 1, 3]), PartialPerm([0, 1])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [PartialPerm([]), PartialPerm([1, 2])]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">class := EquivalenceClassOfElement(cong,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                     PartialPerm([1, 2], [2, 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInverseSemigroupCongruenceClassByKernelTrace(class);</span>
true</pre></div>

<p><a id="X857495647F9A9579" name="X857495647F9A9579"></a></p>

<h5>13.7-7 MinimumGroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimumGroupCongruence</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An inverse semigroup congruence by kernel and trace.</p>

<p>If <var class="Arg">S</var> is an inverse semigroup, then this function returns the least congruence on <var class="Arg">S</var> whose quotient is a group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PartialPerm([5, 2, 0, 0, 1, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PartialPerm([1, 4, 6, 3, 5, 0, 2])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := MinimumGroupCongruence(S);</span>
&lt;semigroup congruence over &lt;inverse partial perm semigroup
 of size 101, rank 7 with 2 generators&gt; with congruence pair (59,1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupAsSemigroup(S / cong);</span>
true</pre></div>

<p><a id="X8036DAA287C71CAC" name="X8036DAA287C71CAC"></a></p>

<h4>13.8 <span class="Heading">
      Congruences on graph inverse semigroups
    </span></h4>

<p><a id="X7AEB7DA27E76145B" name="X7AEB7DA27E76145B"></a></p>

<h5>13.8-1 IsCongruenceByWangPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCongruenceByWangPair</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A congruence by Wang pair <code class="code">cong</code> is a congruence of a graph inverse semigroup <code class="code">S</code> which is expressed in terms of two sets <var class="Arg">H</var> and <var class="Arg">W</var> of vertices of the corresponding graph of <var class="Arg">S</var>. The set <var class="Arg">H</var> must be a hereditary subset (closed under reachability) and all vertices in <var class="Arg">W</var> must have all but one of their out-neighbours in <var class="Arg">H</var>. For more information on Wang pairs see <a href="chapBib_mj.html#biBWang2019aa">[Wan19]</a> and <a href="chapBib_mj.html#biBAnagnostopoulou-Merkouri2021aa">[AMM23]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 4], [3, 4], [4], []]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := GraphInverseSemigroup(D);</span>
&lt;finite graph inverse semigroup with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := CongruenceByWangPair(S, [3, 4], []);</span>
&lt;graph inverse semigroup congruence with H = [ 3, 4 ] and W = [  ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruenceByWangPair(cong);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := CongruenceByWangPair(S, [4], [2]);</span>
&lt;graph inverse semigroup congruence with H = [ 4 ] and W = [ 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruenceByWangPair(cong);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e_1 := S.1;</span>
e_1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e_3 := S.3;</span>
e_3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := SemigroupCongruence(S, [[e_1, e_3]]);</span>
&lt;2-sided semigroup congruence over &lt;finite graph inverse semigroup wit\
h 4 vertices, 5 edges&gt; with 1 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruenceByWangPair(cong);</span>
false
</pre></div>

<p><a id="X7F30D10F7BEEEBB9" name="X7F30D10F7BEEEBB9"></a></p>

<h5>13.8-2 CongruenceByWangPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CongruenceByWangPair</code>( <var class="Arg">S</var>, <var class="Arg">H</var>, <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup congruence.</p>

<p>This function returns a semigroup congruence over the graph inverse semigroup <var class="Arg">S</var> in the form of a Wang pair.</p>

<p>If <var class="Arg">S</var> is a finite graph inverse semigroup <var class="Arg">H</var> and <var class="Arg">W</var> are two lists of vertices in the graph of <var class="Arg">S</var> representing a valid hereditary subset and a W-set respectively, then this function will return the semigroup congruence defined by this Wang pair. For the definition of Wang pair <code class="func">IsCongruenceByWangPair</code> (<a href="chap13_mj.html#X7AEB7DA27E76145B"><span class="RefLink">13.8-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 4], [3, 4], [4], []]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := GraphInverseSemigroup(D);</span>
&lt;finite graph inverse semigroup with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := CongruenceByWangPair(S, [3, 4], []);</span>
&lt;graph inverse semigroup congruence with H = [ 3, 4 ] and W = [  ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := CongruenceByWangPair(S, [4], [2]);</span>
&lt;graph inverse semigroup congruence with H = [ 4 ] and W = [ 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := CongruenceByWangPair(S, [3, 4], []);</span>
&lt;graph inverse semigroup congruence with H = [ 3, 4 ] and W = [  ]&gt;
</pre></div>

<p><a id="X817F4FC27E9BACD8" name="X817F4FC27E9BACD8"></a></p>

<h5>13.8-3 AsCongruenceByWangPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsCongruenceByWangPair</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A congruence by Wang pair.</p>

<p>This operation takes <var class="Arg">cong</var>, a finite graph inverse semigroup congruence, and returns an object representing the same congruence, but described as a congruence by Wang pairs: a pair of sets <var class="Arg">H</var> and <var class="Arg">W</var> of the corresponding graph of <var class="Arg">S</var> that are a hereditary subset and a W-set of the graph of <var class="Arg">S</var> respectively. For more information about Wang pairs see <a href="chapBib_mj.html#biBWang2019aa">[Wan19]</a> and <a href="chapBib_mj.html#biBAnagnostopoulou-Merkouri2021aa">[AMM23]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [3], [4], []]);</span>
&lt;immutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := GraphInverseSemigroup(D);</span>
&lt;finite graph inverse semigroup with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CongruenceByWangPair(S, [4], [2]);</span>
&lt;graph inverse semigroup congruence with H = [ 4 ] and W = [ 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := AsSemigroupCongruenceByGeneratingPairs(last);</span>
&lt;2-sided semigroup congruence over &lt;finite graph inverse semigroup wit\
h 4 vertices, 4 edges&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCongruenceByWangPair(cong);</span>
&lt;graph inverse semigroup congruence with H = [ 4 ] and W = [ 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CongruenceByWangPair(S, [3, 4], [1]);</span>
&lt;graph inverse semigroup congruence with H = [ 3, 4 ] and W = [ 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := AsSemigroupCongruenceByGeneratingPairs(last);</span>
&lt;2-sided semigroup congruence over &lt;finite graph inverse semigroup wit\
h 4 vertices, 4 edges&gt; with 3 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCongruenceByWangPair(cong);</span>
&lt;graph inverse semigroup congruence with H = [ 3, 4 ] and W = [ 1 ]&gt;
</pre></div>

<p><a id="X858AE13379B5C380" name="X858AE13379B5C380"></a></p>

<h5>13.8-4 GeneratingCongruencesOfLattice</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneratingCongruencesOfLattice</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup.</p>

<p>This attribute takes a finite graph inverse semigroup <var class="Arg">S</var> and returns a minimal generating set for the lattice of congruences of <var class="Arg">S</var>, as described in <a href="chapBib_mj.html#biBAnagnostopoulou-Merkouri2021aa">[AMM23]</a>. This operation works only if the corresponding digraph of the graph inverse semigroup is simple. If there are multiple edges, an error is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [3], [4], []]);</span>
&lt;immutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := GraphInverseSemigroup(D);</span>
&lt;finite graph inverse semigroup with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CongruenceByWangPair(S, [4], [2]);</span>
&lt;graph inverse semigroup congruence with H = [ 4 ] and W = [ 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := AsSemigroupCongruenceByGeneratingPairs(last);</span>
&lt;2-sided semigroup congruence over &lt;finite graph inverse semigroup wit\
h 4 vertices, 4 edges&gt; with 2 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCongruenceByWangPair(cong);</span>
&lt;graph inverse semigroup congruence with H = [ 4 ] and W = [ 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CongruenceByWangPair(S, [3, 4], [1]);</span>
&lt;graph inverse semigroup congruence with H = [ 3, 4 ] and W = [ 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := AsSemigroupCongruenceByGeneratingPairs(last);</span>
&lt;2-sided semigroup congruence over &lt;finite graph inverse semigroup wit\
h 4 vertices, 4 edges&gt; with 3 generating pairs&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCongruenceByWangPair(cong);</span>
&lt;graph inverse semigroup congruence with H = [ 3, 4 ] and W = [ 1 ]&gt;
</pre></div>

<p><a id="X7CE483078769A4D6" name="X7CE483078769A4D6"></a></p>

<h4>13.9 <span class="Heading">Rees congruences</span></h4>

<p>A Rees congruence is defined by a semigroup ideal. It is a congruence on a semigroup <code class="code">S</code> which has one congruence class equal to a semigroup ideal <code class="code">I</code> of <code class="code">S</code>, and every other congruence class being a singleton.</p>

<p><a id="X7BC02E08840E0AF4" name="X7BC02E08840E0AF4"></a></p>

<h5>13.9-1 SemigroupIdealOfReesCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemigroupIdealOfReesCongruence</code>( <var class="Arg">cong</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup ideal.</p>

<p>If <var class="Arg">cong</var> is a rees congruence (see <code class="func">IsReesCongruence</code> (<a href="https://docs.gap-system.org/doc/ref/chap51_mj.html#X822DB78579BCB7B5"><span class="RefLink">Reference: IsReesCongruence</span></a>)) then this attribute returns the two-sided ideal that was used to define it, i.e.~the ideal of elements in the only non-trivial congruence class of <var class="Arg">cong</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([2, 3, 4, 3, 1, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([6, 4, 4, 4, 6, 1])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := SemigroupIdeal(S,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([4, 4, 4, 4, 4, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([3, 3, 3, 3, 3, 2]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := ReesCongruenceOfSemigroupIdeal(I);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SemigroupIdealOfReesCongruence(cong);</span>
&lt;non-regular transformation semigroup ideal of degree 6 with
  2 generators&gt;</pre></div>

<p><a id="X7E15F66A8029C64A" name="X7E15F66A8029C64A"></a></p>

<h5>13.9-2 IsReesCongruenceClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsReesCongruenceClass</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This category describes a congruence class of a Rees congruence. A congruence class of a Rees congruence either contains all the elements of an ideal, or is a singleton (see <code class="func">IsReesCongruence</code> (<a href="https://docs.gap-system.org/doc/ref/chap51_mj.html#X822DB78579BCB7B5"><span class="RefLink">Reference: IsReesCongruence</span></a>)).</p>

<p>An object of this type may be used in the same way as any other congruence class object.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([2, 3, 4, 3, 1, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([6, 4, 4, 4, 6, 1]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := SemigroupIdeal(S,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([4, 4, 4, 4, 4, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([3, 3, 3, 3, 3, 2]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cong := ReesCongruenceOfSemigroupIdeal(I);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classes := EquivalenceClasses(cong);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReesCongruenceClass(classes[1]);</span>
true</pre></div>

<p><a id="X7C6B4A2980BE9B03" name="X7C6B4A2980BE9B03"></a></p>

<h4>13.10 <span class="Heading">Universal and trivial congruences</span></h4>

<p>The linked triples of a completely 0-simple Rees 0-matrix semigroup describe only its non-universal congruences. In any one of these, the zero element of the semigroup is related only to itself. However, for any semigroup <span class="SimpleMath">\(S\)</span> the universal relation <span class="SimpleMath">\(S \times S\)</span> is a congruence; called the <em>universal congruence</em>. The universal congruence on a semigroup has its own unique representation.</p>

<p>Since many things we want to calculate about congruences are trivial in the case of the universal congruence, this package contains a category specifically designed for it, <code class="code">IsUniversalSemigroupCongruence</code>. We also define <code class="code">IsUniversalSemigroupCongruenceClass</code>, which represents the single congruence class of the universal congruence.</p>

<p><a id="X8751EF557A81A2B1" name="X8751EF557A81A2B1"></a></p>

<h5>13.10-1 IsUniversalSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUniversalSemigroupCongruence</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This property describes a type of semigroup congruence, which must refer to the <em>universal semigroup congruence</em> <span class="SimpleMath">\(S \times S\)</span>. Externally, an object of this type may be used in the same way as any other object in the category <code class="func">IsSemigroupCongruence</code> (<a href="https://docs.gap-system.org/doc/ref/chap51_mj.html#X78E34B737F0E009F"><span class="RefLink">Reference: IsSemigroupCongruence</span></a>).</p>

<p>An object of this type may be constructed with <code class="code">UniversalSemigroupCongruence</code> or this representation may be selected automatically as an alternative to an <code class="code">IsRZMSCongruenceByLinkedTriple</code> object (since the universal congruence cannot be represented by a linked triple).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([Transformation([3, 2, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := UniversalSemigroupCongruence(S);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUniversalSemigroupCongruence(U);</span>
true</pre></div>

<p><a id="X8646253C86AFFA29" name="X8646253C86AFFA29"></a></p>

<h5>13.10-2 IsUniversalSemigroupCongruenceClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUniversalSemigroupCongruenceClass</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This category describes a class of the universal semigroup congruence (see <code class="func">IsUniversalSemigroupCongruence</code> (<a href="chap13_mj.html#X8751EF557A81A2B1"><span class="RefLink">13.10-1</span></a>)). A universal semigroup congruence by definition has precisely one congruence class, which contains all of the elements of the semigroup in question.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([Transformation([3, 2, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := UniversalSemigroupCongruence(S);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classes := EquivalenceClasses(U);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUniversalSemigroupCongruenceClass(classes[1]);</span>
true</pre></div>

<p><a id="X7B99C6A47F3D375F" name="X7B99C6A47F3D375F"></a></p>

<h5>13.10-3 UniversalSemigroupCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniversalSemigroupCongruence</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A universal semigroup congruence.</p>

<p>This operation returns the universal semigroup congruence for the semigroup <var class="Arg">S</var>. It can be used in the same way as any other semigroup congruence object.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(SymmetricGroup(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[(), (1, 3, 2)], [(1, 2), 0]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalSemigroupCongruence(S);</span>
&lt;universal semigroup congruence over
&lt;Rees 0-matrix semigroup 2x2 over Sym( [ 1 .. 3 ] )&gt;&gt;</pre></div>

<p><a id="X7A9B483B7B4E0E27" name="X7A9B483B7B4E0E27"></a></p>

<h5>13.10-4 TrivialCongruence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialCongruence</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A trivial semigroup congruence.</p>

<p>This operation returns the trivial semigroup congruence for the semigroup <var class="Arg">S</var>. It can be used in the same way as any other semigroup congruence object.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ReesZeroMatrixSemigroup(SymmetricGroup(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[(), (1, 3, 2)], [(1, 2), 0]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TrivialCongruence(S);</span>
&lt;semigroup congruence over &lt;Rees 0-matrix semigroup 2x2 over
  Sym( [ 1 .. 3 ] )&gt; with linked triple (1,2,2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := PartitionMonoid(2);</span>
&lt;regular bipartition *-monoid of size 15, degree 2 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TrivialCongruence(S);</span>
&lt;2-sided semigroup congruence over &lt;regular bipartition *-monoid
 of size 15, degree 2 with 3 generators&gt; with 0 generating pairs&gt;</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap12_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap14_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
