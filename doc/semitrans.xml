#############################################################################
##
#W  semitrans.xml
#Y  Copyright (C) 2011-14                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="GeneratorsSmallest">
<ManSection>
  <Attr Name = "GeneratorsSmallest" Arg = "S" Label = "for a transformation
    semigroup"/>
  <Returns>A generating set of transformations.</Returns>
  <Description>
    <C>GeneratorsSmallest</C> returns the lexicographically least collection
    <C>X</C> of transformations such that <A>S</A> is generated by <C>X</C> and
    each <C>X[i]</C> is not generated by <C>X[1], X[2], ..., X[i-1]</C>. <P/>

    Note that it can be difficult to find this set of generators, and that it
    might contain a substantial proportion of the elements of the semigroup. <P/>

    The comparison of two transformation semigroups via the lexicographic
    comparison of their sets of elements is the same relation as the
    lexicographic comparison of their <C>GeneratorsSmallest</C>. However, due to
    the complexity of determining the <C>GeneratorsSmallest</C>, this is not the
    method used by the &Semigroups; package when comparing transformation
    semigroups.  

    <Example><![CDATA[
gap> S := Monoid([
>  Transformation([1, 3, 4, 1]),
>  Transformation([2, 4, 1, 2]),
>  Transformation([3, 1, 1, 3]),
>  Transformation([3, 3, 4, 1])]);
<transformation monoid of degree 4 with 4 generators>
gap> GeneratorsSmallest(S);
[ Transformation( [ 1, 1, 1, 1 ] ), Transformation( [ 1, 1, 1, 2 ] ), 
  Transformation( [ 1, 1, 1, 3 ] ), Transformation( [ 1, 1, 1 ] ), 
  Transformation( [ 1, 1, 2, 1 ] ), Transformation( [ 1, 1, 2, 2 ] ), 
  Transformation( [ 1, 1, 3, 1 ] ), Transformation( [ 1, 1, 3, 3 ] ), 
  Transformation( [ 1, 1 ] ), Transformation( [ 1, 1, 4, 1 ] ), 
  Transformation( [ 1, 2, 1, 1 ] ), Transformation( [ 1, 2, 2, 1 ] ), 
  IdentityTransformation, Transformation( [ 1, 3, 1, 1 ] ), 
  Transformation( [ 1, 3, 4, 1 ] ), Transformation( [ 2, 1, 1, 2 ] ), 
  Transformation( [ 2, 2, 2 ] ), Transformation( [ 2, 4, 1, 2 ] ), 
  Transformation( [ 3, 3, 3 ] ), Transformation( [ 3, 3, 4, 1 ] ) ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="SmallestElementSemigroup">
<ManSection>
  <Attr Name = "SmallestElementSemigroup" Arg = "S"/>
  <Attr Name = "LargestElementSemigroup" Arg = "S"/>
  <Returns>A transformation.</Returns>
  <Description>
    These attributes return the smallest and largest element of the
    transformation semigroup <A>S</A>, respectively. Smallest means the first
    element in the sorted set of elements of <A>S</A> and largest means the last
    element in the set of elements. <P/>
    
    It is not necessary to find the elements of the semigroup to determine the
    smallest or largest element, and this function has considerable better
    performance than the equivalent <C>Elements(<A>S</A>)[1]</C> and 
    <C>Elements(<A>S</A>)[Size(<A>S</A>)]</C>.

    <Example><![CDATA[
gap> S := Monoid(
> Transformation([1, 4, 11, 11, 7, 2, 6, 2, 5, 5, 10]), 
> Transformation([2, 4, 4, 2, 10, 5, 11, 11, 11, 6, 7]));
<transformation monoid of degree 11 with 2 generators>
gap> SmallestElementSemigroup(S);
IdentityTransformation
gap> LargestElementSemigroup(S);
Transformation( [ 11, 11, 10, 10, 7, 6, 5, 6, 2, 2, 4 ] )]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsTransitive">
<ManSection>
  <Oper Name = "IsTransitive" Arg = "S[, X]" Label = "for a transformation
    semigroup and a set"/>
  <Oper Name = "IsTransitive" Arg = "S[, n]" Label = "for a transformation
    semigroup and a pos int"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    A transformation semigroup <A>S</A> is <E>transitive</E> or <E>strongly
    connected</E> on the set <A>X</A> if for every <C>i, j</C> in <A>X</A>
    there is an element <C>s</C> in <A>S</A> such that <C>i ^ s = j</C>. <P/>

    If the optional second argument is a positive integer <A>n</A>, then
    <C>IsTransitive</C> returns <K>true</K> if <A>S</A> is transitive on
    <C>[1 .. <A>n</A>]</C>, and <K>false</K> if it is not. <P/>

    If the optional second argument is not provided, then the degree of 
    <A>S</A> is used by default; see <Ref
      Attr = "DegreeOfTransformationSemigroup" BookName = "ref"/>. 

    <Example><![CDATA[
gap> S := Semigroup([
>  Bipartition([
>    [1, 2], [3, 6, -2], [4, 5, -3, -4], [-1, -6], [-5]]),
>  Bipartition([
>    [1, -4], [2, 3, 4, 5], [6], [-1, -6], [-2, -3], [-5]])]);
<bipartition semigroup of degree 6 with 2 generators>
gap> AsSemigroup(IsTransformationSemigroup, S);
<transformation semigroup of size 11, degree 12 with 2 generators>
gap> IsTransitive(last);
false
gap> IsTransitive(AsSemigroup(Group((1,2,3))));
true]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

# FIXME remove/recycle this
<#GAPDoc Label="AsMatrixSemigroup">
<ManSection>
  <Oper Name="AsMatrixSemigroup" Arg="S[, F]"/>
  <Returns>A semigroup.</Returns>
  <Description>
    
    <C>AsMatrixSemigroup</C> returns the range of an isomorphism from <A>S</A>
    to a semigroup of matrices over <C>GF(2)</C>. If the optional argument
    <A>F</A> is present, then <C>AsMatrixSemigroup</C> returns an isomorphic
    semigroup over the finite field <A>F</A>.

    <Example><![CDATA[
gap> S := Semigroup([
> Bipartition([
>   [1, 2], [3, 6, -2], [4, 5, -3, -4], [-1, -6], [-5]]),
> Bipartition([
>   [1, -4], [2, 3, 4, 5], [6], [-1, -6], [-2, -3], [-5]])]);
<bipartition semigroup of degree 6 with 2 generators>
gap> AsSemigroup(IsTransformationSemigroup, S);
<transformation semigroup of size 11, degree 12 with 2 generators>
gap> AsMatrixSemigroup(S);
<semigroup of 12x12 matrices over GF(2) with 2 generators>
gap> T := Semigroup(Transformation([2, 2, 3]), Transformation([3, 1, 3]));
<transformation semigroup of degree 3 with 2 generators>
gap> S := AsMatrixSemigroup(T, GF(5));
<semigroup of 3x3 matrices over GF(5) with 2 generators>
gap> Size(S);
5]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ComponentRepsOfTransformationSemigroup">
<ManSection>
  <Attr Name = "ComponentRepsOfTransformationSemigroup" Arg = "S"/>
  <Returns>The representatives of components of a transformation semigroup.</Returns>
  <Description>
    This function returns the representatives of the components of the 
    action of the transformation semigroup <A>S</A> on the set of positive
    integers not greater than the degree of <A>S</A>. <P/>
    
    The representatives are the least set of points such that every point can 
    be reached from some representative under the action of <A>S</A>.

    <Example><![CDATA[
gap> S := Semigroup(
> Transformation([11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5]), 
> Transformation([12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12]));;
gap> ComponentRepsOfTransformationSemigroup(S);
[ 2, 3, 8 ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ComponentsOfTransformationSemigroup">
<ManSection>
  <Attr Name = "ComponentsOfTransformationSemigroup" Arg = "S"/>
  <Returns>The components of a transformation semigroup.</Returns>
  <Description>
    This function returns the components of the action of the transformation
    semigroup <A>S</A> on the set of positive integers not greater than the
    degree of <A>S</A>; the components of <A>S</A> partition this set.
    
    <Example><![CDATA[
gap> S := Semigroup(
> Transformation([11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5]), 
> Transformation([12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12]));;
gap> ComponentsOfTransformationSemigroup(S);
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ] ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CyclesOfTransformationSemigroup">
<ManSection>
  <Attr Name = "CyclesOfTransformationSemigroup" Arg = "S"/>
  <Returns>The cycles of a transformation semigroup.</Returns>
  <Description>
    This function returns the cycles, or strongly connected components, of the
    action of the transformation semigroup <A>S</A> on the set of positive
    integers not greater than the degree of <A>S</A>.
    <Example><![CDATA[
gap> S := Semigroup(
> Transformation([11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5]), 
> Transformation([12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12]));;
gap> CyclesOfTransformationSemigroup(S);
[ [ 12 ], [ 1, 11 ], [ 1, 11, 12, 5, 4, 6 ], 
  [ 1, 11, 12, 5, 4, 10, 9, 6 ], [ 1, 12, 5, 4, 6 ], 
  [ 1, 12, 5, 4, 10, 9, 6 ], [ 1, 12, 5, 4, 10, 9, 11 ], 
  [ 11, 12, 5, 4, 10, 9 ], [ 12, 5, 4, 10, 7 ], [ 4, 10, 7 ] ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSynchronizingSemigroup">
  <ManSection>
    <Prop Name = "IsSynchronizingSemigroup" Arg = "S"
      Label = "for a transformation semigroup" />
    <Oper Name = "IsSynchronizingSemigroup" Arg = "S, n"
      Label = "for a transformation semigroup and a positive integer" />
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      For a positive integer <A>n</A>,
      <C>IsSynchronizingSemigroup</C> returns <K>true</K> if the semigroup of
      transformations <A>S</A> contains a transformation with constant value on
      <C>[1 .. <A>n</A>]</C>.
      Note that this function will return true whenever <C><A>n</A> = 1</C>.
      See also <Ref Oper = "ConstantTransformation" BookName = "ref"/>.
      <P/>

      If the optional second argument is not specified, then <A>n</A> will be
      taken to be the value of 
      <Ref Oper = "DegreeOfTransformationSemigroup" BookName = "ref"/> for
      <A>S</A>.
      <P/>
      
      Note that the semigroup consisting of the identity transformation is the
      unique transformation semigroup with degree <C>0</C>. In this special
      case, the function <C>IsSynchronizingSemigroup</C> will return
      <K>false</K>.<P/>

      <Example><![CDATA[
gap> S := Semigroup(
> Transformation([1, 1, 8, 7, 6, 6, 4, 1, 8, 9]), 
> Transformation([5, 8, 7, 6, 10, 8, 7, 6, 9, 7]));;
gap> IsSynchronizingSemigroup(S, 10);
true
gap> S := Semigroup(
> Transformation([3, 8, 1, 1, 9, 9, 8, 7, 9, 6]), 
> Transformation([7, 6, 8, 7, 5, 6, 8, 7, 8, 9]));;
gap> IsSynchronizingSemigroup(S, 10);
false
gap> Representative(MinimalIdeal(S));
Transformation( [ 7, 8, 8, 7, 8, 8, 8, 7, 8, 8 ] )]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphOfActionOnPairs">
  <ManSection>
    <Attr Name = "DigraphOfActionOnPairs" Arg = "S"
      Label = "for a transformation semigroup" />
    <Oper Name = "DigraphOfActionOnPairs" Arg = "S, n"
      Label = "for a transformation semigroup and an integer" />
    <Returns>A digraph, or <K>fail</K>.</Returns>
    <Description>
      If <A>S</A> is a transformation semigroup and <A>n</A> is a non-negative
      integer such that <A>S</A> acts on the points <C>[1 .. <A>n</A>]</C>, then
      <C>DigraphOfActionOnPairs(<A>S</A>, <A>n</A>)</C> returns a digraph
      representing the <Ref Oper="OnSets" BookName="ref"/> action of <A>S</A> on
      the pairs of points in <C>[1 ..  <A>n</A>]</C>.
      <P/>
      
      If the optional argument <A>n</A> is not specified, then by default the
      degree of <A>S</A> will be chosen for <A>n</A>; see <Ref
        Attr="DegreeOfTransformationSemigroup" BookName="ref" />. If the
      semigroup <A>S</A> does not act on <C>[1 ..  <A>n</A>]</C>, then
      <C>DigraphOfActionOnPairs(<A>S</A>, <A>n</A>)</C> returns <K>fail</K>.
      <P/>

      The digraph returned by <C>DigraphOfActionOnPairs</C> has <M><A>n</A> + {n
        \choose 2}</M> vertices: the vertices <C>[1 .. <A>n</A>]</C> correspond
      to the points in <C>[1 .. <A>n</A>]</C>, and the remaining vertices
      correspond to the pairs of points in <C>[1 .. <A>n</A>]</C>. This
      correspondence is stored in the vertex labels of the digraph; see <Ref
        Oper="DigraphVertexLabels" BookName="Digraphs" />.
      <P/>

      The edges of the digraph are defined as follows. For each pair <C>{i,
        j}</C> in <C>[1 .. <A>n</A>]</C>, and for each generator <C>f</C> in
      <C>GeneratorsOfSemigroup(<A>S</A>)</C> (see <Ref
        Attr="GeneratorsOfSemigroup" BookName="ref" />), there is an edge from
      the vertex corresponding to <C>{i, j}</C> to the vertex corresponding to
      <C>{i ^ f, j ^ f}</C>.  Since <C>f</C> is a transformation, the set <C>{i
        ^ f, j ^ f}</C> may correspond to a pair (in the case that <C>i ^ f
        &lt;&gt; j ^ f</C>), or to a point (in the case that <C>i ^ f = j ^
        f</C>).  The label of an edge (<Ref Oper="DigraphEdgeLabels"
        BookName="Digraphs" />) is the position of the first transformation
      within <C>GeneratorsOfSemigroup(<A>S</A>)</C> that maps the pair
      corresponding to the source vertex to the pair/point corresponding to the
      range vertex.
      <P/>

      Note that the digraph returned by <C>DigraphOfActionOnPairs</C> has no
      multiple edges; see <Ref Prop="IsMultiDigraph" BookName="Digraphs"/>.

      <Example><![CDATA[
gap> x := Transformation([2, 4, 3, 4, 7, 1, 6]);;
gap> y := Transformation([3, 3, 2, 3, 5, 1, 5]);;
gap> S := Semigroup(x, y);
<transformation semigroup of degree 7 with 2 generators>
gap> gr := DigraphOfActionOnPairs(S);
<digraph with 28 vertices, 41 edges>
gap> OnSets([2, 5], x);
[ 4, 7 ]
gap> DigraphVertexLabel(gr, 16);
[ 2, 5 ]
gap> DigraphVertexLabel(gr, 25);
[ 4, 7 ]
gap> DigraphEdgeLabel(gr, 16, 25);
1
gap> gr := DigraphOfActionOnPairs(S, 4);
<digraph with 10 vertices, 11 edges>
gap> DigraphVertexLabels(gr);
[ 1, 2, 3, 4, [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], 
  [ 3, 4 ] ]
gap> DigraphOfActionOnPairs(S, 5);
fail]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>
