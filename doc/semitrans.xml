#############################################################################
##
#W  semitrans.xml
#Y  Copyright (C) 2011-14                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="GeneratorsSmallest">
<ManSection>
  <Attr Name="GeneratorsSmallest" Arg="S" Label="for a transformation
    semigroup"/>
  <Returns>A generating set of transformations.</Returns>
  <Description>
    <C>GeneratorsSmallest</C> returns the lexicographically least collection
    <C>X</C> of transformations such that <A>S</A> is generated by <C>X</C> and
    each <C>X[i]</C> is not generated by <C>X[1], X[2], ..., X[i-1]</C>. <P/>

    Note that it can be difficult to find this set of generators, and that it
    might contain a substantial proportion of the elements of the semigroup. <P/>

    The comparison of two transformation semigroups via the lexicographic
    comparison of their sets of elements is the same relation as the
    lexicographic comparison of their <C>GeneratorsSmallest</C>. However, due to
    the complexity of determining the <C>GeneratorsSmallest</C>, this is not the
    method used by the &Semigroups; package when comparing transformation
    semigroups.  

    <Example><![CDATA[
gap> S := Monoid( 
> Transformation( [ 1, 3, 4, 1 ] ), Transformation( [ 2, 4, 1, 2 ] ), 
> Transformation( [ 3, 1, 1, 3 ] ), Transformation( [ 3, 3, 4, 1 ] ) );
<transformation monoid of degree 4 with 4 generators>
gap> GeneratorsSmallest(S);
[ Transformation( [ 1, 1, 1, 1 ] ), Transformation( [ 1, 1, 1, 2 ] ), 
  Transformation( [ 1, 1, 1, 3 ] ), Transformation( [ 1, 1, 1 ] ), 
  Transformation( [ 1, 1, 2, 1 ] ), Transformation( [ 1, 1, 2, 2 ] ), 
  Transformation( [ 1, 1, 3, 1 ] ), Transformation( [ 1, 1, 3, 3 ] ), 
  Transformation( [ 1, 1 ] ), Transformation( [ 1, 1, 4, 1 ] ), 
  Transformation( [ 1, 2, 1, 1 ] ), Transformation( [ 1, 2, 2, 1 ] ), 
  IdentityTransformation, Transformation( [ 1, 3, 1, 1 ] ), 
  Transformation( [ 1, 3, 4, 1 ] ), Transformation( [ 2, 1, 1, 2 ] ), 
  Transformation( [ 2, 2, 2 ] ), Transformation( [ 2, 4, 1, 2 ] ), 
  Transformation( [ 3, 3, 3 ] ), Transformation( [ 3, 3, 4, 1 ] ) ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="SmallestElementSemigroup">
<ManSection>
  <Attr Name="SmallestElementSemigroup" Arg="S"/>
  <Attr Name="LargestElementSemigroup" Arg="S"/>
  <Returns>A transformation.</Returns>
  <Description>
    These attributes return the smallest and largest element of the
    transformation semigroup <A>S</A>, respectively. Smallest means the first
    element in the sorted set of elements of <A>S</A> and largest means the last
    element in the set of elements. <P/>
    
    It is not necessary to find the elements of the semigroup to determine the
    smallest or largest element, and this function has considerable better
    performance than the equivalent <C>Elements(<A>S</A>)[1]</C> and 
    <C>Elements(<A>S</A>)[Size(<A>S</A>)]</C>.

    <Example><![CDATA[
gap> S := Monoid( 
> [ Transformation( [ 1, 4, 11, 11, 7, 2, 6, 2, 5, 5, 10 ] ), 
>   Transformation( [ 2, 4, 4, 2, 10, 5, 11, 11, 11, 6, 7 ] ) ] );
<transformation monoid of degree 11 with 2 generators>
gap> SmallestElementSemigroup(S);
IdentityTransformation
gap> LargestElementSemigroup(S);
Transformation( [ 11, 11, 10, 10, 7, 6, 5, 6, 2, 2, 4 ] )
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsTransitive">
<ManSection>
  <Oper Name="IsTransitive" Arg="S[, X]" Label="for a transformation
    semigroup and a set"/>
  <Oper Name="IsTransitive" Arg="S[, n]" Label="for a transformation
    semigroup and a pos int"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    A transformation semigroup <A>S</A> is <E>transitive</E> or <E>strongly
    connected</E> on the set <A>X</A> if for every <C>i,j</C> in <A>X</A>
    there is an element <C>s</C> in <A>S</A> such that <C>i^s=j</C>. <P/>

    If the optional second argument is a positive integer <A>n</A>, then
    <C>IsTransitive</C> returns <K>true</K> if <A>S</A> is transitive on
    <C>[1..<A>n</A>]</C>, and <K>false</K> if it is not. <P/>

    If the optional second argument is not provided, then the degree of 
    <A>S</A> is used by default; see <Ref
      Attr="DegreeOfTransformationSemigroup" BookName="ref"/>. 

    <Example><![CDATA[
gap> S:=Semigroup( [ Bipartition( [ [ 1, 2 ], [ 3, 6, -2 ], 
> [ 4, 5, -3, -4 ], [ -1, -6 ], [ -5 ] ] ), 
> Bipartition( [ [ 1, -4 ], [ 2, 3, 4, 5 ], [ 6 ], [ -1, -6 ], 
> [ -2, -3 ], [ -5 ] ] ) ] );
<bipartition semigroup of degree 6 with 2 generators>
gap> AsTransformationSemigroup(S);
<transformation semigroup of degree 12 with 2 generators>
gap> IsTransitive(last);
false
gap> IsTransitive(AsSemigroup(Group((1,2,3))));
true]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsTransformationSemigroup">
<ManSection>
  <Oper Name="AsTransformationSemigroup" Arg="S"/>
  <Oper Name="AsPartialPermSemigroup" Arg="S"/>
  <Oper Name="AsBipartitionSemigroup" Arg="S"/>
  <Oper Name="AsBlockBijectionSemigroup" Arg="S"/>
  <Oper Name="AsMatrixSemigroup" Arg="S[, F]"/>
  <Returns>A semigroup.</Returns>
  <Description>
    <C>AsTransformationSemigroup(<A>S</A>)</C> is just shorthand for 
    <C>Range(IsomorphismTransformationSemigroup(<A>S</A>))</C>, when <A>S</A> 
    is a semigroup; see <Ref Oper="IsomorphismTransformationSemigroup"
      BookName="ref"/> for more details.
    <P/>
  
    The operations: 
    <List>
      <Item> <C>AsPartialPermSemigroup</C>;</Item>
      <Item> <C>AsBipartitionSemigroup</C>;</Item>
      <Item> <C>AsBlockBijectionSemigroup</C>;</Item>
    </List>
    are analogous to <C>AsTransformationSemigroup</C>.
    <P/>
    
    <C>AsMatrixSemigroup</C> returns the range of an isomorphism from <A>S</A>
    to a semigroup of matrices over <C>GF(2)</C>. If the optional argument
    <A>F</A> is present, then <C>AsMatrixSemigroup</C> returns an isomorphic
    semigroup over the finite field <A>F</A>.

    <Example><![CDATA[
gap> S := Semigroup( [ Bipartition( [ [ 1, 2 ], [ 3, 6, -2 ], 
> [ 4, 5, -3, -4 ], [ -1, -6 ], [ -5 ] ] ), 
> Bipartition( [ [ 1, -4 ], [ 2, 3, 4, 5 ], [ 6 ], [ -1, -6 ], 
> [ -2, -3 ], [ -5 ] ] ) ] );
<bipartition semigroup of degree 6 with 2 generators>
gap> AsTransformationSemigroup(S);
<transformation semigroup of degree 12 with 2 generators>
gap> AsMatrixSemigroup(S);
<semigroup of 12x12 matrices over GF(2) with 2 generators>
gap> T := Semigroup(Transformation([2, 2, 3]), Transformation([3, 1, 3]));
<transformation semigroup of degree 3 with 2 generators>
gap> S := AsMatrixSemigroup(T, GF(5));
<semigroup of 3x3 matrices over GF(5) with 2 generators>
gap> Size(S);
5]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ComponentRepsOfTransformationSemigroup">
<ManSection>
  <Attr Name="ComponentRepsOfTransformationSemigroup" Arg="S"/>
  <Returns>The representatives of components of a transformation semigroup.</Returns>
  <Description>
    This function returns the representatives of the components of the 
    action of the transformation semigroup <A>S</A> on the set of positive
    integers not greater than the degree of <A>S</A>. <P/>
    
    The representatives are the least set of points such that every point can 
    be reached from some representative under the action of <A>S</A>.

    <Example><![CDATA[
gap> S:=Semigroup( 
> Transformation( [ 11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5 ] ), 
> Transformation( [ 12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12 ] ) );;
gap> ComponentRepsOfTransformationSemigroup(S);
[ 2, 3, 8 ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ComponentsOfTransformationSemigroup">
<ManSection>
  <Attr Name="ComponentsOfTransformationSemigroup" Arg="S"/>
  <Returns>The components of a transformation semigroup.</Returns>
  <Description>
    This function returns the components of the action of the transformation
    semigroup <A>S</A> on the set of positive integers not greater than the
    degree of <A>S</A>; the components of <A>S</A> partition this set.
    
    <Example><![CDATA[
gap> S:=Semigroup( 
> Transformation( [ 11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5 ] ), 
> Transformation( [ 12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12 ] ) );;
gap> ComponentsOfTransformationSemigroup(S);
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ] ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CyclesOfTransformationSemigroup">
<ManSection>
  <Attr Name="CyclesOfTransformationSemigroup" Arg="S"/>
  <Returns>The cycles of a transformation semigroup.</Returns>
  <Description>
    This function returns the cycles, or strongly connected components, of the
    action of the transformation semigroup <A>S</A> on the set of positive
    integers not greater than the degree of <A>S</A>.
    <Example><![CDATA[
gap> S:=Semigroup( 
> Transformation( [ 11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5 ] ), 
> Transformation( [ 12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12 ] ) );;
gap> CyclesOfTransformationSemigroup(S);
[ [ 1, 11, 12, 5, 4, 6, 10, 7, 9 ] ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSynchronizingSemigroup">
  <ManSection>
    <Oper Name="IsSynchronizingSemigroup" Arg="S[, n]"/>
    <Oper Name="IsSynchronizingTransformationCollection" Arg="coll[, n]"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      For a positive integer <A>n</A>,
      <C>IsSynchronizingSemigroup</C> returns <K>true</K> if the semigroup of
      transformations <A>S</A> contains a transformation with constant value on
      <C>[1..<A>n</A>]</C>.
      Note that this function will return true whenever <C><A>n</A> = 1</C>.
      See also <Ref Oper="ConstantTransformation" BookName="ref"/>.
      <P/>

      If the optional second argument is not specified, then <A>n</A> will be
      taken to be the value of 
      <Ref Oper="DegreeOfTransformationSemigroup" BookName="ref"/> for <A>S</A>.
      <P/>

      The operation <C>IsSynchronizingTransformationCollection</C> behaves in
      the same way as <C>IsSynchronizingSemigroup</C> but can be applied to any
      collection of transformations and not only semigroups. <P/>
      
      Note that the semigroup consisting of the identity
      transformation has degree <C>0</C>, and for this special case the
      function <C>IsSynchronizingSemigroup</C> will return <K>false</K>.<P/>



            <Example><![CDATA[
gap> S:=Semigroup( Transformation( [ 1, 1, 8, 7, 6, 6, 4, 1, 8, 9 ] ), 
>  Transformation( [ 5, 8, 7, 6, 10, 8, 7, 6, 9, 7 ] ) );;
gap> IsSynchronizingSemigroup(S, 10);
true
gap> S:=Semigroup( Transformation( [ 3, 8, 1, 1, 9, 9, 8, 7, 9, 6 ] ), 
>  Transformation( [ 7, 6, 8, 7, 5, 6, 8, 7, 8, 9 ] ) );;
gap> IsSynchronizingSemigroup(S, 10);
false
gap> Representative(MinimalIdeal(S));
Transformation( [ 7, 8, 8, 7, 8, 8, 8, 7, 8, 8 ] )]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsTransformationSemigroupGreensClass">
  <ManSection>
    <Prop Name="IsTransformationSemigroupGreensClass" Arg="class"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      A Green's class <A>class</A> of a semigroup <C>S</C> satisfies the
      property <C>IsTransformationSemigroupGreensClass</C> if and only if
      <C>S</C> is a semigroup of transformations. 
    </Description> 
  </ManSection>
<#/GAPDoc>
