#############################################################################
##
#W  cartan.xml
#Y  Copyright (C) 2024                                   Balthazar Charles
##                                                             Joseph Ruiz
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="GeneralizedConjugacyClasses">
  <ManSection>
    <Attr Name ="GeneralizedConjugacyClasses" Arg="S"
         Label = "for a semigroup"/>
    <Attr Name ="GeneralizedConjugacyClassesRepresentatives" Arg="S"
         Label = "for a semigroup"/>
    <Returns>A complete list of generalized conjugacy classes.</Returns>
    <Description>
      <Ref Attr="GeneralizedConjugacyClasses" Label = "for a semigroup"/> 
      returns a list of the generalized 
      conjugacy classes of the semigroup <A>S</A>. Let <M>R</M> be a 
      relation on <A>S</A> such that it is the union of the set
      <M>\{(mn,nm) | m,n \in S \}</M> and the set 
      <M>\{(m,m^{(w+1)}) | m \in S \}</M> where <M>w</M> is 
      <Ref Attr="SmallestIdempotentPower"/> of <C>m</C>.
      A generalized conjugacy class is an equivalence class of the smallest
      equivalence relation that contains <M>R</M>.
      <Ref Attr="GeneralizedConjugacyClassesRepresentatives" Label = "for a semigroup"/> 
      returns a list of the representatives of the generalized conjugacy classes in the 
      semigroup <A>S</A>. In a group generalized conjugacy classes coincide 
      with conjugacy classes.<P/>

      Note that each generalized conjugacy class as currently implemented
      does not store a list of elements in the conjugacy class, only the representative
      with no way to compute all the elements in the conjugacy class.
      This means that 
      <Ref Attr="GeneralizedConjugacyClasses" Label = "for a semigroup"/> as currently 
      implemented is only as effective as 
      <Ref Attr="GeneralizedConjugacyClassesRepresentatives" Label = "for a semigroup"/>.

      <Example><![CDATA[
gap> S := FullTransformationMonoid(6);;
gap> GeneralizedConjugacyClassesRepresentatives(S);
[ IdentityTransformation, Transformation( [ 1, 2, 3, 4, 6, 5 ] ), 
  Transformation( [ 1, 2, 3, 5, 6, 4 ] ), 
  Transformation( [ 1, 2, 4, 3, 6, 5 ] ), 
  Transformation( [ 1, 2, 4, 5, 6, 3 ] ), 
  Transformation( [ 1, 3, 2, 5, 6, 4 ] ), 
  Transformation( [ 1, 3, 4, 5, 6, 2 ] ), 
  Transformation( [ 2, 1, 4, 3, 6, 5 ] ), 
  Transformation( [ 2, 1, 4, 5, 6, 3 ] ), 
  Transformation( [ 2, 3, 1, 5, 6, 4 ] ), 
  Transformation( [ 2, 3, 4, 5, 6, 1 ] ), 
  Transformation( [ 1, 2, 3, 4, 5, 1 ] ), 
  Transformation( [ 1, 2, 3, 5, 4, 1 ] ), 
  Transformation( [ 1, 2, 4, 5, 3, 1 ] ), 
  Transformation( [ 1, 3, 2, 5, 4, 1 ] ), 
  Transformation( [ 1, 3, 4, 5, 2, 1 ] ), 
  Transformation( [ 2, 1, 4, 5, 3, 2 ] ), 
  Transformation( [ 2, 3, 4, 5, 1, 2 ] ), 
  Transformation( [ 2, 2, 3, 4, 5, 2 ] ), 
  Transformation( [ 2, 2, 3, 5, 4, 2 ] ), 
  Transformation( [ 2, 2, 4, 5, 3, 2 ] ), 
  Transformation( [ 3, 3, 2, 5, 4, 3 ] ), 
  Transformation( [ 3, 3, 4, 5, 2, 3 ] ), 
  Transformation( [ 1, 1, 3, 4, 3, 1 ] ), 
  Transformation( [ 1, 1, 4, 3, 4, 1 ] ), 
  Transformation( [ 3, 3, 4, 1, 4, 3 ] ), 
  Transformation( [ 1, 2, 2, 1, 2, 1 ] ), 
  Transformation( [ 2, 1, 1, 2, 1, 2 ] ), 
  Transformation( [ 1, 1, 1, 1, 1, 1 ] ) ]
]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DClassBicharacter">
  <ManSection>
    <Attr Name ="DClassBicharacter" Arg="D"
         Label = "for a D-classs"/>
    <Returns>A matrix of non-negative integers.</Returns>
    <Description>
      <Ref Attr="DClassBicharacter" Label="for a D-classs"/> returns a matrix whose 
      <C>i</C>th row and <C>j</C>th column entry is the size of the set 
      <M>\{m \in D | hmk = m \}</M> where <C>h</C> is an element in the <C>i</C>th 
      generalized conjugacy class of the parent monoid of <A>D</A> 
      and <C>k</C> is an element in the <C>j</C>th generalized conjugacy class of the 
      parent monoid of <A>D</A>. The order of the generalized conjugacy classes of the 
      parent monoid of <A>D</A> is determined by the list returned by the attribute 
      <Ref Attr="GeneralizedConjugacyClasses" Label="for a semigroup"/> of the parent 
      monoid of <A>D</A>.

      <Example><![CDATA[
gap> S := FullTransformationMonoid(3);;
gap> D := DClasses(S)[1];;
gap> DClassBicharacter(D);
[ [ 6, 0, 0, 0, 0, 0 ], [ 0, 2, 0, 0, 0, 0 ], [ 0, 0, 3, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0 ] ]]]>
  </Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RegularRepresentationBicharacter">
  <ManSection>
    <Attr Name ="RegularRepresentationBicharacter" Arg="S"
         Label = "for a semigroup"/>
    <Returns>A matrix of non-negative integers.</Returns>
    <Description>
      <Ref Attr="RegularRepresentationBicharacter" Label="for a semigroup"/> 
      returns a matrix whose <C>i</C>th row 
      and <C>j</C>th column entry is the size of the set 
      <M>\{m \in <A>S</A> | hmk = m \}</M> where <M>h</M> is an element in the 
      <C>i</C>th generalized conjugacy class of <A>S</A> and <M>k</M> is an element 
      in the <C>j</C>th generalized conjugacy class of <A>S</A>. The order of the 
      generalized conjugacy classes of <A>S</A> is determined by the list returned 
      by the attribute 
      <Ref Attr="GeneralizedConjugacyClasses" Label="for a semigroup"/> of <A>S</A>.

      <Example><![CDATA[
gap> S := FullTransformationMonoid(3);;
gap> RegularRepresentationBicharacter(S);
[ [ 27, 1, 0, 8, 0, 1 ], [ 9, 3, 0, 4, 0, 1 ], [ 3, 1, 3, 2, 0, 1 ], 
  [ 9, 1, 0, 4, 0, 1 ], [ 3, 3, 0, 2, 2, 1 ], [ 3, 1, 0, 2, 0, 1 ] ]]]>
  </Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RClassBicharacterOfGroupHClass">
  <ManSection>
    <Attr Name ="RClassBicharacterOfGroupHClass" Arg="H"
         Label = "for a group H-class"/>
    <Returns>A matrix of non-negative integers.</Returns>
    <Description>
      <Ref Attr="RClassBicharacterOfGroupHClass" Label="for a group H-class"/> 
      returns a matrix whose <C>i</C>th row 
      and <C>j</C>th column entry is the size of the set 
      <M>\{m \in R | hmk = m \}</M> where <C>R</C> is the <Ref Meth="RClassOfHClass"/> of 
      <A>H</A>. Furthermore, <M>h</M> is an element in the <C>i</C>th generalized 
      conjugacy class of <A>H</A> as a group and <M>k</M> is an element in the 
      <C>j</C>th generalized conjugacy class of the parent semigroup of <A>H</A>. The order 
      of the generalized conjugacy classes of the parent semigroup of <A>H</A> is determined 
      by the list returned by the attribute 
      <Ref Attr="GeneralizedConjugacyClasses" Label="for a semigroup"/> of 
      the parent semigroup of <A>H</A>. The order of the generalized conjugacy classes of 
      <A>H</A> is determined by the list returned by the attribute 
      <Ref Attr = "ConjugacyClasses" BookName = "ref"/> of <Ref Attr = "OrdinaryCharacterTable" BookName = "ref"/> of 
      <Ref Attr = "Range" BookName = "ref"/> of <Ref Attr="IsomorphismPermGroup"/> of <A>H</A>.

      <Example><![CDATA[
gap> S := FullTransformationMonoid(3);;
gap> D := RegularDClasses(S)[1];;
gap> H := GroupHClass(D);;
gap> RClassBicharacterOfGroupHClass(H);
[ [ 6, 0, 0, 0, 0, 0 ], [ 0, 2, 0, 0, 0, 0 ], [ 0, 0, 3, 0, 0, 0 ] ]]]>
</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="BlockDiagonalMatrixOfCharacterTables">
  <ManSection>
    <Attr Name ="BlockDiagonalMatrixOfCharacterTables" Arg="S"
         Label = "for a semigroup"/>
    <Returns>A matrix.</Returns>
    <Description>
      <Ref Attr="BlockDiagonalMatrixOfCharacterTables" Label="for a semigroup"/> 
      returns a block diagonal matrix whose
      block matrices along the diagonal are character tables of some group &H;-classes 
      in each regular &D;-class of <A>S</A>.
      The character tables are determined by 
      <Ref Attr = "OrdinaryCharacterTable" BookName = "ref"/> of 
      <Ref Attr = "Range" BookName = "ref"/> of <Ref Attr="IsomorphismPermGroup"/>
      of <Ref Attr="GroupHClass"/> of <Ref Attr="RegularDClasses"/> of <A>S</A>. 

      <Example><![CDATA[
gap> S := FullTransformationMonoid(3);;
gap> BlockDiagonalMatrixOfCharacterTables(S);
[ [ 1, -1, 1, 0, 0, 0 ], [ 2, 0, -1, 0, 0, 0 ], [ 1, 1, 1, 0, 0, 0 ], 
  [ 0, 0, 0, 1, -1, 0 ], [ 0, 0, 0, 1, 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ]]]>
  </Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="MonoidCharacterTable">
  <ManSection>
    <Attr Name="MonoidCharacterTable" Arg='M[, F]'/>
    <Returns>The character table object for <A>M</A> over <A>F</A>.</Returns>
    <Description>
      Called with a finite monoid <A>M</A> and optionally a field <A>F</A>,
      <Ref Attr="MonoidCharacterTable"/> returns the character table of the 
      monoid which is defined as the matrix <M>Trace(X(m))</M>, where <M>X</M> 
      runs over the simple <M>FM</M>-modules and <M>m</M> runs over the 
      generalized conjugacy class representatives of <A>M</A>.<P/>

      To get the character table of a monoid to display like the example below,
      the irreducible characters need to be computed first using
      <Ref Attr="Irr" Label="for a monoid character table"/>.<P/>

      If <A>F</A> is not given, then
      <Ref Attr="MonoidCharacterTable"/> returns the character table of 
      <M>M</M> over a characteristic zero splitting field of <A>M</A>.<P/>

      At the moment, methods are available for the following cases:
      if <A>F</A> is not given (i.e. it defaults to a splitting field of 
      <A>M</A> over the rationals) and <A>M</A> is a finite monoid.<P/>

      For other cases no methods are implemented yet.<P/>

      <Example><![CDATA[
gap> S := FullTransformationMonoid(3);;
gap> ct := MonoidCharacterTable(S);;
gap> Irr(ct);;
gap> Display(ct);
    c.1 c.2 c.3 c.4 c.5 c.6
                           
X.1   1  -1   1   .   .   .
X.2   2   .  -1   .   .   .
X.3   1   1   1   .   .   .
X.4   2   .  -1   1  -1   .
X.5   3   1   .   1   1   .
X.6   1   1   1   1   1   1
]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Irr">
  <ManSection>
    <Attr Name ="Irr" Arg="T"
         Label = "for a monoid character table"/>
    <Returns>A list of monoid characters.</Returns>
    <Description>
      <Ref Attr="Irr" Label="for a monoid character table"/> returns a list of 
      the characters of the irreducible representations of the parent monoid 
      of the monoid character table <A>T</A>.

      <Log><![CDATA[
gap> M := FullBooleanMatMonoid(2);
<monoid of 2x2 boolean matrices with 3 generators>
gap> ct := MonoidCharacterTable(M);;
gap> Irr(ct);
[ MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 1, 1, 1, 1, 1 ] ),
  MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 0, 1, 2, 3, 1 ] ),
  MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 0, 0, 1, 2, 0 ] ),
  MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 0, 0, 0, 1, -1 ] ),
  MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 0, 0, 0, 1, 1 ] ) ]]]></Log>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="MonoidCartanMatrix">
  <ManSection>
    <Attr Name="MonoidCartanMatrix" Arg='M[, F]'/>
    <Returns>An object.</Returns>
    <Description>
      Called with a finite monoid <A>M</A> and a field <A>F</A>,
      <Ref Attr="MonoidCartanMatrix"/> returns the Cartan matrix of the monoid 
      algebra <M>FM</M> which is defined as the matrix
      <M>dim Hom(P,Q)/dim End(P / rad(FM))</M>, where <M>P</M> and <M>Q</M> 
      run over the right indecomposable projective modules of FM.<P/>

      To get the Cartan matrix of a monoid to display like the example below,
      the projective indecomposable modules need to be computed first using
      <Ref Attr="Pims" Label="for a monoid cartan matrix"/>.<P/>

      If <A>M</A> is the only argument then
      <Ref Attr="MonoidCartanMatrix"/> returns the Cartan matrix of the monoid 
      algebra <M>FM</M>, where <A>F</A> is a splitting field of <A>M</A> over 
      the rationals.<P/>

      At the moment, methods are available for the following cases:
      if <A>F</A> is not given (i.e. it defaults to a splitting field of <A>M</A> 
      over the rationals) and <A>M</A> is a finite monoid.<P/>

      For other cases no methods are implemented yet.<P/>

      <Example><![CDATA[
gap> S := FullTransformationMonoid(3);;
gap> cm := MonoidCartanMatrix(S);;
gap> Pims(cm);;
gap> Display(cm);
    X.1 X.2 X.3 X.4 X.5 X.6
                           
P.1   1   .   .   .   .   .
P.2   .   1   .   .   .   .
P.3   1   .   1   1   .   .
P.4   1   .   .   1   .   .
P.5   .   .   .   .   1   .
P.6   .   .   .   1   .   1
]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Pims">
  <ManSection>
    <Attr Name ="Pims" Arg="T"
         Label = "for a monoid cartan matrix"/>
    <Returns>A list of monoid characters.</Returns>
    <Description>
      <Ref Attr="Pims" Label="for a monoid cartan matrix"/> returns a 
      list of the characters of the projective indecomposable 
      modules of the parent monoid of the monoid character table <A>T</A>.

      <Log><![CDATA[
gap> M := FullBooleanMatMonoid(2);
<monoid of 2x2 boolean matrices with 3 generators>
gap> cm := MonoidCartanMatrix(M);;
gap> Pims(cm);
[ MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , Projective Cover Of MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(\
IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 1, 1, 1, 1, 1 ] ) ),
  MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , Projective Cover Of MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(\
IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 0, 1, 2, 3, 1 ] ) ),
  MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , Projective Cover Of MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(\
IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 0, 0, 1, 2, 0 ] ) ),
  MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , Projective Cover Of MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(\
IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 0, 0, 0, 1, -1 ] ) ),
  MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanM\
at, [ [ true, false ], [ false, false ] ]) ] ) ) , Projective Cover Of MonoidCharacter( MonoidCharacterTable( Monoid( [ Matrix(IsBooleanMat, [ [ false, true ], [ true, false ] ]), Matrix(\
IsBooleanMat, [ [ true, false ], [ true, true ] ]), Matrix(IsBooleanMat, [ [ true, false ], [ false, false ] ]) ] ) ) , [ 0, 0, 0, 1, 1 ] ) ) ]]]></Log>
    </Description>
  </ManSection>
<#/GAPDoc>