<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (semigroups) - Chapter 6: 
    Creating semigroups and monoids
  </title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap6.html">[MathJax off]</a></p>
<p><a id="X79A4C070831D989D" name="X79A4C070831D989D"></a></p>
<div class="ChapSects"><a href="chap6_mj.html#X79A4C070831D989D">6 <span class="Heading">
    Creating semigroups and monoids
  </span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X781630C482B40F33">6.1 <span class="Heading">Underlying algorithms and related representations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7A3AC74C7FF85825">6.1-1 <span class="Heading">
        Acting semigroups
      </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7D5133C97A5AB1DC">6.1-2 <span class="Heading">Enumerable semigroups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7F69D8FC7D578A0C">6.1-3 IsActingSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X874E25727FDF82B4">6.1-4 IsEnumerableSemigroupRep</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X79BD00A682BDED7A">6.2 <span class="Heading">Semigroups represented by generators</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X79A15C7C83BBA60B">6.2-1 InverseMonoidByGenerators</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X799EBA2F819D8867">6.3 <span class="Heading">Options when creating semigroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X78CF5DCC7C697BB3">6.3-1 SEMIGROUPS.DefaultOptionsRec</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7A5CFD4F8607CBF7">6.4 <span class="Heading">New semigroups from old</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7BE36790862AE26F">6.4-1 ClosureSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7E5B4C5A82F9E0E0">6.4-2 SubsemigroupByProperty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X832AEDCC7BA9E5F5">6.4-3 InverseSubsemigroupByProperty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X861BA02C7902A4F4">6.4-4 DirectProduct</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X82CCC1A781650878">6.5 <span class="Heading">Changing the representation of a semigroup</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X838F18E87F765697">6.5-1 IsomorphismSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X83D03BE678C9974F">6.5-2 IsomorphismMonoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X80ED104F85AE5134">6.5-3 AsSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7B22038F832B9C0F">6.5-4 AsMonoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X80B7B1C783AA1567">6.5-5 IsomorphismPermGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X870210EA7912B52A">6.5-6 RZMSNormalization</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X80DE617E841E5BA0">6.5-7 RMSNormalization</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7C3F130B8362D55A">6.6 <span class="Heading">Random semigroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X789DE9AB79FCFEB5">6.6-1 RandomSemigroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X803B115984A81A8F">6.7 <span class="Heading">
      Endomorphism monoid of a digraph
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X868955247F2AFAA5">6.7-1 EndomorphismMonoid</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">
    Creating semigroups and monoids
  </span></h3>

<p>In this chapter we describe the various ways that semigroups and monoids can be created in <strong class="pkg">Semigroups</strong>, and the options that are available at the time of creation.</p>

<p><a id="X781630C482B40F33" name="X781630C482B40F33"></a></p>

<h4>6.1 <span class="Heading">Underlying algorithms and related representations</span></h4>

<p>Computing the Green's structure of a semigroup is fundamental to almost every other algorithm for semigroups. There are two fundamental algorithms in the <strong class="pkg">Semigroups</strong> package for computing the Green's structure of a semigroup, which are described in the next two subsections.</p>

<p><a id="X7A3AC74C7FF85825" name="X7A3AC74C7FF85825"></a></p>

<h5>6.1-1 <span class="Heading">
        Acting semigroups
      </span></h5>

<p>The first type of fundamental algorithms are those described in <a href="chapBib_mj.html#biBEast2015aa">[EENMP15]</a>, which when applied to a semigroup with relatively large subgroups are the most efficient methods in the <strong class="pkg">Semigroups</strong> package. For example, the complexity of computing, say, the size of a transformation semigroup that happens to be a group, is the same as the complexity of the Schreier-Sims Algorithm (polynomial in the number of points acted on by the transformations) for a permutation group.</p>

<p>In theory, these algorithms can be applied to compute any subsemigroup of a regular semigroup; but so far in the <strong class="pkg">Semigroups</strong> package they are only implemented for semigroups of: transformations (see <a href="../../../doc/ref/chap53_mj.html#X860026B880BCB2A5"><span class="RefLink">Reference: Transformations</span></a>), partial permutations (see <a href="../../../doc/ref/chap54_mj.html#X7D6495F77B8A77BD"><span class="RefLink">Reference: Partial permutations</span></a>), bipartitions (see Chapter <a href="chap3_mj.html#X7C18DB427C9C0917"><span class="RefLink">3</span></a>), subsemigroups of regular Rees 0-matrix semigroups over permutation groups (see Chapter <a href="../../../doc/ref/chap51_mj.html#X8225A9EC87A255E6"><span class="RefLink">Reference: Rees Matrix Semigroups</span></a>), and matrices over a finite field (see Section <a href="chap5_mj.html#X873822B6830CE367"><span class="RefLink">5.4</span></a>).</p>

<p>We refer to semigroups to which the algorithms in <a href="chapBib_mj.html#biBEast2015aa">[EENMP15]</a> can be applied as <em>acting semigroups</em>, and such semigroups belong to the category <code class="func">IsActingSemigroup</code> (<a href="chap6_mj.html#X7F69D8FC7D578A0C"><span class="RefLink">6.1-3</span></a>).</p>

<p>If you know <em>a priori</em> that the semigroup you want to compute is large and \(\mathscr{J}\)-trivial, then you can disable the special methods for acting semigroups when you create the semigroups; see Section <a href="chap6_mj.html#X799EBA2F819D8867"><span class="RefLink">6.3</span></a> for more details.</p>

<p>It is harder for the acting semigroup algorithms to compute Green's \(\mathscr{L}\)- and \(\mathscr{H}\)-classes of a transformation semigroup and the methods used to compute with Green's \(\mathscr{R}\)- and \(\mathscr{D}\)-classes are the most efficient in <strong class="pkg">Semigroups</strong>. Thus, if you are computing with a transformation semigroup, wherever possible, it is advisable to use the commands relating to Green's \(\mathscr{R}\)- or \(\mathscr{D}\)-classes rather than those relating to Green's \(\mathscr{L}\)- or \(\mathscr{H}\)-classes. No such difficulties are present when computing with the other types of acting semigroups in <strong class="pkg">Semigroups</strong>.</p>

<p>There are methods in <strong class="pkg">Semigroups</strong> for computing individual Green's classes of an acting semigroup without computing the entire data structure of the underlying semigroup; see <code class="func">GreensRClassOfElementNC</code> (<a href="chap12_mj.html#X7B44317786571F8B"><span class="RefLink">12.1-3</span></a>). It is also possible to compute the \(\mathscr{R}\)-classes, the number of elements and test membership in a semigroup without computing all the elements; see, for example, <code class="func">GreensRClasses</code> (<a href="chap12_mj.html#X7D51218A80234DE5"><span class="RefLink">12.1-4</span></a>), <code class="func">RClassReps</code> (<a href="chap12_mj.html#X865387A87FAAC395"><span class="RefLink">12.1-5</span></a>), <code class="func">IteratorOfRClassReps</code> (<a href="chap12_mj.html#X8566F84A7F6D4193"><span class="RefLink">12.2-1</span></a>), <code class="func">IteratorOfRClasses</code> (<a href="chap12_mj.html#X867D7B8982915960"><span class="RefLink">12.2-2</span></a>), or <code class="func">NrRClasses</code> (<a href="chap12_mj.html#X7E45FD9F7BADDFBD"><span class="RefLink">12.1-9</span></a>). This may be useful if you want to study a very large semigroup where computing all the elements of the semigroup is not feasible.</p>

<p><a id="X7D5133C97A5AB1DC" name="X7D5133C97A5AB1DC"></a></p>

<h5>6.1-2 <span class="Heading">Enumerable semigroups</span></h5>

<p>The second fundamental algorithm is the Froidure-Pin Algorithm <a href="chapBib_mj.html#biBFroidure1997aa">[FP97]</a>. The <strong class="pkg">Semigroups</strong> package contains two implementations of the Froidure-Pin Algorithm: one in the <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span> C++ library and the other within the <strong class="pkg">Semigroups</strong> package kernel module.</p>

<p>Both implementations outperform the algorithms for acting semigroups when applied to semigroups with small (trivial) subgroups. This method is also used to determine the structure of a semigroup when the algorithms described in <a href="chapBib_mj.html#biBEast2015aa">[EENMP15]</a> do not apply. It is possible to specify which methods should be applied to a given semigroup; see Section <a href="chap6_mj.html#X799EBA2F819D8867"><span class="RefLink">6.3</span></a>.</p>

<p>We refer to semigroups to which the Froidure-Pin Algorithm can be applied in <strong class="pkg">GAP</strong> as <em>enumerable semigroups</em>, and such semigroups should belong to the representation <code class="func">IsEnumerableSemigroupRep</code> (<a href="chap6_mj.html#X874E25727FDF82B4"><span class="RefLink">6.1-4</span></a>). Every acting semigroup in <strong class="pkg">Semigroups</strong> is an enumerable semigroup since the acting semigroup data structure does not readily admit computation of certain properties or attributes.</p>

<p>Currently, the <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span> implementation of the Froidure-Pin Algorithm can be applied to semigroups consisting of the following types of elements: transformations (see <a href="../../../doc/ref/chap53_mj.html#X860026B880BCB2A5"><span class="RefLink">Reference: Transformations</span></a>), partial permutations (see <a href="../../../doc/ref/chap54_mj.html#X7D6495F77B8A77BD"><span class="RefLink">Reference: Partial permutations</span></a>), bipartitions (see Chapter <a href="chap3_mj.html#X7C18DB427C9C0917"><span class="RefLink">3</span></a>), partitioned binary relations (see Chapter <a href="chap4_mj.html#X85A717D1790B7BB5"><span class="RefLink">4</span></a>) as defined in <a href="chapBib_mj.html#biBMartin2011aa">[MM11]</a>; and matrices over the following semirings:</p>


<ul>
<li><p>the <em>Boolean semiring</em> <span class="SimpleMath">\(\{0, 1\}\)</span> where <span class="SimpleMath">\(0 + 0 = 0\)</span>, <span class="SimpleMath">\(0 + 1 = 1 + 1 = 1 + 0 = 1\)</span>, and <span class="SimpleMath">\(1\cdot 0 = 0 \cdot 0 = 0 \cdot 1 = 0\)</span></p>

</li>
<li><p>finite fields;</p>

</li>
<li><p>the <em>max-plus semiring</em> of natural numbers and negative infinity <span class="SimpleMath">\(\mathbb{N}\cup \{-\infty\}\)</span> with operations max and plus;</p>

</li>
<li><p>the <em>min-plus semiring</em> of natural numbers and infinity <span class="SimpleMath">\(\mathbb{N}\cup \{\infty\}\)</span> with operations min and plus;</p>

</li>
<li><p>the <em>tropical max-plus semiring</em> <span class="SimpleMath">\(\{-\infty, 0, 1, \ldots, t\}\)</span> for some threshold <span class="SimpleMath">\(t\)</span> with operations max and plus;</p>

</li>
<li><p>the <em>tropical min-plus semiring</em> <span class="SimpleMath">\(\{0, 1, \ldots, t, \infty\}\)</span> for some threshold <span class="SimpleMath">\(t\)</span> with operations min and plus;</p>

</li>
<li><p>the semiring <span class="SimpleMath">\(\mathbb{N}_{t, p} = \{0, 1, \ldots, t, t + 1, \ldots, t + p - 1\}\)</span> for some threshold <span class="SimpleMath">\(t\)</span> and period <span class="SimpleMath">\(p\)</span> under addition and multiplication modulo the congruence <span class="SimpleMath">\(t = t + p\)</span>.</p>

</li>
</ul>
<p>(see Chapter <a href="chap5_mj.html#X82D6B7FE7CAC0AFA"><span class="RefLink">5</span></a>).</p>

<p>The version of the Froidure-Pin Algorithm <a href="chapBib_mj.html#biBFroidure1997aa">[FP97]</a> written in C within the <strong class="pkg">Semigroups</strong> package kernel module can be used to compute any other semigroup in <strong class="pkg">GAP</strong> with representation <code class="func">IsEnumerableSemigroupRep</code> (<a href="chap6_mj.html#X874E25727FDF82B4"><span class="RefLink">6.1-4</span></a>). In theory, any finite semigroup can be computed using this algorithm. However, the condition that the semigroup has representation <code class="func">IsEnumerableSemigroupRep</code> (<a href="chap6_mj.html#X874E25727FDF82B4"><span class="RefLink">6.1-4</span></a>) is imposed to avoid this method being used when it is inappropriate (such as for finitely presented semigroups which happen to be finite). If implementing a new type of semigroup in <strong class="pkg">GAP</strong>, then simply do</p>


<div class="example"><pre>InstallTrueMethod(IsGeneratorsOfEnumerableSemigroup,
                       MyNewSemigroupType);</pre></div>

<p>to make your new semigroup type <code class="code">MyNewSemigroupType</code> use this version of the Froidure-Pin Algorithm.</p>

<p>Mostly due to the way that <strong class="pkg">GAP</strong> handles memory, this implementation is approximately 4 times slower than the implementation in <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span>. This version of the Froidure-Pin Algorithm is included because it applies to a wider class of semigroups than those currently implemented in <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span> and it is more straightforward to extend the classes of semigroup to which it applies. From a usage perspective there is no difference between those enumerable semigroups that are representable in <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span> and those that are not, except that the latter has superior performance.</p>

<p><a id="X7F69D8FC7D578A0C" name="X7F69D8FC7D578A0C"></a></p>

<h5>6.1-3 IsActingSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsActingSemigroup</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>Every acting semigroup, as defined in Section <a href="chap6_mj.html#X7A3AC74C7FF85825"><span class="RefLink">6.1-1</span></a>, belongs to this category.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 3, 2]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsActingSemigroup(S);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEnumerableSemigroupRep(S);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := FreeSemigroup(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsActingSemigroup(S);</span>
false</pre></div>

<p><a id="X874E25727FDF82B4" name="X874E25727FDF82B4"></a></p>

<h5>6.1-4 IsEnumerableSemigroupRep</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsEnumerableSemigroupRep</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;representation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>Every semigroup with this representation can have the Froidure-Pin algorithm applied to it; see Section <a href="chap6_mj.html#X7D5133C97A5AB1DC"><span class="RefLink">6.1-2</span></a> for more details.</p>

<p>Basic operations for enumerable semigroups are <code class="func">AsListCanonical</code> (<a href="chap13_mj.html#X7AC3FAA5826516AD"><span class="RefLink">13.1-1</span></a>), <code class="func">EnumeratorCanonical</code> (<a href="chap13_mj.html#X7AC3FAA5826516AD"><span class="RefLink">13.1-1</span></a>), <code class="func">IteratorCanonical</code> (<a href="chap13_mj.html#X7AC3FAA5826516AD"><span class="RefLink">13.1-1</span></a>), <code class="func">PositionCanonical</code> (<a href="chap13_mj.html#X7B4B10AE81602D4E"><span class="RefLink">13.1-2</span></a>), <code class="func">Enumerate</code> (<a href="chap13_mj.html#X7BCD5342793C7A7E"><span class="RefLink">13.1-3</span></a>), and <code class="func">IsFullyEnumerated</code> (<a href="chap13_mj.html#X7FA42CA97917C8A6"><span class="RefLink">13.1-4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 3, 2]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEnumerableSemigroupRep(S);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := FreeSemigroup(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEnumerableSemigroupRep(S);</span>
false
</pre></div>

<p><a id="X79BD00A682BDED7A" name="X79BD00A682BDED7A"></a></p>

<h4>6.2 <span class="Heading">Semigroups represented by generators</span></h4>

<p><a id="X79A15C7C83BBA60B" name="X79A15C7C83BBA60B"></a></p>

<h5>6.2-1 InverseMonoidByGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseMonoidByGenerators</code>( <var class="Arg">coll</var>[, <var class="Arg">opts</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseSemigroupByGenerators</code>( <var class="Arg">coll</var>[, <var class="Arg">opts</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An inverse monoid or semigroup.</p>

<p>If <var class="Arg">coll</var> is a collection satisfying <code class="code">IsGeneratorsOfInverseSemigroup</code>, then <code class="code">InverseMonoidByGenerators</code> and <code class="code">InverseSemigroupByGenerators</code> return the inverse monoid and semigroup generated by <var class="Arg">coll</var>, respectively.</p>

<p>If present, the optional second argument <var class="Arg">opts</var> should be a record containing the values of the options for the semigroup being created, as described in Section <a href="chap6_mj.html#X799EBA2F819D8867"><span class="RefLink">6.3</span></a>.</p>

<p><a id="X799EBA2F819D8867" name="X799EBA2F819D8867"></a></p>

<h4>6.3 <span class="Heading">Options when creating semigroups</span></h4>

<p>When using any of the functions:</p>


<ul>
<li><p><code class="func">InverseSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X78B13FED7AFB4326"><span class="RefLink">Reference: InverseSemigroup</span></a>),</p>

</li>
<li><p><code class="func">InverseMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X80D9B9A98736051B"><span class="RefLink">Reference: InverseMonoid</span></a>),</p>

</li>
<li><p><code class="func">Semigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X7F55D28F819B2817"><span class="RefLink">Reference: Semigroup</span></a>),</p>

</li>
<li><p><code class="func">Monoid</code> (<a href="../../../doc/ref/chap51_mj.html#X7F95328B7C7E49EA"><span class="RefLink">Reference: Monoid</span></a>),</p>

</li>
<li><p><code class="func">SemigroupByGenerators</code> (<a href="../../../doc/ref/chap51_mj.html#X79FBBEC9841544F3"><span class="RefLink">Reference: SemigroupByGenerators</span></a>),</p>

</li>
<li><p><code class="func">MonoidByGenerators</code> (<a href="../../../doc/ref/chap51_mj.html#X85129EE387CC4D28"><span class="RefLink">Reference: MonoidByGenerators</span></a>),</p>

</li>
<li><p><code class="func">ClosureSemigroup</code> (<a href="chap6_mj.html#X7BE36790862AE26F"><span class="RefLink">6.4-1</span></a>),</p>

</li>
<li><p><code class="func">ClosureMonoid</code> (<a href="chap6_mj.html#X7BE36790862AE26F"><span class="RefLink">6.4-1</span></a>),</p>

</li>
<li><p><code class="func">ClosureInverseSemigroup</code> (<a href="chap6_mj.html#X7BE36790862AE26F"><span class="RefLink">6.4-1</span></a>),</p>

</li>
<li><p><code class="func">ClosureInverseMonoid</code> (<a href="chap6_mj.html#X7BE36790862AE26F"><span class="RefLink">6.4-1</span></a>),</p>

</li>
<li><p><code class="func">SemigroupIdeal</code> (<a href="chap7_mj.html#X78E15B0184A1DC14"><span class="RefLink">7.1-1</span></a>)</p>

</li>
</ul>
<p>a record can be given as an optional final argument. The components of this record specify the values of certain options for the semigroup being created. A list of these options and their default values is given below.</p>

<p>Assume that <var class="Arg">S</var> is the semigroup created by one of the functions given above and that either: <var class="Arg">S</var> is generated by a collection <var class="Arg">gens</var>; or <var class="Arg">S</var> is an ideal of such a semigroup.</p>


<dl>
<dt><strong class="Mark"><code class="code">acting</code></strong></dt>
<dd><p>this component should be <code class="keyw">true</code> or <code class="keyw">false</code>. Roughly speaking, there are two types of methods in the <strong class="pkg">Semigroups</strong> package: those for semigroups which have to be fully enumerated, and those for semigroups that do not; see Section <a href="chap1_mj.html#X7DFB63A97E67C0A1"><span class="RefLink">1.1</span></a>. In order for a semigroup to use the latter methods in <strong class="pkg">Semigroups</strong> it must satisfy <code class="func">IsActingSemigroup</code> (<a href="chap6_mj.html#X7F69D8FC7D578A0C"><span class="RefLink">6.1-3</span></a>). By default any semigroup or monoid of transformations, partial permutations, Rees 0-matrix elements, or bipartitions satisfies <code class="code">IsActingSemigroup</code>.</p>

<p>There are cases (such as when it is known <em>a priori</em> that the semigroup is \(\mathscr{D}\)-trivial), when it might be preferable to use the methods that involve fully enumerating a semigroup. In other words, it might be desirable to disable the more sophisticated methods for acting semigroups. If this is the case, then the value of this component can be set <code class="keyw">false</code> when the semigroup is created. Following this none of the special methods for acting semigroup will be used to compute anything about the semigroup.</p>

</dd>
<dt><strong class="Mark"><code class="code">regular</code></strong></dt>
<dd><p>this component should be <code class="keyw">true</code> or <code class="keyw">false</code>. If it is known <em>a priori</em> that the semigroup <code class="code">S</code> being created is a regular semigroup, then this component can be set to <code class="keyw">true</code>. In this case, <code class="code">S</code> knows it is a regular semigroup and can take advantage of the methods for regular semigroups in <strong class="pkg">Semigroups</strong>. It is usually much more efficient to compute with a regular semigroup that to compute with a non-regular semigroup.</p>

<p>If this option is set to <code class="keyw">true</code> when the semigroup being defined is <strong class="button">not</strong> regular, then the results might be unpredictable.</p>

<p>The default value for this option is <code class="keyw">false</code>.</p>

</dd>
<dt><strong class="Mark"><code class="code">hashlen</code></strong></dt>
<dd><p>this component should be a positive integer, which roughly specifies the lengths of the hash tables used internally by <strong class="pkg">Semigroups</strong>. <strong class="pkg">Semigroups</strong> uses hash tables in several fundamental methods. The lengths of these tables are a compromise between performance and memory usage; larger tables provide better performance for large computations but use more memory. Note that it is unlikely that you will need to specify this option unless you find that <strong class="pkg">GAP</strong> runs out of memory unexpectedly or that the performance of <strong class="pkg">Semigroups</strong> is poorer than expected. If you find that <strong class="pkg">GAP</strong> runs out of memory unexpectedly, or you plan to do a large number of computations with relatively small semigroups (say with tens of thousands of elements), then you might consider setting <code class="code">hashlen</code> to be less than the default value of <code class="code">12517</code> for each of these semigroups. If you find that the performance of <strong class="pkg">Semigroups</strong> is unexpectedly poor, or you plan to do a computation with a very large semigroup (say, more than 10 million elements), then you might consider setting <code class="code">hashlen</code> to be greater than the default value of <code class="code">12517</code>.</p>

<p>You might find it useful to set the info level of the info class <code class="code">InfoOrb</code> to 2 or higher since this will indicate when hash tables used by <strong class="pkg">Semigroups</strong> are being grown; see <code class="func">SetInfoLevel</code> (<a href="../../../doc/ref/chap7_mj.html#X7B2ADC37783104B9"><span class="RefLink">Reference: InfoLevel</span></a>).</p>

</dd>
<dt><strong class="Mark"><code class="code">small</code></strong></dt>
<dd><p>if this component is set to <code class="keyw">true</code>, then <strong class="pkg">Semigroups</strong> will compute a small subset of <var class="Arg">gens</var> that generates <var class="Arg">S</var> at the time that <var class="Arg">S</var> is created. This will increase the amount of time required to create <var class="Arg">S</var> substantially, but may decrease the amount of time required for subsequent calculations with <var class="Arg">S</var>. If this component is set to <code class="keyw">false</code>, then <strong class="pkg">Semigroups</strong> will return the semigroup generated by <var class="Arg">gens</var> without modifying <var class="Arg">gens</var>. The default value for this component is <code class="keyw">false</code>.</p>

<p>This option is ignored when passed to <code class="func">ClosureSemigroup</code> (<a href="chap6_mj.html#X7BE36790862AE26F"><span class="RefLink">6.4-1</span></a>) or <code class="func">ClosureInverseSemigroup</code> (<a href="chap6_mj.html#X7BE36790862AE26F"><span class="RefLink">6.4-1</span></a>).</p>

</dd>
<dt><strong class="Mark"><code class="code">cong_by_ker_trace_threshold</code></strong></dt>
<dd><p>this should be a positive integer, which specifies a semigroup size. If <var class="Arg">S</var> is a semigroup with inverse op, and <var class="Arg">S</var> has a size greater than or equal to this threshold, then any congruence defined on it may use the "kernel and trace" method to perform calculations. If its size is less than the threshold, then other methods will be used instead. The "kernel and trace" method has better complexity than the generic method, but has large overheads which make it a poor choice for small semigroups. The default value for this component is <code class="code">10 ^ 5</code>. See Section <a href="chap16_mj.html#X7BFDC38178940AE6"><span class="RefLink">16.7</span></a> for more information about the "kernel and trace" method.</p>

</dd>
<dt><strong class="Mark"><code class="code">report</code></strong></dt>
<dd><p>this component should be either <code class="keyw">true</code> or <code class="keyw">false</code>. If this component is set to <code class="keyw">true</code>, then some additional information will be provided during computations performed by the <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span> C++ library.</p>

</dd>
<dt><strong class="Mark"><code class="code">batch_size</code></strong></dt>
<dd><p>this component should be a positive integer. If <var class="Arg">S</var> is a semigroup with representation <code class="func">IsEnumerableSemigroupRep</code> (<a href="chap6_mj.html#X874E25727FDF82B4"><span class="RefLink">6.1-4</span></a>), then when certain computations are performed with <var class="Arg">S</var> using the <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span> C++ library, then the computations will be executed in batches of size at least <code class="code">batch_size</code>. This value of this component changes the performance of the <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span> C++ library â€” you may wish to tweak this parameter if you experience sub-optimal performance.</p>

</dd>
<dt><strong class="Mark"><code class="code">nr_threads</code></strong></dt>
<dd><p>this component should be a positive integer. This number sets the maximum number of threads that can be used by computations in the <span class="URL"><a href=" https://james-d-mitchell.github.io/libsemigroups/">libsemigroups</a></span> C++ library.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 2, 3, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  rec(hashlen := 100003, small := false));</span>
&lt;commutative transformation semigroup of degree 4 with 1 generator&gt;</pre></div>

<p>The default values of the options described above are stored in a global variable named <code class="func">SEMIGROUPS.DefaultOptionsRec</code> (<a href="chap6_mj.html#X78CF5DCC7C697BB3"><span class="RefLink">6.3-1</span></a>). If you want to change the default values of these options for a single <strong class="pkg">GAP</strong> session, then you can simply redefine the value in <strong class="pkg">GAP</strong>. For example, to change the option <code class="code">small</code> from the default value of <var class="Arg">false</var> use:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SEMIGROUPS.DefaultOptionsRec.small := true;</span>
true</pre></div>

<p>If you want to change the default values of the options stored in <code class="func">SEMIGROUPS.DefaultOptionsRec</code> (<a href="chap6_mj.html#X78CF5DCC7C697BB3"><span class="RefLink">6.3-1</span></a>) for all <strong class="pkg">GAP</strong> sessions, then you can edit these values in the file <code class="code">semigroups/gap/options.g</code>.</p>

<p><a id="X78CF5DCC7C697BB3" name="X78CF5DCC7C697BB3"></a></p>

<h5>6.3-1 SEMIGROUPS.DefaultOptionsRec</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SEMIGROUPS.DefaultOptionsRec</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>This global variable is a record whose components contain the default values of certain options for semigroups. A description of these options is given above in Section <a href="chap6_mj.html#X799EBA2F819D8867"><span class="RefLink">6.3</span></a>.</p>

<p>The value of <code class="code">SEMIGROUPS.DefaultOptionsRec</code> is defined in the file <code class="code">semigroups/gap/options.g</code>.</p>

<p><a id="X7A5CFD4F8607CBF7" name="X7A5CFD4F8607CBF7"></a></p>

<h4>6.4 <span class="Heading">New semigroups from old</span></h4>

<p><a id="X7BE36790862AE26F" name="X7BE36790862AE26F"></a></p>

<h5>6.4-1 ClosureSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClosureSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">coll</var>[, <var class="Arg">opts</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClosureMonoid</code>( <var class="Arg">S</var>, <var class="Arg">coll</var>[, <var class="Arg">opts</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClosureInverseSemigroup</code>( <var class="Arg">S</var>, <var class="Arg">coll</var>[, <var class="Arg">opts</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClosureInverseMonoid</code>( <var class="Arg">S</var>, <var class="Arg">coll</var>[, <var class="Arg">opts</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup, monoid, inverse semigroup, or inverse monoid.</p>

<p>These operations return the semigroup, monoid, inverse semigroup or inverse monoid generated by the argument <var class="Arg">S</var> and the collection of elements <var class="Arg">coll</var> after removing duplicates and elements from <var class="Arg">coll</var> that are already in <var class="Arg">S</var>. In most cases, the new semigroup knows at least as much information about its structure as was already known about that of <var class="Arg">S</var>.</p>

<p>When <code class="code">X</code> is any of <code class="func">Semigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X7F55D28F819B2817"><span class="RefLink">Reference: Semigroup</span></a>), <code class="func">Monoid</code> (<a href="../../../doc/ref/chap51_mj.html#X7F95328B7C7E49EA"><span class="RefLink">Reference: Monoid</span></a>), <code class="func">InverseSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X78B13FED7AFB4326"><span class="RefLink">Reference: InverseSemigroup</span></a>), or <code class="func">InverseMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X80D9B9A98736051B"><span class="RefLink">Reference: InverseMonoid</span></a>), the argument <var class="Arg">S</var> of the operation <code class="code">ClosureX</code> must belong to the category <code class="code">IsX</code>, and <code class="code">ClosureX(<var class="Arg">S</var>, <var class="Arg">coll</var>)</code> returns an object in the category <code class="code">IsX</code> such that</p>


<div class="example"><pre>
        ClosureX(S, coll) = X(S, coll);</pre></div>

<p>but may have fewer generators, if for example, <var class="Arg">coll</var> contains a duplicates or elements already known to belong to <var class="Arg">S</var>.</p>

<p>For example, the argument <var class="Arg">S</var> of <code class="code">ClosureInverseSemigroup</code> must be an inverse semigroup in the category <code class="func">IsInverseSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X83F1529479D56665"><span class="RefLink">Reference: IsInverseSemigroup</span></a>). <code class="code">ClosureInverseSemigroup(<var class="Arg">S</var>, <var class="Arg">coll</var>)</code> returns an inverse semigroup which is equal to <code class="code">InverseSemigroup(<var class="Arg">S</var>, <var class="Arg">coll</var>)</code>.</p>

<p>If present, the optional third argument <var class="Arg">opts</var> should be a record containing the values of the options for the semigroup being created as described in Section <a href="chap6_mj.html#X799EBA2F819D8867"><span class="RefLink">6.3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := [Transformation([2, 6, 7, 2, 6, 1, 1, 5]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Transformation([3, 8, 1, 4, 5, 6, 7, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Transformation([4, 3, 2, 7, 7, 6, 6, 5]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Transformation([7, 1, 7, 4, 2, 5, 6, 3])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid(gens[1]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for x in gens do </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     S := ClosureSemigroup(S, x); </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S;</span>
&lt;transformation monoid of degree 8 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(S);</span>
233606
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid(PartialPerm([1]));</span>
&lt;trivial partial perm group of rank 1 with 1 generator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := ClosureMonoid(S, [PartialPerm([2 .. 5])]);</span>
&lt;partial perm monoid of rank 5 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">One(T);</span>
&lt;identity partial perm on [ 1, 2, 3, 4, 5 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := ClosureSemigroup(S, [PartialPerm([2 .. 5])]);</span>
&lt;partial perm semigroup of rank 4 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">One(T);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClosureInverseMonoid(DualSymmetricInverseMonoid(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        DClass(DualSymmetricInverseMonoid(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                               IdentityBipartition(3)));</span>
&lt;inverse block bijection monoid of degree 3 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup(Bipartition([[1, -1, -3], [2, 3, -2]]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         Bipartition([[1, -3], [2, -2], [3, -1]]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := ClosureInverseSemigroup(S, DClass(PartitionMonoid(3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">IdentityBipartition(3)));</span>
&lt;inverse block bijection semigroup of degree 3 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := ClosureInverseSemigroup(T, [T.1, T.1, T.1]);</span>
&lt;inverse block bijection semigroup of degree 3 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseMonoid([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([5, 9, 10, 0, 6, 3, 8, 4, 0]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([10, 7, 0, 8, 0, 0, 5, 9, 1])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := PartialPerm([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">5, 1, 7, 3, 10, 0, 2, 12, 0, 14, 11, 0, 16, 0, 0, 0, 0, 6, 9, 15]);</span>
[4,3,7,2,1,5,10,14][8,12][13,16][18,6][19,9][20,15](11)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ClosureInverseSemigroup(S, x);</span>
&lt;inverse partial perm semigroup of rank 19 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(S);</span>
9744
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Idempotents(SymmetricInverseSemigroup(10));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := ClosureInverseSemigroup(S, T);</span>
&lt;inverse partial perm semigroup of rank 19 with 14 generators&gt;</pre></div>

<p><a id="X7E5B4C5A82F9E0E0" name="X7E5B4C5A82F9E0E0"></a></p>

<h5>6.4-2 SubsemigroupByProperty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubsemigroupByProperty</code>( <var class="Arg">S</var>, <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubsemigroupByProperty</code>( <var class="Arg">S</var>, <var class="Arg">func</var>, <var class="Arg">limit</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup.</p>

<p><code class="code">SubsemigroupByProperty</code> returns the subsemigroup of the semigroup <var class="Arg">S</var> generated by those elements of <var class="Arg">S</var> fulfilling <var class="Arg">func</var> (which should be a function returning <code class="keyw">true</code> or <code class="keyw">false</code>).</p>

<p>If no elements of <var class="Arg">S</var> fulfil <var class="Arg">func</var>, then <code class="keyw">fail</code> is returned.</p>

<p>If the optional third argument <var class="Arg">limit</var> is present and a positive integer, then once the subsemigroup has at least <var class="Arg">limit</var> elements the computation stops.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function(x)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local n;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     n := DegreeOfTransformation(x);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return 1 ^ x &lt;&gt; 1 and ForAll([1 .. n], y -&gt; y = 1 or y ^ x = y);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;</span>
function( x ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := SubsemigroupByProperty(FullTransformationSemigroup(3), func);</span>
&lt;transformation semigroup of size 2, degree 3 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := SubsemigroupByProperty(FullTransformationSemigroup(4), func);</span>
&lt;transformation semigroup of size 3, degree 4 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := SubsemigroupByProperty(FullTransformationSemigroup(5), func);</span>
&lt;transformation semigroup of size 4, degree 5 with 4 generators&gt;</pre></div>

<p><a id="X832AEDCC7BA9E5F5" name="X832AEDCC7BA9E5F5"></a></p>

<h5>6.4-3 InverseSubsemigroupByProperty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseSubsemigroupByProperty</code>( <var class="Arg">S</var>, <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An inverse semigroup.</p>

<p><code class="code">InverseSubsemigroupByProperty</code> returns the inverse subsemigroup of the inverse semigroup <var class="Arg">S</var> generated by those elements of <var class="Arg">S</var> fulfilling <var class="Arg">func</var> (which should be a function returning <code class="keyw">true</code> or <code class="keyw">false</code>).</p>

<p>If no elements of <var class="Arg">S</var> fulfil <var class="Arg">func</var>, then <code class="keyw">fail</code> is returned.</p>

<p>If the optional third argument <var class="Arg">limit</var> is present and a positive integer, then once the subsemigroup has at least <var class="Arg">limit</var> elements the computation stops.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsometry := function(f)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">local n, i, j, k, l;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> n := RankOfPartialPerm(f);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> for i in [1 .. n - 1] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   k := DomainOfPartialPerm(f)[i];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   for j in [i + 1 .. n] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     l := DomainOfPartialPerm(f)[j];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if not AbsInt(k ^ f - l ^ f) = AbsInt(k - l) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       return false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> return true;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSubsemigroupByProperty(SymmetricInverseSemigroup(5),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">IsIsometry);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(S);</span>
142</pre></div>

<p><a id="X861BA02C7902A4F4" name="X861BA02C7902A4F4"></a></p>

<h5>6.4-4 DirectProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectProduct</code>( <var class="Arg">S</var>[, <var class="Arg">T</var>, <var class="Arg">...</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectProductOp</code>( <var class="Arg">list</var>, <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transformation semigroup.</p>

<p>The function <code class="code">DirectProduct</code> takes an arbitrary positive number of transformation semigroups and returns another transformation semigroup isomorphic to their direct product. The operation <code class="code">DirectProductOp</code> is included for consistency with the <strong class="pkg">GAP</strong> library (see <code class="func">DirectProductOp</code> (<a href="../../../doc/ref/chap49_mj.html#X861BA02C7902A4F4"><span class="RefLink">Reference: DirectProductOp</span></a>)). It takes exactly two arguments, namely a non-empty list <code class="code">list</code> of transformation semigroups and one of these semigroups, <code class="code">S</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([2, 1]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Semigroup(Transformation([1, 2, 3, 3, 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DP := DirectProduct(S, T);</span>
&lt;commutative transformation semigroup of degree 7 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Elements(DP);</span>
[ Transformation( [ 1, 2, 3, 4, 5, 5, 5 ] ), 
  Transformation( [ 2, 1, 3, 4, 5, 5, 5 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid([Transformation([2, 4, 3, 4]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                Transformation([3, 3, 2, 3, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Semigroup([Transformation([3, 5, 4, 2, 6, 3])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DP := DirectProduct(S, T);</span>
&lt;transformation semigroup of degree 11 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(DP);</span>
35
</pre></div>

<p><a id="X82CCC1A781650878" name="X82CCC1A781650878"></a></p>

<h4>6.5 <span class="Heading">Changing the representation of a semigroup</span></h4>

<p>The <strong class="pkg">Semigroups</strong> package provides two convenient constructors <code class="func">IsomorphismSemigroup</code> (<a href="chap6_mj.html#X838F18E87F765697"><span class="RefLink">6.5-1</span></a>) and <code class="func">IsomorphismMonoid</code> (<a href="chap6_mj.html#X83D03BE678C9974F"><span class="RefLink">6.5-2</span></a>) for changing the representation of a given semigroup or monoid. These methods can be used to find an isomorphism from any semigroup to a semigroup of any other type, provided such an isomorphism exists.</p>

<p>Note that at present neither <code class="func">IsomorphismSemigroup</code> (<a href="chap6_mj.html#X838F18E87F765697"><span class="RefLink">6.5-1</span></a>) nor <code class="func">IsomorphismMonoid</code> (<a href="chap6_mj.html#X83D03BE678C9974F"><span class="RefLink">6.5-2</span></a>) can be used to determine whether two given semigroups, or monoids, are isomorphic.</p>

<p>Some methods for <code class="func">IsomorphismSemigroup</code> (<a href="chap6_mj.html#X838F18E87F765697"><span class="RefLink">6.5-1</span></a>) and <code class="func">IsomorphismMonoid</code> (<a href="chap6_mj.html#X83D03BE678C9974F"><span class="RefLink">6.5-2</span></a>) are based on methods for the <strong class="pkg">GAP</strong> library operations:</p>


<ul>
<li><p><code class="func">IsomorphismReesMatrixSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X7964B5C97FB9C07D"><span class="RefLink">Reference: IsomorphismReesMatrixSemigroup</span></a>),</p>

</li>
<li><p><code class="func">AntiIsomorphismTransformationSemigroup</code> (<a href="../../../doc/ref/chap53_mj.html#X820ECE00846E480F"><span class="RefLink">Reference: AntiIsomorphismTransformationSemigroup</span></a>),</p>

</li>
<li><p><code class="func">IsomorphismTransformationSemigroup</code> (<a href="../../../doc/ref/chap53_mj.html#X78F29C817CF6827F"><span class="RefLink">Reference: IsomorphismTransformationSemigroup</span></a>) and <code class="func">IsomorphismTransformationMonoid</code> (<a href="../../../doc/ref/chap53_mj.html#X78F29C817CF6827F"><span class="RefLink">Reference: IsomorphismTransformationMonoid</span></a>),</p>

</li>
<li><p><code class="func">IsomorphismPartialPermSemigroup</code> (<a href="../../../doc/ref/chap54_mj.html#X7FE18EBE79B9C17C"><span class="RefLink">Reference: IsomorphismPartialPermSemigroup</span></a>) and <code class="func">IsomorphismPartialPermMonoid</code> (<a href="../../../doc/ref/chap54_mj.html#X7FE18EBE79B9C17C"><span class="RefLink">Reference: IsomorphismPartialPermMonoid</span></a>),</p>

</li>
<li><p><code class="func">IsomorphismFpSemigroup</code> (<a href="../../../doc/ref/chap52_mj.html#X869F966B8196F28C"><span class="RefLink">Reference: IsomorphismFpSemigroup</span></a>) and <code class="code">IsomorphismFpMonoid</code>.</p>

</li>
</ul>
<p>The operation <code class="func">IsomorphismMonoid</code> (<a href="chap6_mj.html#X83D03BE678C9974F"><span class="RefLink">6.5-2</span></a>) can be used to return an isomorphism from a semigroup which is mathematically a monoid (but does not below to the category of monoids in <strong class="pkg">GAP</strong> <code class="func">IsMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X861C523483C6248C"><span class="RefLink">Reference: IsMonoid</span></a>)) into a monoid. This is the primary purpose of the operation <code class="func">IsomorphismMonoid</code> (<a href="chap6_mj.html#X83D03BE678C9974F"><span class="RefLink">6.5-2</span></a>). Either <code class="func">IsomorphismSemigroup</code> (<a href="chap6_mj.html#X838F18E87F765697"><span class="RefLink">6.5-1</span></a>) or <code class="func">IsomorphismMonoid</code> (<a href="chap6_mj.html#X83D03BE678C9974F"><span class="RefLink">6.5-2</span></a>) can be used to change the representation of a monoid, but only the latter is guaranteed to return an object in the category of monoids.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSemigroup(IsBooleanMatSemigroup, S);</span>
&lt;monoid of 10x10 boolean matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsMonoid(IsBooleanMatMonoid, S);</span>
&lt;monoid of 10x10 boolean matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSemigroup(IsBooleanMatSemigroup, S);</span>
&lt;semigroup of 10x10 boolean matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsMonoid(IsBooleanMatMonoid, S);</span>
&lt;monoid of 8x8 boolean matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := Monoid([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([[1, -3], [2, 3, 6], [4, 7, -6], [5, -8], [8, -4, -5],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [-1], [-2], [-7]]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([[1, 3, -6], [2, -8], [4, 8, -1], [5], [6, -3, -4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [7], [-2], [-5], [-7]]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([[1, 2, 4, -3, -7, -8], [3, 5, 6, 8, -4, -6],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [7, -1, -2, -5]])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsMonoid(IsPBRMonoid, M);</span>
&lt;pbr monoid of size 163, degree 163 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSemigroup(IsPBRSemigroup, M);</span>
&lt;pbr semigroup of size 163, degree 8 with 4 generators&gt;</pre></div>

<p>There are some further methods in <strong class="pkg">Semigroups</strong> for obtaining an isomorphism from a Rees matrix, or 0-matrix, semigroup to another such semigroup with particular properties; <code class="func">RMSNormalization</code> (<a href="chap6_mj.html#X80DE617E841E5BA0"><span class="RefLink">6.5-7</span></a>) and <code class="func">RZMSNormalization</code> (<a href="chap6_mj.html#X870210EA7912B52A"><span class="RefLink">6.5-6</span></a>).</p>

<p><a id="X838F18E87F765697" name="X838F18E87F765697"></a></p>

<h5>6.5-1 IsomorphismSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismSemigroup</code>( <var class="Arg">filt</var>, <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An isomorphism of semigroups.</p>

<p><code class="code">IsomorphismSemigroup</code> can be used to find an isomorphism from a given semigroup to a semigroup of another type, provided such an isomorphism exists.</p>

<p>The first argument <var class="Arg">filt</var> must be of the form <code class="code">IsXSemigroup</code>, for example, <code class="func">IsTransformationSemigroup</code> (<a href="../../../doc/ref/chap53_mj.html#X7EAF835D7FE4026F"><span class="RefLink">Reference: IsTransformationSemigroup</span></a>), <code class="func">IsFpSemigroup</code> (<a href="../../../doc/ref/chap52_mj.html#X8239EF2B853411E9"><span class="RefLink">Reference: IsFpSemigroup</span></a>), and <code class="func">IsPBRSemigroup</code> (<a href="chap4_mj.html#X8554A3F878A4DC73"><span class="RefLink">4.6-1</span></a>) are some possible values for <var class="Arg">filt</var>. Note that <var class="Arg">filt</var> should not be of the form <code class="code">IsXMonoid</code>; see <code class="func">IsomorphismMonoid</code> (<a href="chap6_mj.html#X83D03BE678C9974F"><span class="RefLink">6.5-2</span></a>). The second argument <var class="Arg">S</var> should be a semigroup.</p>

<p><code class="code">IsomorphismSemigroup</code> returns an isomorphism from <var class="Arg">S</var> to a semigroup <var class="Arg">T</var> of the type described by <var class="Arg">filt</var>, if such an isomorphism exists. More precisely, if <code class="code">T</code> is the range of the returned isomorphism, then <code class="code"><var class="Arg">filt</var>(T)</code> will return <code class="keyw">true</code>. For example, if <var class="Arg">filt</var> is <code class="code">IsTransformationSemigroup</code>, then the range of the returned isomorphism will be a transformation semigroup.</p>

<p>An error is returned if there is no isomorphism from <var class="Arg">S</var> to a semigroup satisfying <var class="Arg">filt</var>. For example, there is no method for <code class="code">IsomorphismSemigroup</code> when <var class="Arg">filt</var> is, say, <code class="func">IsReesMatrixSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X780BB78A79275244"><span class="RefLink">Reference: IsReesMatrixSemigroup</span></a>) and when <var class="Arg">S</var> is a non-simple semigroup. Similarly, there is no method when <var class="Arg">filt</var> is <code class="func">IsPartialPermSemigroup</code> (<a href="../../../doc/ref/chap54_mj.html#X7D161674800B50E0"><span class="RefLink">Reference: IsPartialPermSemigroup</span></a>) and when <var class="Arg">S</var> is a non-inverse semigroup.</p>

<p>In some cases, if no better method is installed, <code class="code">IsomorphismSemigroup</code> returns an isomorphism found by composing an isomorphism from <var class="Arg">S</var> to a transformation semigroup <code class="code">T</code>, and an isomorphism from <code class="code">T</code> to a semigroup of type <var class="Arg">filt</var>.</p>

<p>Note that if the argument <var class="Arg">S</var> belongs to the category of monoids <code class="func">IsMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X861C523483C6248C"><span class="RefLink">Reference: IsMonoid</span></a>), then <code class="code">IsomorphismSemigroup</code> will often, but not always, return a monoid isomorphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [1, 2], [3, 6, -2], [4, 5, -3, -4], [-1, -6], [-5]]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [1, -4], [2, 3, 4, 5], [6], [-1, -6], [-2, -3], [-5]])]);</span>
&lt;bipartition semigroup of degree 6 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismSemigroup(IsTransformationSemigroup, S);</span>
MappingByFunction( &lt;bipartition semigroup of size 11, degree 6 with 2 
 generators&gt;, &lt;transformation semigroup of size 11, degree 12 with 2 
 generators&gt;, function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismSemigroup(IsBooleanMatSemigroup, S);</span>
MappingByFunction( &lt;bipartition semigroup of size 11, degree 6 with 2 
 generators&gt;, &lt;semigroup of size 11, 12x12 boolean matrices with 2 
 generators&gt;, function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismSemigroup(IsFpSemigroup, S);</span>
MappingByFunction( &lt;bipartition semigroup of size 11, degree 6 with 2 
 generators&gt;, &lt;fp semigroup on the generators 
[ s1, s2 ]&gt;, function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 6, 8, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            [2, 6, 7, 9, 1, 5]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 4, 6, 7, 8, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            [3, 8, 1, 9, 4, 10, 5, 6])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismSemigroup(IsBipartitionSemigroup, S);</span>
MappingByFunction( &lt;inverse partial perm semigroup of rank 10 with 2 
 generators&gt;, &lt;inverse bipartition semigroup of degree 10 with 2 
 generators&gt;, function( x ) ... end, &lt;Operation "AsPartialPerm"&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricInverseMonoid(4);</span>
&lt;symmetric inverse monoid of degree 4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismSemigroup(IsBlockBijectionSemigroup, S);</span>
MappingByFunction( &lt;symmetric inverse monoid of degree 4&gt;, 
&lt;inverse block bijection monoid of degree 5 with 3 generators&gt;
 , function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(Range(last));</span>
209
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([3, 1]), PartialPerm([1, 3, 4])]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismSemigroup(IsBlockBijectionSemigroup, S);</span>
MappingByFunction( &lt;partial perm semigroup of rank 3 with 2 
 generators&gt;, &lt;block bijection semigroup of degree 5 with 2 
 generators&gt;, function( x ) ... end, function( x ) ... end )</pre></div>

<p><a id="X83D03BE678C9974F" name="X83D03BE678C9974F"></a></p>

<h5>6.5-2 IsomorphismMonoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismMonoid</code>( <var class="Arg">filt</var>, <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An isomorphism of monoids.</p>

<p><code class="code">IsomorphismMonoid</code> can be used to find an isomorphism from a given semigroup which is mathematically a monoid (but might not belong to the category of monoids in <strong class="pkg">GAP</strong>) to a monoid, provided such an isomorphism exists.</p>

<p>The first argument <var class="Arg">filt</var> must be of the form <code class="code">IsXMonoid</code>, for example, <code class="func">IsTransformationMonoid</code> (<a href="../../../doc/ref/chap53_mj.html#X7EAF835D7FE4026F"><span class="RefLink">Reference: IsTransformationMonoid</span></a>), <code class="func">IsFpMonoid</code> (<a href="../../../doc/ref/chap52_mj.html#X8239EF2B853411E9"><span class="RefLink">Reference: IsFpMonoid</span></a>), and <code class="func">IsBipartitionMonoid</code> (<a href="chap3_mj.html#X810BFF647C4E191E"><span class="RefLink">3.8-1</span></a>) are some possible values for <var class="Arg">filt</var>. Note that <var class="Arg">filt</var> should not be of the form <code class="code">IsXSemigroup</code>; see <code class="func">IsomorphismSemigroup</code> (<a href="chap6_mj.html#X838F18E87F765697"><span class="RefLink">6.5-1</span></a>). The second argument <var class="Arg">S</var> should be a semigroup which is mathematically a monoid but which may or may not belong to the category <code class="func">IsMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X861C523483C6248C"><span class="RefLink">Reference: IsMonoid</span></a>) of monoids in <strong class="pkg">GAP</strong>, i.e. <var class="Arg">S</var> must satisfy <code class="func">IsMonoidAsSemigroup</code> (<a href="chap14_mj.html#X7E4DEECD7CD9886D"><span class="RefLink">14.1-12</span></a>).</p>

<p><code class="code">IsomorphismMonoid</code> returns a monoid isomorphism from <var class="Arg">S</var> to a semigroup <var class="Arg">T</var> of the type described by <var class="Arg">filt</var>, if such an isomorphism exists. In this context, a <em>monoid isomorphism</em> is a semigroup isomorphism that maps the <code class="func">MultiplicativeNeutralElement</code> (<a href="../../../doc/ref/chap35_mj.html#X7EE2EA5F7EB7FEC2"><span class="RefLink">Reference: MultiplicativeNeutralElement</span></a>) of <var class="Arg">S</var> to the <code class="func">One</code> (<a href="../../../doc/ref/chap31_mj.html#X8046262384895B2A"><span class="RefLink">Reference: One</span></a>) of <var class="Arg">T</var>. If <code class="code">T</code> is the range of the returned isomorphism, then <code class="code"><var class="Arg">filt</var>(T)</code> will return <code class="keyw">true</code>. For example, if <var class="Arg">filt</var> is <code class="code">IsTransformationMonoid</code>, then the range of the returned isomorphism will be a transformation monoid.</p>

<p>An error is returned if there is no isomorphism from <var class="Arg">S</var> to a monoid satisfying <var class="Arg">filt</var>. For example, there is no method for <code class="code">IsomorphismMonoid</code> when <var class="Arg">filt</var> is, say, <code class="func">IsReesZeroMatrixSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X780BB78A79275244"><span class="RefLink">Reference: IsReesZeroMatrixSemigroup</span></a>) and when <var class="Arg">S</var> is a not 0-simple. Similarly, there is no method when <var class="Arg">filt</var> is <code class="func">IsPartialPermMonoid</code> (<a href="../../../doc/ref/chap54_mj.html#X7D161674800B50E0"><span class="RefLink">Reference: IsPartialPermMonoid</span></a>) and when <var class="Arg">S</var> is a non-inverse monoid.</p>

<p>In some cases, if no better method is installed, <code class="code">IsomorphismMonoid</code> returns an isomorphism found by composing an isomorphism from <var class="Arg">S</var> to a transformation monoid <code class="code">T</code>, and an isomorphism from <code class="code">T</code> to a monoid of type <var class="Arg">filt</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));</span>
&lt;transformation semigroup of degree 10 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismMonoid(IsTransformationMonoid, S);</span>
MappingByFunction( &lt;transformation semigroup of degree 10 with 2 
 generators&gt;, &lt;transformation monoid of degree 8 with 2 generators&gt;
 , function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismMonoid(IsBooleanMatMonoid, S);</span>
MappingByFunction( &lt;transformation semigroup of degree 10 with 2 
 generators&gt;, &lt;monoid of 8x8 boolean matrices with 2 generators&gt;
 , function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismMonoid(IsFpMonoid, S);</span>
MappingByFunction( &lt;transformation semigroup of degree 10 with 2 
 generators&gt;, &lt;fp monoid on the generators 
[ m1, m2 ]&gt;, function( x ) ... end, function( x ) ... end )</pre></div>

<p><a id="X80ED104F85AE5134" name="X80ED104F85AE5134"></a></p>

<h5>6.5-3 AsSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSemigroup</code>( <var class="Arg">filt</var>, <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup.</p>

<p><code class="code">AsSemigroup(<var class="Arg">filt</var>, <var class="Arg">S</var>)</code> is just shorthand for <code class="code">Range(IsomorphismSemigroup(<var class="Arg">filt</var>, <var class="Arg">S</var>))</code>, when <var class="Arg">S</var> is a semigroup; see <code class="func">IsomorphismSemigroup</code> (<a href="chap6_mj.html#X838F18E87F765697"><span class="RefLink">6.5-1</span></a>) for more details.</p>

<p>Note that if the argument <var class="Arg">S</var> belongs to the category of monoids <code class="func">IsMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X861C523483C6248C"><span class="RefLink">Reference: IsMonoid</span></a>), then <code class="code">AsSemigroup</code> will often, but not always, return a monoid. A monoid is not returned if there is not a good monoid isomorphism from <var class="Arg">S</var> to a monoid of the required type, but there is a good semigroup isomorphism.</p>

<p>If it is not possible to convert the semigroup <var class="Arg">S</var> to a semigroup of type <var class="Arg">filt</var>, then an error is given.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [1, 2], [3, 6, -2], [4, 5, -3, -4], [-1, -6], [-5]]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [1, -4], [2, 3, 4, 5], [6], [-1, -6], [-2, -3], [-5]])]);</span>
&lt;bipartition semigroup of degree 6 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSemigroup(IsTransformationSemigroup, S);</span>
&lt;transformation semigroup of size 11, degree 12 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [1, 2], [3, 6, -2], [4, 5, -3, -4], [-1, -6], [-5]]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [1, -4], [2, 3, 4, 5], [6], [-1, -6], [-2, -3], [-5]])]);</span>
&lt;bipartition semigroup of degree 6 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSemigroup(IsTransformationSemigroup, S);</span>
&lt;transformation semigroup of size 11, degree 12 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Semigroup(Transformation([2, 2, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([3, 1, 3]));</span>
&lt;transformation semigroup of degree 3 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := AsSemigroup(IsMatrixOverFiniteFieldSemigroup, GF(5), T);</span>
&lt;semigroup of 3x3 matrices over GF(5) with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(S);</span>
5</pre></div>

<p><a id="X7B22038F832B9C0F" name="X7B22038F832B9C0F"></a></p>

<h5>6.5-4 AsMonoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsMonoid</code>( [<var class="Arg">filt</var>, ]<var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A monoid or <code class="keyw">fail</code>.</p>

<p><code class="code">AsMonoid(<var class="Arg">filt</var>, <var class="Arg">S</var>)</code> is just shorthand for <code class="code">Range(IsomorphismMonoid(<var class="Arg">filt</var>, <var class="Arg">S</var>))</code>, when <var class="Arg">S</var> is a semigroup or monoid; see <code class="func">IsomorphismMonoid</code> (<a href="chap6_mj.html#X83D03BE678C9974F"><span class="RefLink">6.5-2</span></a>) for more details.</p>

<p>If the first argument <var class="Arg">filt</var> is omitted and the semigroup <var class="Arg">S</var> is mathematically a monoid which does not belong to the category of monoids in <strong class="pkg">GAP</strong>, then <code class="code">AsMonoid</code> returns a monoid (in the category of monoids) isomorphic to <var class="Arg">S</var> and of the same type as <var class="Arg">S</var>. If <var class="Arg">S</var> is already in the category of monoids and the first argument <var class="Arg">filt</var> is omitted, then <var class="Arg">S</var> is returned.</p>

<p>If the first argument <var class="Arg">filt</var> is omitted and the semigroup <var class="Arg">S</var> is not a monoid, i.e. it does not satisfy <code class="func">IsMonoidAsSemigroup</code> (<a href="chap14_mj.html#X7E4DEECD7CD9886D"><span class="RefLink">14.1-12</span></a>), then <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsMonoid(S);</span>
&lt;transformation monoid of degree 8 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSemigroup(IsBooleanMatSemigroup, S);</span>
&lt;semigroup of 10x10 boolean matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsMonoid(IsBooleanMatMonoid, S);</span>
&lt;monoid of 8x8 boolean matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid(Bipartition([[1, -1, -3], [2, 3], [-2]]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               Bipartition([[1, -1], [2, 3, -3], [-2]]));</span>
&lt;bipartition monoid of degree 3 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsMonoid(IsTransformationMonoid, S);</span>
&lt;transformation monoid of size 3, degree 3 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsMonoid(S);</span>
&lt;bipartition monoid of size 3, degree 3 with 2 generators&gt;</pre></div>

<p><a id="X80B7B1C783AA1567" name="X80B7B1C783AA1567"></a></p>

<h5>6.5-5 IsomorphismPermGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismPermGroup</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An isomorphism.</p>

<p>If the semigroup <var class="Arg">S</var> is mathematically a group, so that it satisfies <code class="func">IsGroupAsSemigroup</code> (<a href="chap14_mj.html#X852F29E8795FA489"><span class="RefLink">14.1-6</span></a>), then <code class="code">IsomorphismPermGroup</code> returns an isomorphism to a permutation group.</p>

<p>If <var class="Arg">S</var> is not a group then an error is given.</p>

<p>See also <code class="func">IsomorphismPermGroup</code> (<a href="../../../doc/ref/chap43_mj.html#X80B7B1C783AA1567"><span class="RefLink">Reference: IsomorphismPermGroup</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([2, 2, 3, 4, 6, 8, 5, 5]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([3, 3, 8, 2, 5, 6, 4, 4]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupAsSemigroup(S);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Range(IsomorphismPermGroup(S));</span>
Group([ (5,6,8), (2,3,8,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(Range(IsomorphismPermGroup(S)));</span>
"S6"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Range(IsomorphismPartialPermSemigroup(SymmetricGroup(4)));</span>
&lt;partial perm group of size 24, rank 4 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismPermGroup(S);</span>
MappingByFunction( &lt;partial perm group of size 24, rank 4 with
  2 generators&gt;, Group([ (1,2,3,4), (1,
2) ]), &lt;Attribute "AsPermutation"&gt;, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := GroupOfUnits(PartitionMonoid(4));</span>
&lt;block bijection group of degree 4 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(G);</span>
"S4"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismPermGroup(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RespectsMultiplication(iso);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv := InverseGeneralMapping(iso);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(G, x -&gt; (x ^ iso) ^ inv = x);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(G, x -&gt; ForAll(G, y -&gt; (x * y) ^ iso = x ^ iso * y ^ iso));</span>
true</pre></div>

<p><a id="X870210EA7912B52A" name="X870210EA7912B52A"></a></p>

<h5>6.5-6 RZMSNormalization</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RZMSNormalization</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An isomorphism.</p>

<p>If <var class="Arg">R</var> is a Rees 0-matrix semigroup <span class="SimpleMath">\(M^{0}[I, T, \Lambda; P]\)</span> then <code class="code">RZMSNormalization</code> returns an isomorphism from <var class="Arg">R</var> to a <em>normalized</em> Rees 0-matrix semigroup <span class="SimpleMath">\(S = M^{0}[I, T, \Lambda; Q]\)</span>. The structure matrix <span class="SimpleMath">\(Q\)</span> is obtained by <em>normalizing</em> the matrix <span class="SimpleMath">\(P\)</span> (see <code class="func">Matrix</code> (<a href="../../../doc/ref/chap51_mj.html#X879384D479EB1D82"><span class="RefLink">Reference: Matrix</span></a>)) and has the following properties:</p>


<ul>
<li><p>The matrix <span class="SimpleMath">\(Q\)</span> is in block diagonal form, and the blocks are ordered by decreasing size along the leading diagonal (the size of a block is defined to be the number of rows it contains multiplied by the number of columns it contains).</p>

<p>If the index sets <span class="SimpleMath">\(I\)</span> and <span class="SimpleMath">\(\Lambda\)</span> are partitioned into <span class="SimpleMath">\(k\)</span> parts according to the <code class="func">RZMSConnectedComponents</code> (<a href="chap13_mj.html#X79B062917AB34542"><span class="RefLink">13.14-2</span></a>) of <span class="SimpleMath">\(S\)</span>, giving a disjoint union <span class="SimpleMath">\(I=I_1\cup\ldots\cup I_k\)</span> and <span class="SimpleMath">\(\Lambda=\Lambda_1\cup\ldots\cup\Lambda_k\)</span>, then the <span class="SimpleMath">\(r\)</span>th block corresponds to the sub-matrix <span class="SimpleMath">\(Q_{r}\)</span> of <span class="SimpleMath">\(Q\)</span> defined by <span class="SimpleMath">\(I_{r}\)</span> and <span class="SimpleMath">\(\Lambda_{r}\)</span>.</p>

</li>
<li><p>The first non-zero entry in a row occurs no sooner than the first non-zero entry in any previous row.</p>

</li>
<li><p>The first non-zero entry in a column occurs no sooner than the first non-zero entry in any previous column.</p>

</li>
<li><p>The previous two items imply that if the matrix <span class="SimpleMath">\(P\)</span> has any rows/columns consisting entirely of zeroes, then these will become the final rows/columns of <span class="SimpleMath">\(Q\)</span>.</p>

</li>
</ul>
<p>Furthermore, if <span class="SimpleMath">\(T\)</span> is a group (i.e. a semigroup for which <code class="func">IsGroupAsSemigroup</code> (<a href="chap14_mj.html#X852F29E8795FA489"><span class="RefLink">14.1-6</span></a>) returns <code class="keyw">true</code>), then the non-zero entries of the structure matrix <span class="SimpleMath">\(Q\)</span> are chosen such that the following hold:</p>


<ul>
<li><p>The first non-zero entry of every row and every column is equal to the identity of <span class="SimpleMath">\(T\)</span>.</p>

</li>
<li><p>For each <span class="SimpleMath">\(r\)</span>, let <span class="SimpleMath">\(Q_{r}\)</span> be the sub-matrix of <span class="SimpleMath">\(Q\)</span> defined by <span class="SimpleMath">\(I_r\)</span> and <span class="SimpleMath">\(\Lambda_r\)</span> (as above), and let <span class="SimpleMath">\(T_r\)</span> be the subsemigroup of <span class="SimpleMath">\(T\)</span> generated by the non-zero entries of <span class="SimpleMath">\(Q_{r}\)</span>. Then the idempotent generated subsemigroup of <span class="SimpleMath">\(S\)</span> is equal to:</p>


<ul>
<li><p><span class="SimpleMath">\(\bigcup_{r=1}^{k} M^{0}[I_r, T_r, \Lambda_r, Q_r]\)</span>, where the zeroes of these Rees 0-matrix semigroups are all identified with the zero of <span class="SimpleMath">\(S\)</span>.</p>

</li>
</ul>
</li>
</ul>
<p>The normalization given by <code class="code">RZMSNormalization</code> is based on Theorem 2 of <a href="chapBib_mj.html#biBGraham1968Graph">[Gra68]</a> and is sometimes called <em>Graham normal form</em>. Note that isomorphic Rees 0-matrix semigroups can have normalizations which are not equal.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesZeroMatrixSemigroup(Group(()),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[0, (), 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [(), 0, 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [0, 0, ()]]);</span>
&lt;Rees 0-matrix semigroup 3x3 over Group(())&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := RZMSNormalization(R);</span>
MappingByFunction( &lt;Rees 0-matrix semigroup 3x3 over Group(())&gt;, 
&lt;Rees 0-matrix semigroup 3x3 over Group(())&gt;
 , function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Range(iso);</span>
&lt;Rees 0-matrix semigroup 3x3 over Group(())&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Matrix(S);</span>
[ [ (), 0, 0 ], [ 0, (), 0 ], [ 0, 0, () ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesZeroMatrixSemigroup(SymmetricGroup(4),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[0, 0, 0, (1, 3, 2)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [(2, 3), 0, 0, 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [0, 0, (1, 3), (1, 2)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [0, (4, 1, 2, 3), 0, 0]]);</span>
&lt;Rees 0-matrix semigroup 4x4 over Sym( [ 1 .. 4 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Range(RZMSNormalization(R));</span>
&lt;Rees 0-matrix semigroup 4x4 over Sym( [ 1 .. 4 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Matrix(S);</span>
[ [ (), (), 0, 0 ], [ 0, (), 0, 0 ], [ 0, 0, (), 0 ], [ 0, 0, 0, () ] 
 ]</pre></div>

<p><a id="X80DE617E841E5BA0" name="X80DE617E841E5BA0"></a></p>

<h5>6.5-7 RMSNormalization</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RMSNormalization</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An isomorphism.</p>

<p>If <var class="Arg">R</var> is a Rees matrix semigroup over a group <code class="code">G</code> (i.e. a semigroup for which <code class="func">IsGroupAsSemigroup</code> (<a href="chap14_mj.html#X852F29E8795FA489"><span class="RefLink">14.1-6</span></a>) returns <code class="keyw">true</code>), then <code class="code">RMSNormalization</code> returns an isomorphism from <var class="Arg">R</var> to a <em>normalized</em> Rees matrix semigroup <code class="code">S</code> over <code class="code">G</code>.</p>

<p>The semigroup <code class="code">S</code> is normalized in the sense that the first entry of each row and column of the <code class="func">Matrix</code> (<a href="../../../doc/ref/chap51_mj.html#X879384D479EB1D82"><span class="RefLink">Reference: Matrix</span></a>) of <code class="code">S</code> is the identity element of <code class="code">G</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesMatrixSemigroup(SymmetricGroup(4),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[(1, 2), (2, 4, 3), (2, 1, 4)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [(1, 3, 2), (1, 2)(3, 4), ()],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [(2, 3), (1, 3, 2, 4), (2, 3)]]);</span>
&lt;Rees matrix semigroup 3x3 over Sym( [ 1 .. 4 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := RMSNormalization(R);</span>
MappingByFunction( &lt;Rees matrix semigroup 3x3 over Sym( [ 1 .. 4 ] )&gt;
 , &lt;Rees matrix semigroup 3x3 over Sym( [ 1 .. 4 ] )&gt;
 , function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Range(iso);</span>
&lt;Rees matrix semigroup 3x3 over Sym( [ 1 .. 4 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Matrix(S);</span>
[ [ (), (), () ], [ (), (1,2), (1,4,2,3) ], [ (), (1,4,2,3), (2,4) ] ]
</pre></div>

<p><a id="X7C3F130B8362D55A" name="X7C3F130B8362D55A"></a></p>

<h4>6.6 <span class="Heading">Random semigroups</span></h4>

<p><a id="X789DE9AB79FCFEB5" name="X789DE9AB79FCFEB5"></a></p>

<h5>6.6-1 RandomSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomSemigroup</code>( <var class="Arg">arg...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomMonoid</code>( <var class="Arg">arg...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomInverseSemigroup</code>( <var class="Arg">arg...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomInverseMonoid</code>( <var class="Arg">arg...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: A semigroup.</p>

<p>The operations described in this section can be used to generate semigroups, in some sense, at random. There is no guarantee given about the distribution of these semigroups, and this is only intended as a means of generating semigroups for testing and other similar purposes.</p>

<p>Roughly speaking, the arguments of <code class="code">RandomSemigroup</code> are a filter specifying the type of the semigroup to be returned, together with some further parameters that describe some attributes of the semigroup to be returned. For instance, we may want to specify the number of generators, and, say, the degree, or dimension, of the elements, where appropriate. The arguments of <code class="code">RandomMonoid</code>, <code class="code">RandomInverseSemigroup</code>, and <code class="code">RandomInverseMonoid</code> are analogous.</p>

<p>If no arguments are specified, then they are all chosen at random, for a truly random experience.</p>

<p>The first argument, if present, should be a filter <var class="Arg">filter</var>. For <code class="code">RandomSemigroup</code> and <code class="code">RandomInverseSemigroup</code> the filter <var class="Arg">filter</var> must be of the form <code class="code">IsXSemigroup</code>. For example, <code class="func">IsTransformationSemigroup</code> (<a href="../../../doc/ref/chap53_mj.html#X7EAF835D7FE4026F"><span class="RefLink">Reference: IsTransformationSemigroup</span></a>), <code class="func">IsFpSemigroup</code> (<a href="../../../doc/ref/chap52_mj.html#X8239EF2B853411E9"><span class="RefLink">Reference: IsFpSemigroup</span></a>), and <code class="func">IsPBRSemigroup</code> (<a href="chap4_mj.html#X8554A3F878A4DC73"><span class="RefLink">4.6-1</span></a>) are some possible values for <var class="Arg">filter</var>. For <code class="code">RandomMonoid</code> and <code class="code">RandomInverseMonoid</code> the argument <var class="Arg">filter</var> must be of the form <code class="code">IsXMonoid</code>; such as <code class="func">IsBipartitionMonoid</code> (<a href="chap3_mj.html#X810BFF647C4E191E"><span class="RefLink">3.8-1</span></a>) or <code class="func">IsBooleanMatMonoid</code> (<a href="chap5_mj.html#X8616225581BC7414"><span class="RefLink">5.7-2</span></a>).</p>

<p>Suppose that the first argument <var class="Arg">filter</var> is <code class="func">IsFpSemigroup</code> (<a href="../../../doc/ref/chap52_mj.html#X8239EF2B853411E9"><span class="RefLink">Reference: IsFpSemigroup</span></a>). Then the only other arguments that can be specified is (and this argument is also optional):</p>


<dl>
<dt><strong class="Mark">number of generators</strong></dt>
<dd><p>The second argument, if present, should be a positive integer <var class="Arg">m</var> indicating the number of generators that the semigroup should have. If the second argument <var class="Arg">m</var> is not specified, then a number is selected at random.</p>

</dd>
</dl>
<p>If <var class="Arg">filter</var> is a filter such as <code class="func">IsTransformationSemigroup</code> (<a href="../../../doc/ref/chap53_mj.html#X7EAF835D7FE4026F"><span class="RefLink">Reference: IsTransformationSemigroup</span></a>) or <code class="func">IsIntegerMatrixSemigroup</code> (<a href="chap5_mj.html#X7DC6EB0680B3E4DD"><span class="RefLink">5.7-1</span></a>), then a further argument can be specified:</p>


<dl>
<dt><strong class="Mark">degree / dimension</strong></dt>
<dd><p>The third argument, if present, should be a positive integer <var class="Arg">n</var>, which specifies the degree or dimension of the generators. For example, if the first argument <var class="Arg">filter</var> is <code class="code">IsTransformationSemigroup</code>, then the value of this argument is the degree of the transformations in the returned semigroup; or if <var class="Arg">filter</var> is <code class="code">IsMatrixOverFiniteFieldSemigroup</code>, then this argument is the dimension of the matrices in the returned semigroup.</p>

</dd>
</dl>
<p>If <var class="Arg">filter</var> is <code class="func">IsTropicalMaxPlusMatrixSemigroup</code> (<a href="chap5_mj.html#X7DC6EB0680B3E4DD"><span class="RefLink">5.7-1</span></a>), for example, then a fourth argument can be given (or not!):</p>


<dl>
<dt><strong class="Mark">threshold</strong></dt>
<dd><p>The fourth argument, if present, should be a positive integer <var class="Arg">t</var>, which specifies the threshold of the semiring over which the matrices in the returned semigroup are defined.</p>

</dd>
</dl>
<p>You get the idea, the error messages are self-explanatory, and <code class="code">RandomSemigroup</code> works for most of the type of semigroups defined in <strong class="pkg">GAP</strong>.</p>

<p><code class="code">RandomMonoid</code> is similar to <code class="code">RandomSemigroup</code> except it returns a monoid. Likewise, <code class="code">RandomInverseSemigroup</code> and <code class="code">RandomInverseMonoid</code> return inverse semigroups and monoids, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup();</span>
&lt;semigroup of 10x10 max-plus matrices with 12 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomMonoid(IsTransformationMonoid);</span>
&lt;transformation monoid of degree 9 with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomMonoid(IsPartialPermMonoid, 2);</span>
&lt;partial perm monoid of rank 17 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomMonoid(IsPartialPermMonoid, 2, 3);</span>
&lt;partial perm monoid of rank 3 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomInverseSemigroup(IsTropicalMinPlusMatrixSemigroup);</span>
&lt;semigroup of 6x6 tropical min-plus matrices with 14 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomInverseSemigroup(IsTropicalMinPlusMatrixSemigroup, 1);</span>
&lt;semigroup of 6x6 tropical min-plus matrices with 14 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup(IsTropicalMinPlusMatrixSemigroup, 2);</span>
&lt;semigroup of 11x11 tropical min-plus matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup(IsTropicalMinPlusMatrixSemigroup, 2, 1);</span>
&lt;semigroup of 1x1 tropical min-plus matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup(IsTropicalMinPlusMatrixSemigroup, 2, 1, 3);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last.1;</span>
Matrix(IsTropicalMinPlusMatrix, [[infinity]], 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup(IsNTPMatrixSemigroup, 2, 1, 3, 4);</span>
&lt;semigroup of 1x1 ntp matrices with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last.1;</span>
Matrix(IsNTPMatrix, [[2]], 3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup(IsReesMatrixSemigroup, 2, 2);</span>
&lt;Rees matrix semigroup 2x2 over
  &lt;permutation group of size 659 with 1 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup(IsReesZeroMatrixSemigroup, 2, 2, Group((1, 2), (3, 4)));</span>
&lt;Rees 0-matrix semigroup 2x2 over Group([ (1,2), (3,4) ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomInverseMonoid(IsMatrixOverFiniteFieldMonoid, 2, 2);</span>
&lt;monoid of 3x3 matrices over GF(421^4) with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomInverseMonoid(IsMatrixOverFiniteFieldMonoid, 2, 2, GF(7));</span>
&lt;monoid of 3x3 matrices over GF(7) with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup(IsBipartitionSemigroup, 5, 5);</span>
&lt;bipartition semigroup of degree 5 with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomMonoid(IsBipartitionMonoid, 5, 5);</span>
&lt;bipartition monoid of degree 5 with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSemigroup(IsBooleanMatSemigroup);</span>
&lt;semigroup of 3x3 boolean matrices with 18 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomMonoid(IsBooleanMatMonoid);</span>
&lt;monoid of 11x11 boolean matrices with 19 generators&gt;</pre></div>

<p><a id="X803B115984A81A8F" name="X803B115984A81A8F"></a></p>

<h4>6.7 <span class="Heading">
      Endomorphism monoid of a digraph
    </span></h4>

<p><a id="X868955247F2AFAA5" name="X868955247F2AFAA5"></a></p>

<h5>6.7-1 EndomorphismMonoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EndomorphismMonoid</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EndomorphismMonoid</code>( <var class="Arg">digraph</var>, <var class="Arg">colors</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A monoid.</p>

<p>An endomorphism of <var class="Arg">digraph</var> is a homomorphism <code class="func">DigraphHomomorphism</code> (<a href="../../../pkg/digraphs/doc/chap7_mj.html#X85E9B019877AD7FE"><span class="RefLink">Digraphs: DigraphHomomorphism</span></a>) from <var class="Arg">digraph</var> back to itself.</p>

<p><code class="code">EndomorphismMonoid</code>, called with a single argument, returns the monoid of all endomorphisms of <var class="Arg">digraph</var>.</p>

<p>If the <var class="Arg">colors</var> argument is specified, then it will return the monoid of endomorphisms which respect the given colouring. The colouring <var class="Arg">colors</var> can be in one of two forms:</p>


<ul>
<li><p>A list of positive integers of size the number of vertices of <var class="Arg">digraph</var>, where <var class="Arg">colors</var><code class="code">[i]</code> is the colour of vertex <code class="code">i</code>.</p>

</li>
<li><p>A list of lists, such that <var class="Arg">colors</var><code class="code">[i]</code> is a list of all vertices with colour <code class="code">i</code>.</p>

</li>
</ul>
<p>See also <code class="func">GeneratorsOfEndomorphismMonoid</code> (<a href="../../../pkg/digraphs/doc/chap7_mj.html#X7E93B268823F6478"><span class="RefLink">Digraphs: GeneratorsOfEndomorphismMonoid</span></a>). Note that the performance of <code class="code">EndomorphismMonoid</code> may differ from that of <code class="func">GeneratorsOfEndomorphismMonoid</code> (<a href="../../../pkg/digraphs/doc/chap7_mj.html#X7E93B268823F6478"><span class="RefLink">Digraphs: GeneratorsOfEndomorphismMonoid</span></a>) since the former incrementally adds newly discovered endomorphisms to the monoid using <code class="func">ClosureMonoid</code> (<a href="chap6_mj.html#X7BE36790862AE26F"><span class="RefLink">6.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(List([1 .. 3], x -&gt; [1 .. 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EndomorphismMonoid(gr);</span>
&lt;transformation monoid of degree 3 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := CompleteDigraph(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EndomorphismMonoid(gr);</span>
&lt;transformation group of size 6, degree 3 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EndomorphismMonoid(gr, [1, 2, 2]);</span>
&lt;transformation group of degree 3 with 1 generator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EndomorphismMonoid(gr, [[1], [2, 3]]);</span>
&lt;transformation group of degree 3 with 1 generator&gt;</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
