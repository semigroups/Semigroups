#############################################################################
##
#W  properties.xml
#Y  Copyright (C) 2011-12                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="AntiIsomorphismTransformationSemigroup">
  <ManSection>
    <Oper Name="AntiIsomorphismTransformationSemigroup" Arg="S"/>
    <Returns>An anti-isomorphism. 
    </Returns>
    <Description> 
      If <A>S</A> is a semigroup, then
      <C>AntiIsomorphismTransformationSemigroup</C> returns an anti-isomorphism
      from <A>S</A> to a transformation semigroup. At present, the degree of the
      resulting transformation semigroup equals the size of <A>S</A> plus 
      <M>1</M>, and, consequently, this function is of limited use. <P/>

      See also <Ref Oper="IsomorphismTransformationSemigroup" BookName="ref"/>. 

      <Example>
gap> file:=Concatenation(CitrusDir(), "/examples/selfcomp.citrus.gz");;
gap> S:=Semigroup(ReadCitrus(file, 34));;
gap> Size(S);
1016
gap> AntiIsomorphismTransformationSemigroup(S); 
MappingByFunction( &lt;semigroup with 7 generators>, &lt;semigroup with 
7 generators>, function( a ) ... end )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GroupOfUnits">
  <ManSection>
    <Attr Name="GroupOfUnits" Arg="S"/>
    <Returns>The group of units of a semigroup.</Returns>
    <Description>
      <C>GroupOfUnits</C> returns the group of units of the semigroup of
      transformations or partial permutations <A>S</A> as a subsemigroup of
      <A>S</A> if it exists and returns <K>fail</K> if it does not. Use <Ref
        Oper="IsomorphismPermGroup"/> if you require a permutation
      representation of the group of units.<P/>

      If a semigroup <A>S</A> has an identity <C>e</C>, then the <E>group of
        units</E> of <A>S</A> is the set of those <C>s</C> in <A>S</A> such that
      there exists <C>t</C> in <A>S</A> where <C>s*t=t*s=e</C>. Equivalently,
      the group of units is the &H;-class of the identity of <A>S</A>.<P/> 
      
      See also 
      <Ref Oper="GreensHClassOfElement" BookName="ref"/>,
      <Ref Prop="IsMonoidAsSemigroup"/>, and
      <Ref Attr="MultiplicativeNeutralElement" BookName="ref"/>.

      <Example>
gap> S:=Semigroup(Transformation( [ 1, 2, 5, 4, 3, 8, 7, 6 ] ),
>   Transformation( [ 1, 6, 3, 4, 7, 2, 5, 8 ] ),
>   Transformation( [ 2, 1, 6, 7, 8, 3, 4, 5 ] ),
>   Transformation( [ 3, 2, 3, 6, 1, 6, 1, 2 ] ),
>   Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] ) );;
gap> Size(S);
5304
gap> StructureDescription(GroupOfUnits(S));
"C2 x S4"
gap> S:=InverseSemigroup( PartialPermNC( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], 
> [ 2, 4, 5, 3, 6, 7, 10, 9, 8, 1 ] ),
> PartialPermNC( [ 1, 2, 3, 4, 5, 6, 7, 8, 10 ], 
> [ 8, 2, 3, 1, 4, 5, 10, 6, 9 ] ) );;
gap> StructureDescription(GroupOfUnits(S));
"C8"
gap> S:=InverseSemigroup( PartialPermNC( [ 1, 3, 4 ], [ 4, 3, 5 ] ),
> PartialPermNC( [ 1, 2, 3, 5 ], [ 3, 1, 5, 2 ] ) );;
gap> GroupOfUnits(S);
fail</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IdempotentGeneratedSubsemigp">
  <ManSection>
    <Oper Name="IdempotentGeneratedSubsemigp" Arg="S"/>
    <Returns>A semigroup.  
    </Returns>
    <Description> 
      <C>IdempotentGeneratedSubsemigp</C> returns the subsemigroup of the
      semigroup of transformations or partial permutations <A>S</A> generated
      by the idempotents of <A>S</A>.<P/>
      
      See also <Ref Attr="Idempotents"/> and <Ref Attr="SmallGeneratingSet"/>.
<Example>
gap> file:=Concatenation(CitrusDir(), "/examples/graph8c.citrus.gz");;
gap> S:=Semigroup(ReadCitrus(file, 13));;
gap> IdempotentGeneratedSubsemigp(S);
&lt;monoid with 20 generators>
gap> S:=SymmetricInverseSemigp(5);
&lt;inverse semigroup with 3 generators>
gap> IdempotentGeneratedSubsemigp(S);
&lt;inverse semigroup with 6 generators></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="InjectionPrincipalFactor">
<ManSection>
  <Attr Name="InjectionPrincipalFactor" Arg="D"/>
  <Attr Name="IsomorphismReesMatrixSemigroup" Arg="D"/>
  <Returns>A injective mapping.</Returns>
  <Description> 
    The argument <A>D</A> should be a &D;-class of a semigroup of
    transformations or partial permutations.  If <A>D</A> is a
    subsemigroup of <C>S</C>, then 
    the <E>principal factor</E> of <A>D</A> is just <A>D</A> itself.
    If <A>D</A> is not a subsemigroup of <C>S</C>, then 
    the principal factor of <A>D</A> is 
    the semigroup with elements <A>D</A> and a new element <C>0</C> with
    multiplication of <M>x,y\in D</M> defined by:
    <Alt Not="Text">
      <Display>
        xy=\left\{\begin{array}{ll}
        x*y\ (\textrm{in }S)&amp;\textrm{if }x*y\in D\\
        0&amp;\textrm{if }xy\not\in D.
        \end{array}\right.
      </Display>
    </Alt>
    <Alt Only="Text">
      <C>xy</C> equals the product of <C>x</C> and <C>y</C> if it belongs to
      <A>D</A> and <C>0</C> if it does not. <P/>
    </Alt>
    <C>InjectionPrincipalFactor</C> returns an injective function
    from the &D;-class <A>D</A> to a Rees matrix semigroup, which
    contains the principal factor of <A>D</A> as a subsemigroup. <P/>

    If <A>D</A> is a subsemigroup of its parent semigroup, then the
    function returned by <C>InjectionPrincipalFactor</C> or
    <C>IsomorphismReesMatrixSemigroup</C> 
    is an isomorphism from <A>D</A> to a Rees matrix semigroup; see
    <Ref Func="ReesMatrixSemigroup" BookName="ref"/>.<P/>

    If <A>D</A> is not a semigroup, then the function returned by
    <C>InjectionPrincipalFactor</C> is an
    injective function from <A>D</A> to a Rees 0-matrix semigroup isomorphic
    to the principal factor of <A>D</A>; see 
    <Ref Func="ReesZeroMatrixSemigroup" BookName="ref"/>. In this case, 
    <C>IsomorphismReesMatrixSemigroup</C> returns an error.<P/>

    See also <Ref Attr="PrincipalFactor"/>.
    
    <Example>
gap> S:=InverseSemigroup(
> PartialPermNC( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] ),
> PartialPermNC( [ 1, 2, 3, 4, 6, 7, 8, 10 ], 
> [ 3, 8, 1, 9, 4, 10, 5, 6 ] ) );;
gap> f:=PartialPermNC([ 1, 2, 5, 6, 7, 9 ], [ 1, 2, 5, 6, 7, 9 ]);;
gap> d:=GreensDClassOfElement(S, f);
{&lt;identity on [ 1, 2, 5, 6, 7, 9 ]>}
gap> InjectionPrincipalFactor(d);
MappingByFunction( {&lt;identity on [ 1, 2, 5, 6, 7, 9 
 ]>}, Rees Zero Matrix Semigroup over &lt;zero group with 
2 generators>, function( f ) ... end, function( x ) ... end )
gap> rms:=Range(last);
Rees Zero Matrix Semigroup over &lt;zero group with 2 generators>
gap> SandwichMatrixOfReesZeroMatrixSemigroup(rms);
[ [ (), 0, 0 ], [ 0, (), 0 ], [ 0, 0, () ] ]
gap> Size(rms);
10
gap> Size(d);
9</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IrredundantGeneratingSubset">
  <ManSection>
    <Oper Name="IrredundantGeneratingSubset" Arg="coll"/>
    <Returns>    
    A list of transformations or partial permutations.
    </Returns>
    <Description>
      If <A>coll</A> is a transformation or partial permutation collection,
      then this function returns a subset <C>U</C> of <A>coll</A> or
      <C>Generators(<A>coll</A>)</C> such that no element of <C>U</C> is
      generated by the other elements of <C>U</C>.  <P/>

      See also <Ref Func="Generators"/>, 
      <Ref Prop="IsTransformationCollection" BookName="ref"/>, and 
      <Ref Oper="SmallGeneratingSet"/>.

      <Log>
gap> S:=Semigroup( Transformation( [ 5, 1, 4, 6, 2, 3 ] ),
> Transformation( [ 1, 2, 3, 4, 5, 6 ] ),
> Transformation( [ 4, 6, 3, 4, 2, 5 ] ),
> Transformation( [ 5, 4, 6, 3, 1, 3 ] ),
> Transformation( [ 2, 2, 6, 5, 4, 3 ] ),
> Transformation( [ 3, 5, 5, 1, 2, 4 ] ),
> Transformation( [ 6, 5, 1, 3, 3, 4 ] ),
> Transformation( [ 1, 3, 4, 3, 2, 1 ] ) );;
gap> IrredundantGeneratingSubset(S);
[ Transformation( [ 1, 3, 4, 3, 2, 1 ] ), 
  Transformation( [ 2, 2, 6, 5, 4, 3 ] ), 
  Transformation( [ 3, 5, 5, 1, 2, 4 ] ), 
  Transformation( [ 5, 1, 4, 6, 2, 3 ] ), 
  Transformation( [ 5, 4, 6, 3, 1, 3 ] ), 
  Transformation( [ 6, 5, 1, 3, 3, 4 ] ) ]
gap> S:=RandomInverseMonoid(1000,10);
&lt;inverse monoid with 1000 generators>
gap> SmallGeneratingSet(S);
[ [ 1 .. 10 ] -> [ 6, 5, 1, 9, 8, 3, 10, 4, 7, 2 ], 
  [ 1 .. 10 ] -> [ 1, 4, 6, 2, 8, 5, 7, 10, 3, 9 ], 
  [ 1, 2, 3, 4, 6, 7, 8, 9 ] -> [ 7, 5, 10, 1, 8, 4, 9, 6 ]
  [ 1 .. 9 ] -> [ 4, 3, 5, 7, 10, 9, 1, 6, 8 ] ]
gap> IrredundantGeneratingSubset(last);
[ [ 1 .. 9 ] -> [ 4, 3, 5, 7, 10, 9, 1, 6, 8 ], 
  [ 1 .. 10 ] -> [ 1, 4, 6, 2, 8, 5, 7, 10, 3, 9 ], 
  [ 1 .. 10 ] -> [ 6, 5, 1, 9, 8, 3, 10, 4, 7, 2 ] ]
</Log>
    </Description>
  </ManSection>
<#/GAPDoc>

<!-- JDM improve --> 
<#GAPDoc Label="IsAbundantSemigroup">
  <ManSection>
    <Prop Name="IsAbundantSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is abundant
          and <K>false</K> if it is not.
    </Returns>
    <Description>
      A transformation semigroup is <E>abundant</E> if and only if for all
      <M>f\in S</M> there exists an idempotent <M>e\in S</M> such that
      <M>\textrm{ker}(f)=\textrm{ker}(e)</M>.  <!-- hmm is this right, or do we
      require the existence of an idempotent e' such that im(e')=im(f) too? --> 
      <Example>
gap> gens:=[ Transformation( [ 1, 3, 2, 3 ] ),
>  Transformation( [ 1, 4, 1, 2 ] ),
>  Transformation( [ 2, 4, 1, 1 ] ),
>  Transformation( [ 3, 4, 2, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsAbundantSemigroup(S);
true
gap> IsRegularSemigroup(S);
false</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsAdequateSemigroup">
  <ManSection>
    <Prop Name="IsAdequateSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is adequate
          and <K>false</K> if it is not.
    </Returns>
    <Description>
      A transformation semigroup is <E>adequate</E> if it is abundant and its
      idempotents commute. See <Ref Prop="IsAbundantSemigroup"/> and 
      <Ref Prop="IsBlockGroup"/>.
      <Example>
gap> S:=Semigroup(Transformation( [ 1, 7, 3, 8, 4, 2, 6, 5, 9 ] ),
>   Transformation( [ 1, 8, 6, 2, 3, 7, 4, 5, 9 ] ),
>   Transformation( [ 1, 9, 9, 9, 5, 6, 7, 9, 9 ] ));;
gap> IsAdequateSemigroup(S);
true
gap> S:=Semigroup( Transformation( [ 1, 3, 2, 3 ] ),
>  Transformation( [ 1, 4, 1, 2 ] ),
>  Transformation( [ 2, 4, 1, 1 ] ),
>  Transformation( [ 3, 4, 2, 2 ] ) );;
gap> IsAdequateSemigroup(S);
false</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBand">
  <ManSection>
    <Prop Name="IsBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsBand</C> returns <K>true</K> if every element of the semigroup of
      transformations or partial permutations <A>S</A> is an idempotent and
      <K>false</K> if it is not. An inverse semigroup is band if and only if it
      is a semilattice; see <Ref Prop="IsSemilatticeAsSemigroup"/>.

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsBand(S);
true
gap> S:=InverseSemigroup(
> PartialPermNC( [ 1, 2, 3, 4, 8, 9 ], [ 5, 8, 7, 6, 9, 1 ] ),
> PartialPermNC( [ 1, 3, 4, 7, 8, 9, 10 ], [ 2, 3, 8, 7, 10, 6, 1 ] ) );;
gap> IsBand(S);
false
gap> IsBand(IdempotentGeneratedSubsemigp(S));
true</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBlockGroup">
  <ManSection>
    <Prop Name="IsBlockGroup" Arg="S"/>
    <Prop Name="IsSemigroupWithCommutingIdempotents" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsBlockGroup</C> and <C>IsSemigroupWithCommutingIdempotents</C> return
      <K>true</K> if the semigroup <A>S</A> of transformations or partial
      permutations is a block group and <K>false</K> if it is not.<P/>

      A semigroup <A>S</A> is a <E>block group</E> if every &L;-class and every
      &R;-class of <A>S</A> contains at most one idempotent. Every semigroup
      of partial permutations is a block group.  
      <Example>
gap> S:=Semigroup(Transformation( [ 5, 6, 7, 3, 1, 4, 2, 8 ] ),
>   Transformation( [ 3, 6, 8, 5, 7, 4, 2, 8 ] ));;
gap> IsBlockGroup(S);
true
gap> S:=Semigroup(Transformation( [ 2, 1, 10, 4, 5, 9, 7, 4, 8, 4 ] ),
> Transformation( [ 10, 7, 5, 6, 1, 3, 9, 7, 10, 2 ] ));;
gap> IsBlockGroup(S);
false</Example>
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBrandtSemigroup">
  <ManSection>
    <Prop Name="IsBrandtSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsBrandtSemigroup</C> return <K>true</K> if the semigroup of
      transformations or partial permutations is 
      a 0-simple inverse semigroup, and <K>false</K> if it is not. See also
      <Ref Prop="IsZeroSimpleSemigroup"/> and <Ref Prop="IsInverseSemigroup"/>.
      <Example>
gap> S:=Semigroup(Transformation( [ 2, 8, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 5, 8, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 3, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 6, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 1, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 1, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 4, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 8, 7, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 8, 8, 2, 8 ] ));;
gap> IsBrandtSemigroup(S);
true
gap> T:=Range(IsomorphismPartialPermSemigroup(S));;
gap> IsBrandtSemigroup(T);
true</Example>
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCliffordSemigroup">
  <ManSection>
    <Prop Name="IsCliffordSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsCliffordSemigroup</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is  
      regular and its idempotents are central, and <K>false</K> if it is not. 
      
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 2, 4, 5, 6, 3, 7, 8 ] ), 
> Transformation( [ 3, 3, 4, 5, 6, 2, 7, 8 ] ), 
> Transformation( [ 1, 2, 5, 3, 6, 8, 4, 4 ] ) );;
gap> IsCliffordSemigroup(S);
true
gap> T:=Range(IsomorphismPartialPermSemigroup(S));;
gap> IsCliffordSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCommutativeSemigroup">
  <ManSection>
    <Prop Name="IsCommutativeSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsCommutativeSemigroup</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is commutative and
      <K>false</K> if it is not.  
      The function <Ref Prop="IsCommutative" BookName="ref"/> can also be used
      to test if a semigroup is commutative.  <P/>

      A semigroup <A>S</A> is <E>commutative</E> if 
      <C>x*y=y*x</C> for all <C>x,y</C> in <A>S</A>.

      <Example>
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCommutativeSemigroup(S);
true
gap> IsCommutative(S);
true
gap> S:=InverseSemigroup(
>  PartialPermNC( [ 1, 2, 3, 4, 5, 6 ], [ 2, 5, 1, 3, 9, 6 ] ),
>  PartialPermNC( [ 1, 2, 3, 4, 6, 8 ], [ 8, 5, 7, 6, 2, 1 ] ) );;
gap> IsCommutativeSemigroup(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCompletelyRegularSemigroup">
  <ManSection>
    <Prop Name="IsCompletelyRegularSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsCompletelyRegularSemigroup</C> returns <K>true</K> if every element
      of the semigroup of transformations or partial permutations <A>S</A>
      is contained in a subgroup of <A>S</A>.<P/> 
      
      An inverse semigroup is
      completely regular if and only if it is a Clifford semigroup; see
      <Ref Prop="IsCliffordSemigroup"/>. 

      <Example>
gap> gens:=[ Transformation( [ 1, 2, 4, 3, 6, 5, 4 ] ), 
>  Transformation( [ 1, 2, 5, 6, 3, 4, 5 ] ), 
>  Transformation( [ 2, 1, 2, 2, 2, 2, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCompletelyRegularSemigroup(S);
true
gap> IsInverseSemigroup(S);
true
gap> T:=Range(IsomorphismPartialPermSemigroup(S));;
gap> IsCompletelyRegularSemigroup(T);
true
gap> IsCliffordSemigroup(T);         
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRTrivial">
  <ManSection><Heading>IsXTrivial</Heading>
    <Prop Name="IsRTrivial" Arg="S"/>
    <Prop Name="IsLTrivial" Arg="S"/>
    <Prop Name="IsHTrivial" Arg="S"/>
    <Prop Name="IsDTrivial" Arg="S"/>
    <Prop Name="IsAperiodicSemigroup" Arg="S"/>
    <Prop Name="IsCombinatorialSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsXTrivial</C> returns <K>true</K> if Green's &R;-relation,
      &L;-relation, &H;-relation, &D;-relation, respectively, on the
      semigroup of transformations or partial permutations <A>S</A> is 
      trivial and <K>false</K> if it is not.
      These properties can also be applied to a Green's class instead of a
      semigroup where applicable. 
      <P/> 

      For inverse semigroups, the properties of being 
      &R;-trivial, &L;-trivial, &D;-trivial, and a semilattice are equivalent;
      see <Ref Prop="IsSemilatticeAsSemigroup"/>.
      <P/>

      A semigroup is <E>aperiodic</E> if its contains no non-trivial
      subgroups (equivalently, all of its group &H;-classes 
      are trivial). A finite semigroup is aperiodic if and only if it is 
      &H;-trivial. <P/>

      <E>Combinatorial</E> is a synonym for aperiodic in this context. 
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 5, 1, 3, 7, 10, 6, 2, 7, 10 ] ), 
>  Transformation( [ 4, 4, 5, 6, 7, 7, 7, 4, 3, 10 ] ) );;
gap> IsHTrivial(S);
true
gap> Size(S);
108
gap> IsRTrivial(S);
false
gap> IsLTrivial(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsFactorisableSemigroup">
<ManSection>
  <Prop Name="IsFactorisableSemigroup" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    An inverse monoid is <E>factorisable</E> if every element is the product
    of an element of the group of units and an idempotent; see also 
    <Ref Attr="GroupOfUnits"/> and <Ref Attr="Idempotents"/>. Hence an
    inverse semigroup of partial permutations is factorisable if and only if
    each of its generators is the restriction of some element in the group of
    units. 
    <Example>
gap> S:=InverseSemigroup( PartialPermNC( [ 1, 2, 4 ], [ 3, 1, 4 ] ),
> PartialPermNC( [ 1, 2, 3, 5 ], [ 4, 1, 5, 2 ] ) );;
gap> IsFactorisableSemigroup(S);
false
gap> IsFactorisableSemigroup(SymmetricInverseSemigp(5)); 
true</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGroupAsSemigroup">
  <ManSection>
    <Prop Name="IsGroupAsSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      If the semigroup of transformations or partial permutations <A>S</A>
      is actually a group, then <C>IsGroupAsSemigroup</C> returns <K>true</K>.
      If it is not a group, then <K>false</K> is returned.
      <Example>
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsGroupAsSemigroup(S);
true
gap> G:=SymmetricGroup(5);;
gap> S:=Range(IsomorphismPartialPermSemigroup(G));
&lt;inverse semigroup with 2 generators>
gap> IsGroupAsSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsIdempotentGenerated">
  <ManSection><Heading>IsIdempotentGenerated</Heading>
    <Prop Name="IsIdempotentGenerated" Arg="S"/>
    <Prop Name="IsSemiBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsIdempotentGenerated</C> and <C>IsSemiBand</C> return 
      <K>true</K> if the semigroup of transformations or partial
      permutations <A>S</A> is generated by its idempotents and <K>false</K> if
      it is not.  See also <Ref Attr="Idempotents"/> and 
      <Ref Attr="IdempotentGeneratedSubsemigp"/>. <P/>

      An inverse semigroup is idempotent-generated if and only if it is a
      semilattice; see <Ref Prop="IsSemilatticeAsSemigroup"/>.<P/>

      Semiband and  idempotent-generated are synonymous
      in this context. 

      <Example>
gap> S:=SingularSemigroup(4);
&lt;semigroup with 12 generators>
gap> IsIdempotentGenerated(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsInverseSemigroup">
<ManSection>
  <Prop Name="IsInverseSemigroup" Arg="S"/>
  <Prop Name="IsInverseMonoid" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    If <A>S</A> is a semigroup of transformations or partial permutations, then
    <C>IsInverseSemigroup</C> returns <K>true</K> if <A>S</A> is an inverse
    semigroup and <K>false</K> if it is not. If <A>S</A> is monoid of
    transformations or partial permutations, then <C>IsInverseMonoid</C>
    returns <K>true</K> if <A>S</A> is an inverse monoid and <K>false</K> if
    it is not.<P/>

    A semigroup is an <E>inverse semigroup</E> if every element 
    <C>x</C> has a unique semigroup inverse, that is, a unique
    element <C>y</C> such that <C>x*y*x=x</C> and <C>y*x*y=y</C>.

    <Example>
gap> gens:=[Transformation([1,2,4,5,6,3,7,8]),
> Transformation([3,3,4,5,6,2,7,8]),
> Transformation([1,2,5,3,6,8,4,4])];;
gap> S:=Semigroup(gens);;
gap> IsInverseSemigroup(S);
true</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<!-- the following does not currently exist! -->
<#GAPDoc Label="IsIrredundantGeneratingSet">
  <ManSection>
    <Oper Name="IsIrredundantGeneratingSet" Arg="[S, ]U"/>
    <Description>
      returns <K>true</K> if <C>u</C> is not an element of the subsemigroup 
      generated by <C>U</C> without <C>u</C> for all <C>u</C> in <C>U</C>.<P/>

      If the optional first argument is present, then 
      <C>IsIrredundantGeneratingSet</C> first checks that <C>U</C> generates 
      <A>S</A>.

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftSimple">
  <ManSection>
    <Prop Name="IsLeftSimple" Arg="S"/>
    <Prop Name="IsRightSimple" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
    <C>IsLeftSimple</C> and <C>IsRightSimple</C> returns <K>true</K> if the 
    semigroup of transformations or partial permutations <A>S</A> has only one
    &L;-class or one &R;-class,
    respectively, and returns <K>false</K> if it has more than one. <P/>

    An inverse semigroup is left simple if and only if it is right simple if
    and only if it is a group; see <Ref Prop="IsGroupAsSemigroup"/>.
<Example>
gap> S:=Semigroup( Transformation( [ 6, 7, 9, 6, 8, 9, 8, 7, 6 ] ), 
>  Transformation( [ 6, 8, 9, 6, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 8, 9, 7, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 9, 8, 6, 7, 9, 7, 8, 6 ] ), 
>  Transformation( [ 6, 9, 9, 6, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 9, 9, 7, 8, 8, 6, 9, 7 ] ), 
>  Transformation( [ 7, 8, 8, 7, 9, 9, 7, 8, 6 ] ), 
>  Transformation( [ 7, 9, 9, 7, 6, 9, 6, 8, 7 ] ), 
>  Transformation( [ 8, 7, 6, 9, 8, 6, 8, 7, 9 ] ), 
>  Transformation( [ 9, 6, 6, 7, 8, 8, 7, 6, 9 ] ), 
>  Transformation( [ 9, 6, 6, 7, 9, 6, 9, 8, 7 ] ), 
>  Transformation( [ 9, 6, 7, 9, 6, 6, 9, 7, 8 ] ), 
>  Transformation( [ 9, 6, 8, 7, 9, 6, 9, 8, 7 ] ), 
>  Transformation( [ 9, 7, 6, 8, 7, 7, 9, 6, 8 ] ), 
>  Transformation( [ 9, 7, 7, 8, 9, 6, 9, 7, 8 ] ), 
>  Transformation( [ 9, 8, 8, 9, 6, 7, 6, 8, 9 ] ) );;
gap> IsRightSimple(S);
false
gap> IsLeftSimple(S);
true
gap> IsGroupAsSemigroup(S);
false
gap> NrRClasses(S);
16</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftZeroSemigroup">
  <ManSection>
    <Prop Name="IsLeftZeroSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsLeftZeroSemigroup</C> returns  <K>true</K> if the semigroup <A>S</A>
      of transformations or partial permutations is
      a left zero semigroup and <K>false</K> if it is not. <P/>

      A semigroup is a <E>left zero semigroup</E> if <C>x*y=x</C> for
      all <C>x,y</C>. An inverse semigroup is a left zero semigroup if and only
      if it is trivial. 

      <Example>
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
> Transformation( [ 1, 2, 3, 3, 3 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsLeftZeroSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicSemigroup">
  <ManSection>
    <Prop Name="IsMonogenicSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
   <Description>
     <C>IsMonogenicSemigroup</C> returns <K>true</K> if the semigroup <A>S</A>
     of transformations or partial permutations is monogenic and it returns
     <K>false</K> if it is not. <P/>

     A semigroup is <E>monogenic</E> if it is generated by a single element.
     See also <Ref Prop="IsMonogenicInverseSemigroup"/> and <Ref Attr="IndexPeriodOfTransformation"/>.
<Example>
gap> S:=Semigroup(
> Transformation( [ 2, 2, 2, 11, 10, 8, 10, 11, 2, 11, 10, 2, 11, 11, 10 ] ),
> Transformation( [ 2, 2, 2, 8, 11, 15, 11, 10, 2, 10, 11, 2, 10, 4, 7 ] ), 
> Transformation( [ 2, 2, 2, 11, 10, 8, 10, 11, 2, 11, 10, 2, 11, 11, 10 ] ),
> Transformation( [ 2, 2, 12, 7, 8, 14, 8, 11, 2, 11, 10, 2, 11, 15, 4 ] ));;
gap> IsMonogenicSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicInverseSemigroup">
  <ManSection>
    <Prop Name="IsMonogenicInverseSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
   <Description>
     <C>IsMonogenicInverseSemigroup</C> returns <K>true</K> if the semigroup
     <A>S</A> of transformations or partial permutations is an inverse
     monogenic semigroup and it returns <K>false</K> if it is not. <P/>

     A inverse semigroup is <E>monogenic</E> if it is generated as an inverse
     semigroup by a single element.  See also <Ref
       Prop="IsMonogenicSemigroup"/> and <Ref
       Attr="IndexPeriodOfTransformation"/>.
<Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] );;
gap> S:=InverseSemigroup(f, f^2, f^3);;
gap> IsMonogenicSemigroup(S);
false
gap> IsMonogenicInverseSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonoidAsSemigroup">
  <ManSection>
    <Prop Name="IsMonoidAsSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsMonoidAsSemigroup</C> returns <K>true</K> if the semigroup
      of transformations or partial permutations <A>S</A> is a monoid and
      <K>false</K> if it is not. It is possible that <A>S</A> is a monoid but
      does not satisfy <Ref Prop="IsMonoid" BookName="ref"/> and so <A>S</A>
      does not possess the attributes of a monoid (such as, <Ref
        Attr="GeneratorsOfMonoid" BookName="ref"/>).<P/>

      A semigroup of transformations satisfies
      <C>IsMonoidAsSemigroup</C> if and only if it satisfies
      <Ref Prop="IsTransformationMonoid" BookName="ref"/>.
     A semigroup of partial permutations satisfies <C>IsMonoidAsSemigroup</C>
     if and only if it satisfies <Ref Prop="IsPartialPermMonoid"/>.   <P/>

     See also <Ref Attr="One" BookName="ref"/>, <Ref Prop="IsInverseMonoid"/>
     and <Ref Oper="IsomorphismTransformationMonoid"/>.
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ),
> Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) );;
gap> IsMonoidAsSemigroup(S);
true
gap> MultiplicativeNeutralElement(S);
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 9 ] )
gap> S:=Monoid(Transformation( [ 8, 2, 8, 9, 10, 6, 2, 8, 7, 8 ] ),
> Transformation( [ 9, 2, 6, 3, 6, 4, 5, 5, 3, 2 ] ));;
gap> IsMonoidAsSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismTransformationMonoid">
<ManSection>
  <Oper Name="IsomorphismTransformationMonoid" Arg="S"/>
  <Oper Name="IsomorphismTransformationSemigroup" Arg="S"/>
  <Returns>An isomorphism.
  </Returns>
  <Description>
  <C>IsomorphismTransformationSemigroup(<A>S</A>)</C>
   returns an isomorphism from the semigroup <A>S</A> to a
   semigroup of transformations.<P/>

   <C>IsomorphismTransformationMonoid(<A>S</A>)</C> returns an isomorphism from
   the monoid <A>S</A> to a monoid of transformations. <P/>
   
   We only describe <C>IsomorphismTransformationMonoid</C>,
   the corresponding statements for <C>IsomorphismTransformationSemigroup</C>
   also hold.

   <List>

     <Mark>Partial permutation semigroups</Mark>
     <Item>
       If <A>S</A> is a partial permutation monoid, then
       <C>IsomorphismTransformationMonoid(<A>S</A>)</C> returns an isomorphism
       from <A>S</A> to a monoid of partial permutations on
       <C>[1..LargestMovedPoint(<A>S</A>)+1]</C> obtained using <Ref
         Func="AsTransformation"/>. The inverse of this isomorphism is obtained
       using <Ref Func="AsPartialPerm"/>; see <Ref Attr="LargestMovedPoint"
         Label="for a partial perm"/>, 
       <Ref Func="InverseMonoid"/> and <Ref Func="Monoid" BookName="ref"/>.
     </Item>
     
    <Mark>Permutation groups</Mark>
    <Item>
      If <A>S</A> is a permutation group, then
      <C>IsomorphismTransformationMonoid</C> returns an isomorphism from
      <A>S</A> to a transformation monoid acting on the set
      <C>[1..NrMovedPoints(<A>S</A>)]</C> obtained using 
      <Ref Func="AsTransformation"/>; see 
      <Ref Attr="NrMovedPoints" BookName="ref"/>.
    </Item>

    <Mark>Transformation semigroups</Mark>
    <Item>
      If <A>obj</A> is a transformation semigroup satisfying <Ref
      Prop="IsMonoidAsSemigroup"/>, then this function returns an isomorphism
      from <A>obj</A> to a transformation monoid. <P/>
    </Item>
  </List>

  <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ),
> Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) );;
gap> IsTransformationMonoid(S);
false
gap> IsMonoidAsSemigroup(S);
true
gap> M:=Range(IsomorphismTransformationMonoid(S));
&lt;monoid with 2 generators>
gap> IsTransformationMonoid(M);
true
gap> s:=InverseMonoid(
>  PartialPermNC( [ 1, 2, 3 ], [ 4, 2, 3 ] ),
>  PartialPermNC( [ 1, 2, 4 ], [ 1, 3, 2 ] ),
>  PartialPermNC( [ 1, 2, 4 ], [ 4, 1, 2 ] ) );;
gap> t:=Range(IsomorphismTransformationMonoid(s));
&lt;monoid with 5 generators>
gap> Size(s); Size(t);
117
117</Example>
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismPartialPermSemigroup">
<ManSection>
  <Oper Name="IsomorphismPartialPermMonoid" Arg="S"/>
  <Oper Name="IsomorphismPartialPermSemigroup" Arg="S"/>
  <Returns>An isomorphism.</Returns>
  <Description>
    <C>IsomorphismPartialPermSemigroup(<A>S</A>)</C>
     returns an isomorphism from the inverse semigroup or group <A>S</A> to an
     inverse semigroup of partial permutations.<P/>

     <C>IsomorphismPartialPermMonoid(<A>S</A>)</C> returns an isomorphism from
     the inverse monoid or group <A>S</A> to an inverse monoid of partial
     permutations.<P/> 
     
     We only describe <C>IsomorphismPartialPermMonoid</C>,
     the corresponding statements for <C>IsomorphismPartialPermSemigroup</C>
     also hold.

     <List>

       <Mark>Partial permutation semigroups</Mark>
       <Item>
         If <A>S</A> is a partial permutation semigroup that does not satisfy
         <Ref Prop="IsMonoid" BookName="ref"/> but does satisfy <Ref
           Prop="IsMonoidAsSemigroup"/>, then
         <C>IsomorphismPartialPermMonoid(<A>S</A>)</C> returns an isomorphism
         from <A>S</A> to an inverse monoid of partial permutations; see
         <Ref Func="InverseMonoid"/>.
       </Item>
       
      <Mark>Permutation groups</Mark>
      <Item>
        If <A>S</A> is a permutation group, then
        <C>IsomorphismPartialPermMonoid</C> returns an isomorphism from
        <A>S</A> to an inverse monoid of partial permutations on the set
        <C>MovedPoints(<A>S</A>)</C> obtained using <Ref Func="AsPartialPerm"/>.
        The inverse of this isomorphism is obtained using <Ref
          Func="AsPermutation"/>; see <Ref Attr="MovedPoints" BookName="ref"/>.
      </Item>
      <Mark>Transformation semigroups</Mark>
      <Item>
        If <A>S</A> is a transformation semigroup satisfying <Ref
          Prop="IsInverseMonoid"/>, then
        <C>IsomorphismPartialPermMonoid</C> returns an isomorphism from
        <A>S</A> to an inverse monoid of partial permutations on a subset of
        <C>[1..DegreeOfTransformationSemigroup(<A>S</A>)]</C>.
      </Item>
    </List>
    <Example>
gap> s:=InverseSemigroup( 
> PartialPermNC( [ 1, 2, 3, 4, 5 ], [ 4, 2, 3, 1, 5 ] ),
> PartialPermNC( [ 1, 2, 4, 5 ], [ 3, 1, 4, 2 ] ) );;
gap> IsMonoid(s); 
false
gap> IsMonoidAsSemigroup(s);
true
gap> iso:=IsomorphismPartialPermMonoid(s);
MappingByFunction( &lt;inverse semigroup with 
2 generators>, &lt;inverse monoid with 
2 generators>, function( x ) ... end, function( x ) ... end )
gap> Size(s);
508
gap> Size(Range(iso));
508
gap> g:=Group((1,2)(3,8)(4,6)(5,7), (1,3,4,7)(2,5,6,8), (1,4)(2,6)(3,7)(5,8));;
gap> IsomorphismPartialPermSemigroup(g);
MappingByFunction( Group([ (1,2)(3,8)(4,6)(5,7), (1,3,4,7)(2,5,6,8),
  (1,4)(2,6)(3,7)(5,8) ]), &lt;inverse semigroup with
3 generators>, function( p ) ... end, function( f ) ... end )
gap> s:=Semigroup(Transformation( [ 2, 5, 1, 7, 3, 7, 7 ] ), 
> Transformation( [ 3, 6, 5, 7, 2, 1, 7 ] ) );;
gap> iso:=IsomorphismPartialPermMonoid(s);
MappingByFunction( &lt;inverse monoid with 2 generators>, &lt;inverse monoid with 
2 generators>, function( f ) ... end, function( x ) ... end )
gap> MovedPoints(Range(iso));
[ 1, 2, 3, 5, 6 ]</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismPermGroup">
<ManSection>
  <Oper Name="IsomorphismPermGroup" Arg="S"/>
  <Returns>An isomorphism.
  </Returns>
  <Description>
    If the semigroup of transformations or partial permutations <A>S</A>
    satisfies <Ref Prop="IsGroupAsSemigroup"/>, then
    <C>IsomorphismPermGroup</C> returns an isomorphism to a permutation
    group.<P/> 
   
    If <A>S</A> does not satisfy <Ref Prop="IsGroupAsSemigroup"/>,
    then an error is given.

<Example>
gap> S:=Semigroup( Transformation( [ 2, 2, 3, 4, 6, 8, 5, 5 ] ),
> Transformation( [ 3, 3, 8, 2, 5, 6, 4, 4 ] ) );;
gap> IsGroupAsSemigroup(S);
true
gap> IsomorphismPermGroup(S); 
MappingByFunction( &lt;semigroup with 2 generators>, Group([ (5,6,8), (2,3,8,4) 
 ]), &lt;Operation "AsPermutation">, function( x ) ... end )
gap> StructureDescription(Range(IsomorphismPermGroup(S)));
"S6"
gap> s:=Range(IsomorphismPartialPermSemigroup(SymmetricGroup(4)));
&lt;inverse semigroup with 2 generators>
gap> IsomorphismPermGroup(s);
MappingByFunction( &lt;inverse semigroup with 2 generators>, Group(
[ (1,2,3,4), (1,2) ]), &lt;Operation "AsPermutation">, function( x ) ... end )</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsOrthodoxSemigroup">
  <ManSection>
    <Prop Name="IsOrthodoxSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsOrthodoxSemigroup</C> returns <K>true</K> if the semigroup 
      <A>S</A> of transformations or partial permutations is 
      orthodox and <K>false</K> if it is not.<P/>

      A semigroup is <E>orthodox</E> if it is regular and its  
      idempotent elements form a subsemigroup.
      Every inverse semigroup is also an orthodox semigroup.
      <P/>

      See also <Ref Prop="IsRegularSemigroup"/> and 
      <Ref Prop="IsRegularSemigroup" BookName="ref"/>.

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 5, 4 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 2 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 3 ] ), 
>  Transformation( [ 5, 5, 5, 5, 5, 5 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsOrthodoxSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRectangularBand">
  <ManSection>
    <Prop Name="IsRectangularBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsRectangularBand</C> returns <K>true</K> if the semigroup <A>S</A> of
      transformations or partial permutations is a 
      rectangular band and <K>false</K> if it is not.<P/>
      
      A semigroup <A>S</A> is a <E>rectangular band</E> if for all <C>x,y,z</C> 
      in <A>S</A> we have that <C>x^2=x</C> and <C>xyz=xz</C>.
      An inverse semigroup is a rectangular band if and only if it is a group.
      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRectangularBand(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularSemigroup">
  <ManSection>
    <Prop Name="IsRegularSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsRegularSemigroup</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is regular
      and <K>false</K> if it is not. <P/>

      A semigroup <C>S</C> is <E>regular</E> if for all <C>x</C> in <C>S</C> 
      there exists <C>y</C> in <C>S</C> such that <C>x*y*x=x</C>. Every inverse
      semigroup is regular, and a semigroup of partial permutations is regular
      if and only if it is an inverse semigroup.<P/>

      See also <Ref Prop="IsRegularDClass" BookName="ref"/>,
      <Ref Func="IsRegularDClass"/>,   
      and <Ref Func="IsRegularTransformation"/>.
      
      <Example>
gap> IsRegularSemigroup(FullTransformationSemigroup(5));
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRightZeroSemigroup">
  <ManSection>
    <Prop Name="IsRightZeroSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsRightZeroSemigroup</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is 
      a right zero semigroup and <K>false</K> if it is not.<P/>
      
      A semigroup <C>S</C> is a <E>right zero semigroup</E> if <C>x*y=y</C> for 
      all <C>x,y</C> in <C>S</C>. An inverse semigroup is a right zero
      semigroup if and only if it is trivial. 
      <Example>
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
>  Transformation( [ 1, 2, 4, 4, 1 ] )];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemilatticeAsSemigroup">
  <ManSection>
    <Prop Name="IsSemilatticeAsSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsSemilatticeAsSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is a semilattice and <K>false</K> if it is not.
      <P/>
      
      A semigroup is a
      <E>semilattice</E> if it is commutative and every element is an 
      idempotent. The idempotents of an inverse semigroup form a semilattice. 
      <Example>
gap> S:=Semigroup(Transformation( [ 2, 5, 1, 7, 3, 7, 7 ] ), 
> Transformation( [ 3, 6, 5, 7, 2, 1, 7 ] ) );;                    
gap> Size(S);
631
gap> IsInverseSemigroup(S);
true
gap> A:=Semigroup(Idempotents(S)); 
&lt;semigroup with 32 generators>
gap> IsSemilatticeAsSemigroup(A);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSimpleSemigroup">
  <ManSection><Heading>IsSimpleSemigroup</Heading>
    <Prop Name="IsSimpleSemigroup" Arg="S"/>
    <Prop Name="IsCompletelySimpleSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsSimpleSemigroup</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is simple 
      and <K>false</K> if it is not.<P/>
      
      A semigroup is <E>simple</E> if it has no proper
      2-sided ideals. A semigroup is <E>completely simple</E> if it is simple 
      and possesses minimal left and right ideals. A finite semigroup is simple 
      if and only if it is completely simple.  An inverse semigroup is simple
      if and only if it is a group.
      <Example>
gap> gens:=[ Transformation( [ 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 2 ] ), 
>  Transformation( [ 1, 1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 3 ] ), 
>  Transformation( [ 1, 7, 3, 9, 5, 11, 7, 1, 9, 3, 11, 5, 5 ] ), 
>  Transformation( [ 7, 7, 9, 9, 11, 11, 1, 1, 3, 3, 5, 5, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsSimpleSemigroup(S);
true
gap> IsCompletelySimpleSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSynchronizingSemigroup">
  <ManSection>
    <Prop Name="IsSynchronizingSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsSynchronizingSemigroup</C> returns <K>true</K> if the semigroup of
      transformations <A>S</A> contains a
      constant transformation. 
      See also <Ref Oper="ConstantTransformation"/>. 
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 1, 8, 7, 6, 6, 4, 1, 8, 9 ] ), 
>  Transformation( [ 5, 8, 7, 6, 10, 8, 7, 6, 9, 7 ] ) );;
gap> IsSynchronizingSemigroup(S);
true
gap> S:=Semigroup( Transformation( [ 3, 8, 1, 1, 9, 9, 8, 7, 9, 6 ] ), 
>  Transformation( [ 7, 6, 8, 7, 5, 6, 8, 7, 8, 9 ] ) );;
gap> IsSynchronizingSemigroup(S);
false
gap> Representative(MinimalIdeal(S));
Transformation( [ 7, 7, 8, 7, 7, 7, 8, 7, 8, 7 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroGroup">
  <ManSection>
    <Prop Name="IsZeroGroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description> 
      <C>IsZeroGroup</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is 
      a zero group and <K>false</K> if it is not.<P/>

      A semigroup <C>S</C> is a <E>zero group</E> if there exists an 
      element <C>z</C> in <C>S</C> such that <C>S</C> without <C>z</C> is a
      group and <C>x*z=z*x=z</C> for all <C>x</C> in <C>S</C>.
      Every zero group is an inverse semigroup. 
      <Example>
gap> S:=Semigroup(Transformation( [ 2, 2, 3, 4, 6, 8, 5, 5, 9 ] ),
> Transformation( [ 3, 3, 8, 2, 5, 6, 4, 4, 9 ] ),
> ConstantTransformation(9, 9));;
gap> IsZeroGroup(S);
true
gap> T:=Range(IsomorphismPartialPermSemigroup(S));;
gap> IsZeroGroup(T);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroRectangularBand">
  <ManSection>
    <Prop Name="IsZeroRectangularBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsZeroRectangularBand</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is a zero
      rectangular band and <K>false</K> if it is not.<P/>

      A semigroup is a <E>zero rectangular band</E> if it is zero simple and
      &H;-trivial; see also <Ref Prop="IsZeroSimpleSemigroup"/>
      and <Ref Prop="IsHTrivial"/>.
      An inverse semigroup is a zero rectangular band if and only if it is a
      zero group; see <Ref Prop="IsZeroGroup"/>.
<Example>
gap> S:=Semigroup( 
>  Transformation( [ 1, 3, 7, 9, 1, 12, 13, 1, 15, 9, 1, 18, 1, 1, 13, 1, 1, 
>      21, 1, 1, 1, 1, 1, 25, 26, 1 ] ),
> Transformation( [ 1, 5, 1, 5, 11, 1, 1, 14, 1, 16, 17, 1, 1, 19, 1, 11, 1,
>      1, 1, 23, 1, 16, 19, 1, 1, 1 ] ),
> Transformation( [ 1, 4, 8, 1, 10, 1, 8, 1, 1, 1, 10, 1, 8, 10, 1, 1, 20, 1,
>      22, 1, 8, 1, 1, 1, 1, 1 ] ),
> Transformation( [ 1, 6, 6, 1, 1, 1, 6, 1, 1, 1, 1, 1, 6, 1, 6, 1, 1, 6, 1,
>      1, 24, 1, 1, 1, 1, 6 ] ) );;
gap> IsZeroRectangularBand(Semigroup(Elements(GreensDClasses(S)[9]))); 
true
gap> IsZeroRectangularBand(Semigroup(Elements(GreensDClasses(S)[3])));
true
gap> IsZeroRectangularBand(Semigroup(Elements(GreensDClasses(S)[1])));
false</Example>
    </Description>
  </ManSection>  
<#/GAPDoc>

<#GAPDoc Label="IsZeroSemigroup">
  <ManSection>
    <Prop Name="IsZeroSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description> 
      <C>IsZeroSemigroup</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is 
      a zero semigroup and <K>false</K> if it is not.<P/>

      A semigroup <C>S</C> is a <E>zero semigroup</E> if there exists an 
      element <C>z</C> in <C>S</C> such that <C>x*y=z</C> for all <C>x,y</C>
      in <C>S</C>. An inverse semigroup is a zero semigroup if and only if it
      is trivial. 

      <Example>
gap> S:=Semigroup( Transformation( [ 4, 7, 6, 3, 1, 5, 3, 6, 5, 9 ] ), 
> Transformation( [ 5, 3, 5, 1, 9, 3, 8, 7, 4, 3 ] ) );;
gap> IsZeroSemigroup(S);
false
gap> S:=Semigroup( Transformation( [ 7, 8, 8, 8, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 8, 8, 5, 7, 8, 8 ] ), 
>  Transformation( [ 8, 7, 8, 8, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 8, 7, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 7, 8, 5, 8, 8, 8 ] ) );;
gap> IsZeroSemigroup(S);
true
gap> MultiplicativeZero(S);
Transformation( [ 8, 8, 8, 8, 5, 8, 8, 8 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroSimpleSemigroup">
  <ManSection>
    <Prop Name="IsZeroSimpleSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsZeroSimpleSemigroup</C> returns <K>true</K> if the semigroup of
      transformations or partial permutations <A>S</A> is
      a zero simple semigroup and <K>false</K> if it is not.<P/>

      A semigroup is a <E>zero simple semigroup</E> if it has no two-sided 
      ideals other than itself and the set containing the zero element; see
      also <Ref Attr="MultiplicativeZero"/>. An inverse semigroup is zero
      simple if and only if it is a Brandt semigroup; see <Ref
        Prop="IsBrandtSemigroup"/>.

      <Example>
gap> S:=Semigroup( 
>  Transformation( [ 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 5, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 17, 11, 17, 17, 17, 17, 17, 17, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 4, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 5, 17, 17, 17, 17, 17, 17, 17, 17, 
>  17, 17, 17, 17, 17 ] ));;
gap> IsZeroSimpleSemigroup(S);
true
gap> S:=Semigroup(
> Transformation( [ 2, 3, 4, 5, 1, 8, 7, 6, 2, 7 ] ),
> Transformation([ 2, 3, 4, 5, 6, 8, 7, 1, 2, 2 ] ));;
gap> IsZeroSimpleSemigroup(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="MinimalIdeal">
  <ManSection>
    <Attr Name="MinimalIdeal" Arg="S"/>
    <Returns> 
    The minimal ideal of a semigroup. 
    </Returns>
    <Description>
    The minimal ideal of a semigroup is the least ideal with respect to
    containment. <P/> 

    Currently, <C>MinimalIdeal</C> returns a semigroup with as
    many generators as elements. There are plans to improve this in future
    versions of &Citrus;. <P/>

    Note that <C>MinimalIdeal</C> is significantly faster than finding the
    &D;-class with minimum rank representative (which is also
    the minimal ideal). 

    See also <Ref Attr="PartialOrderOfDClasses"/> and 
    <Ref Oper="IsGreensLessThanOrEqual" BookName="ref"/>. 
    
    <Example>
gap> S:=Semigroup( Transformation( [ 3, 4, 1, 3, 6, 3, 4, 6, 10, 1 ] ), 
> Transformation( [ 8, 2, 3, 8, 4, 1, 3, 4, 9, 7 ] ));;
gap> MinimalIdeal(S);
&lt;semigroup with 5 generators>
gap> Elements(MinimalIdeal(S));
[ Transformation( [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ), 
  Transformation( [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 ] ), 
  Transformation( [ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ] ), 
  Transformation( [ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 ] ), 
  Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 ] ) ]
gap> f:=Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 ] );;
gap> D:=DClass(S, f);
{Transformation( [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 ] )}
gap> ForAll(GreensDClasses(S), x-> IsGreensLessThanOrEqual(D, x));
true
gap> S:=POI(10);                  
&lt;inverse monoid with 10 generators>
gap> MinimalIdeal(S);
&lt;inverse semigroup with 1 generator></Example>
    </Description>
  </ManSection>
<#/GAPDoc>
    
<#GAPDoc Label="MultiplicativeZero">
  <ManSection>
    <Attr Name="MultiplicativeZero" Arg="S"/>
    <Returns>
     The zero element of a semigroup.
    </Returns>
    <Description>
      <C>MultiplicativeZero</C> returns the zero element of the semigroup
      <A>S</A> of transformations or partial permutations if it has one and
      <K>fail</K> if it does not. 
      See also <Ref Attr="MultiplicativeZero" BookName="ref"/>.
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 2, 6, 6, 5, 2 ] ), 
> Transformation( [ 1, 6, 3, 6, 2, 1, 6 ] ));;
gap> MultiplicativeZero(S);
Transformation( [ 1, 1, 1, 1, 1, 1, 1 ] )
gap> S:=Semigroup(Transformation( [ 2, 8, 3, 7, 1, 5, 2, 6 ] ), 
> Transformation( [ 3, 5, 7, 2, 5, 6, 3, 8 ] ), 
> Transformation( [ 6, 7, 4, 1, 4, 1, 6, 2 ] ), 
> Transformation( [ 8, 8, 5, 1, 7, 5, 2, 8 ] ));;
gap> MultiplicativeZero(S);
fail
gap> S:=InverseSemigroup( PartialPermNC( [ 1, 3, 4 ], [ 5, 3, 1 ] ),
> PartialPermNC( [ 1, 2, 3, 4 ], [ 4, 3, 1, 2 ] ),
> PartialPermNC( [ 1, 3, 4, 5 ], [ 2, 4, 5, 3 ] ) );;
gap> MultiplicativeZero(S);
&lt;empty mapping></Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NaturalPartialOrder">
<ManSection>
  <Attr Name="NaturalPartialOrder" Arg="S"/>
  <Returns>The natural partial order on an inverse semigroup.</Returns>
  <Description>
    The <E>natural partial order</E> <M>\leq</M> on an inverse semigroup
    <M>S</M> is defined by <M>s\leq</M><M>t</M> if there exists an idempotent
    <M>e</M> in <M>S</M> such that <M>s=et</M>. Hence if <A>f</A> and
    <A>g</A> are partial permutations, then <A>f</A><M>\leq</M><A>g</A> if
    and only if <A>f</A> is a restriction of <A>g</A>;
    see <Ref Oper="RestrictedPartialPerm"/>.<P/> 

    <C>NaturalPartialOrder</C> returns the natural partial order on the inverse
    semigroup of partial permutations <A>S</A> as a list of sets of positive
    integers where entry <C>i</C> in <C>NaturalPartialOrder(<A>S</A>)</C> is
    the set of positions in <C>Elements(<A>S</A>)</C> of elements less than
    <C>Elements(<A>S</A>)[i]</C>. See also 
    <Ref Func="NaturalLeqPartialPerm"/>.<P/>
  
    <Example>
gap> S:=InverseSemigroup([ PartialPermNC( [ 1, 3 ], [ 1, 3 ] ),
> PartialPermNC( [ 1, 2 ], [ 3, 2 ] ) ] );
&lt;inverse semigroup with 2 generators>
gap> Size(S);
11
gap> NaturalPartialOrder(S);
[ [  ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], 
  [ 1, 2, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ] ]
gap> NaturalLeqPartialPerm(Elements(S)[4], Elements(S)[10]);
true
gap> NaturalLeqPartialPerm(Elements(S)[4], Elements(S)[9]); 
false</Example>
  </Description>
</ManSection>
<#/GAPDoc>

</ManSection>
<#GAPDoc Label="NrElementsOfRank">
  <ManSection>
    <Attr Name="NrElementsOfRank" Arg="S, n"/>
    <Returns>the number of elements of a given rank. </Returns>
    <Description><C>NrElementsOfRank</C> returns the number of elements of the
    semigroup <A>S</A> of partial permutations or transformations with rank
    <A>n</A>; see 
    <Ref Func="Rank" Label="for a transformation"/>, 
    <Ref Func="RankOfPartialPerm"/> and
    <Ref Attr="RankOfTransformation" BookName="ref"/>.

    <Example>
gap> S:=Semigroup( Transformation( [ 1, 3, 4, 1, 3 ] ), 
> Transformation( [ 2, 4, 1, 5, 5 ] ), 
> Transformation( [ 2, 5, 3, 5, 3 ] ), 
> Transformation( [ 4, 1, 2, 2, 1 ] ), 
>  Transformation( [ 5, 5, 1, 1, 3 ] ) );;
gap> NrElementsOfRank(S, 10);
0
gap> Size(S);
602
gap> List([1..5], x-> NrElementsOfRank(S, x));
[ 5, 260, 336, 1, 0 ]
gap> Sum(last);
602
gap> T:=FullTransformationSemigroup(5);;
gap> List([1..5], x-> NrElementsOfRank(T, x));
[ 5, 300, 1500, 1200, 120 ]
gap> Sum(last);
3125
gap> S:=SymmetricInverseSemigp(5);;
gap> NrElementsOfRank(S, 4);
600
gap> Binomial(5,4)^2*Factorial(4);
600</Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SmallGeneratingSet">
<ManSection>
  <Attr Name="SmallGeneratingSet" Arg="S"/>
  <Returns>A small generating set for a semigroup.</Returns>
    <Description>
      <C>SmallGeneratingSet</C> returns a relatively small generating subset
      of the set of generators of the semigroup <A>S</A> of transformations or
      partial permutations; see <Ref Func="Generators"/>. If the number of
      generators for <A>S</A> is already relatively small, then this function
      will often return the original generating set.<P/> 

      As neither irredundancy, nor minimal length are proven,
    <C>SmallGeneratingSet</C> usually returns an answer  much faster than
    <Ref Oper="IrredundantGeneratingSubset"/>. It can be used whenever a
    small generating set is desired which does not necessarily needs to be
    optimal. <C>SmallGeneratingSet</C> works particularly well for inverse
    semigroups of partial permutations.<P/>
    
    Note that <C>SmallGeneratingSet</C> may return different
    results in different &GAP; sessions.

      <Log>
gap> S:=Semigroup( Transformation( [ 1, 2, 3, 2, 4 ] ), 
> Transformation( [ 1, 5, 4, 3, 2 ] ),
> Transformation( [ 2, 1, 4, 2, 2 ] ), Transformation( [ 2, 4, 4, 2, 1 ] ),
> Transformation( [ 3, 1, 4, 3, 2 ] ), Transformation( [ 3, 2, 3, 4, 1 ] ),
> Transformation( [ 4, 4, 3, 3, 5 ] ), Transformation( [ 5, 1, 5, 5, 3 ] ),
> Transformation( [ 5, 4, 3, 5, 2 ] ), Transformation( [ 5, 5, 4, 5, 5 ] ) );;
gap> SmallGeneratingSet(S);                  
[ Transformation( [ 1, 5, 4, 3, 2 ] ), Transformation( [ 3, 2, 3, 4, 1 ] ), 
  Transformation( [ 5, 4, 3, 5, 2 ] ), Transformation( [ 1, 2, 3, 2, 4 ] ), 
  Transformation( [ 4, 4, 3, 3, 5 ] ) ]
gap> S:=RandomInverseMonoid(10000,10);;
gap> SmallGeneratingSet(S);
[ [ 1 .. 10 ] -> [ 3, 2, 4, 5, 6, 1, 7, 10, 9, 8 ], 
  [ 1 .. 10 ] -> [ 5, 10, 8, 9, 3, 2, 4, 7, 6, 1 ], 
  [ 1, 3, 4, 5, 6, 7, 8, 9, 10 ] -> [ 1, 6, 4, 8, 2, 10, 7, 3, 9 ] ]</Log>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="PrimitiveIdempotents">
<ManSection>
  <Attr Name="PrimitiveIdempotents" Arg="S"/>
  <Returns>A list of idempotent partial permutations.</Returns>
  <Description>
    An idempotent in an inverse semigroup <A>S</A> is <E>primitive</E> if it is
    non-zero and minimal with respect to the <Ref Attr="NaturalPartialOrder"/>
    on <A>S</A>. <C>PrimitiveIdempotents</C> returns the list of primitive
    idempotents in the inverse semigroup of partial permutations <A>S</A>. 
    <Example>
gap> S:= InverseMonoid(
> PartialPermNC( [ 1 ], [ 4 ] ),
> PartialPermNC( [ 1, 2, 3 ], [ 2, 1, 3 ] ),
> PartialPermNC( [ 1, 2, 3 ], [ 3, 1, 2 ] ) );;
gap> MultiplicativeZero(S);
&lt;empty mapping>
gap> PrimitiveIdempotents(S);
[ &lt;identity on [ 4 ]>, &lt;identity on [ 1 ]>, &lt;identity on [ 2 ]>, 
  &lt;identity on [ 3 ]> ]</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="PrincipalFactor">
<ManSection>
  <Attr Name="PrincipalFactor" Arg="D"/>
  <Returns>A Rees matrix semigroup.</Returns>
  <Description> 
    <C>PrincipalFactor(<A>D</A>)</C> is just shorthand for
    <C>Range(InjectionPrincipalFactor(<A>D</A>))</C>; see
    <Ref Oper="InjectionPrincipalFactor"/> for more details. 
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsPartialPermSemigroup">
<ManSection>
  <Prop Name="IsPartialPermSemigroup" Arg="S"/>
  <Prop Name="IsPartialPermMonoid" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description> 
    <C>IsPartialPermSemigroup</C> returns <K>true</K> if <A>S</A> is a
    semigroup of partial permutations and <K>false</K> if it is not. 
    <C>IsPartialPermMonoid</C> returns <K>true</K> if <A>S</A> is a monoid of
    partial permutations and <K>false</K> if it is not. Note that a semigroup
    <A>S</A> satisfies <C>IsPartialPermMonoid</C> if and only if it contains an
    identity but <A>S</A> may or may not satisfy <Ref Prop="IsMonoid"
      BookName="ref"/>; see <Ref Prop="IsMonoidAsSemigroup"/>.
  </Description>
</ManSection>
<#/GAPDoc>


#EOF
