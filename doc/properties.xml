#############################################################################
##
#W  properties.xml
#Y  Copyright (C) 2011-13                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="IsRectangularGroup">
  <ManSection>
    <Prop Name="IsRectangularGroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      A semigroup is <E>rectangular group</E> if it is the direct product of a
      group and a rectangular band. Or equivalently, if it is orthodox and simple.

      <Example><![CDATA[
gap> G := AsSemigroup(IsTransformationSemigroup, MathieuGroup(11));
<transformation group of size 7920, degree 11 with 2 generators>
gap> R := RectangularBand(3, 2);
<regular transformation semigroup of size 6, degree 6 with 3
 generators>
gap> S := DirectProduct(G, R);;
gap> IsRectangularGroup(R);
true
gap> IsRectangularGroup(G);
true
gap> IsRectangularGroup(S);
true
gap> IsRectangularGroup(JonesMonoid(3));
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsUnitRegularMonoid">
  <ManSection>
    <Prop Name="IsUnitRegularMonoid" Arg="S"/>
    <Returns><K>true</K> if the semigroup <A>S</A> is unit regular
          and <K>false</K> if it is not.
    </Returns>
    <Description>
      A monoid is <E>unit regular</E> if and only if for every <C>>x</C> in
      <A>S</A> there exists an element <C>y</C> in the group of units of
      <A>S</A> such that <C>x*y*x=x</C>.

      <Example><![CDATA[
gap> IsUnitRegularMonoid(FullTransformationMonoid(3));
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBand">
  <ManSection>
    <Prop Name="IsBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsBand</C> returns <K>true</K> if every element of the semigroup
      <A>S</A> is an idempotent and <K>false</K> if it is not. An inverse
      semigroup is band if and only if it is a semilattice; see
      <Ref Prop="IsSemilattice"/>.

      <Example><![CDATA[
gap> S := Semigroup(
> Transformation([1, 1, 1, 4, 4, 4, 7, 7, 7, 1]),
> Transformation([2, 2, 2, 5, 5, 5, 8, 8, 8, 2]),
> Transformation([3, 3, 3, 6, 6, 6, 9, 9, 9, 3]),
> Transformation([1, 1, 1, 4, 4, 4, 7, 7, 7, 4]),
> Transformation([1, 1, 1, 4, 4, 4, 7, 7, 7, 7]));;
gap> IsBand(S);
true
gap> S := InverseSemigroup(
> PartialPerm([1, 2, 3, 4, 8, 9], [5, 8, 7, 6, 9, 1]),
> PartialPerm([1, 3, 4, 7, 8, 9, 10], [2, 3, 8, 7, 10, 6, 1]));;
gap> IsBand(S);
false
gap> IsBand(IdempotentGeneratedSubsemigroup(S));
true
gap> S := PartitionMonoid(4);
<regular bipartition *-monoid of size 4140, degree 4 with 4
 generators>
gap> M := MinimalIdeal(S);
<simple bipartition *-semigroup ideal of degree 4 with 1 generator>
gap> IsBand(M);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBlockGroup">
  <ManSection>
    <Prop Name = "IsBlockGroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsBlockGroup</C> returns <K>true</K> if the semigroup <A>S</A> is a
      block group and <K>false</K> if it is not.<P/>

      A semigroup <A>S</A> is a <E>block group</E> if every &L;-class and every
      &R;-class of <A>S</A> contains at most one idempotent. Every semigroup
      of partial permutations is a block group.
      <Example><![CDATA[
gap> S := Semigroup(Transformation([5, 6, 7, 3, 1, 4, 2, 8]),
>                   Transformation([3, 6, 8, 5, 7, 4, 2, 8]));;
gap> IsBlockGroup(S);
true
gap> S := Semigroup(
> Transformation([2, 1, 10, 4, 5, 9, 7, 4, 8, 4]),
> Transformation([10, 7, 5, 6, 1, 3, 9, 7, 10, 2]));;
gap> IsBlockGroup(S);
false
gap> S := Semigroup(PartialPerm([1, 2], [5, 4]),
>                   PartialPerm([1, 2, 3], [1, 2, 5]),
>                   PartialPerm([1, 2, 3], [2, 1, 5]),
>                   PartialPerm([1, 3, 4], [3, 1, 2]),
>                   PartialPerm([1, 3, 4, 5], [5, 4, 3, 2]));;
gap> T := AsSemigroup(IsBlockBijectionSemigroup, S);
<block bijection semigroup of degree 6 with 5 generators>
gap> IsBlockGroup(T);
true
gap> IsBlockGroup(AsSemigroup(IsBipartitionSemigroup, S));
true
gap> S := Semigroup(
> Bipartition([[1, -2], [2, -3], [3, -4], [4, -1]]),
> Bipartition([[1, -2], [2, -1], [3, -3], [4, -4]]),
> Bipartition([[1, 2, -3], [3, -1, -2], [4, -4]]),
> Bipartition([[1, -1], [2, -2], [3, -3], [4, -4]]));;
gap> IsBlockGroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBrandtSemigroup">
  <ManSection>
    <Prop Name = "IsBrandtSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsBrandtSemigroup</C> return <K>true</K> if the semigroup <A>S</A> is
      a finite 0-simple inverse semigroup, and <K>false</K> if it is not. See
      also <Ref Prop = "IsZeroSimpleSemigroup"/> and <Ref
        Prop = "IsInverseSemigroup" BookName = "ref" />.
      <Example><![CDATA[
gap> S := Semigroup(
> Transformation([2, 8, 8, 8, 8, 8, 8, 8]),
> Transformation([5, 8, 8, 8, 8, 8, 8, 8]),
> Transformation([8, 3, 8, 8, 8, 8, 8, 8]),
> Transformation([8, 6, 8, 8, 8, 8, 8, 8]),
> Transformation([8, 8, 1, 8, 8, 8, 8, 8]),
> Transformation([8, 8, 8, 1, 8, 8, 8, 8]),
> Transformation([8, 8, 8, 8, 4, 8, 8, 8]),
> Transformation([8, 8, 8, 8, 8, 7, 8, 8]),
> Transformation([8, 8, 8, 8, 8, 8, 2, 8]));;
gap> IsBrandtSemigroup(S);
true
gap> T := Range(IsomorphismPartialPermSemigroup(S));;
gap> IsBrandtSemigroup(T);
true
gap> S := DualSymmetricInverseMonoid(4);;
gap> D := DClass(S,
>                Bipartition([[1, 2, 3, -1, -2, -3], [4, -4]]));;
gap> R := InjectionPrincipalFactor(D);;
gap> S := Semigroup(PreImages(R, GeneratorsOfSemigroup(Range(R))));;
gap> IsBrandtSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCliffordSemigroup">
  <ManSection>
    <Prop Name = "IsCliffordSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsCliffordSemigroup</C> returns <K>true</K> if the semigroup <A>S</A>
      is  regular and its idempotents are central, and <K>false</K> if it is
      not.
      <Example><![CDATA[
gap> S := Semigroup(Transformation([1, 2, 4, 5, 6, 3, 7, 8]),
>                   Transformation([3, 3, 4, 5, 6, 2, 7, 8]),
>                   Transformation([1, 2, 5, 3, 6, 8, 4, 4]));;
gap> IsCliffordSemigroup(S);
true
gap> T := Range(IsomorphismPartialPermSemigroup(S));;
gap> IsCliffordSemigroup(S);
true
gap> S := DualSymmetricInverseMonoid(5);;
gap> T := IdempotentGeneratedSubsemigroup(S);;
gap> IsCliffordSemigroup(T);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCommutativeSemigroup">
  <ManSection>
    <Prop Name = "IsCommutativeSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsCommutativeSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is commutative and <K>false</K> if it is not.  The function <Ref
        Prop = "IsCommutative" BookName = "ref"/> can also be used to test if a
      semigroup is commutative.<P/>

      A semigroup <A>S</A> is <E>commutative</E> if
      <C>x * y = y * x</C> for all <C>x, y</C> in <A>S</A>.

      <Example><![CDATA[
gap> S := Semigroup(Transformation([2, 4, 5, 3, 7, 8, 6, 9, 1]),
>                   Transformation([3, 5, 6, 7, 8, 1, 9, 2, 4]));;
gap> IsCommutativeSemigroup(S);
true
gap> IsCommutative(S);
true
gap> S := InverseSemigroup(
>  PartialPerm([1, 2, 3, 4, 5, 6], [2, 5, 1, 3, 9, 6]),
>  PartialPerm([1, 2, 3, 4, 6, 8], [8, 5, 7, 6, 2, 1]));;
gap> IsCommutativeSemigroup(S);
false
gap> S := Semigroup(
> Bipartition([[1, 2, 3, 6, 7, -1, -4, -6],
>              [4, 5, 8, -2, -3, -5, -7, -8]]),
>  Bipartition([[1, 2, -3, -4], [3, -5], [4, -6], [5, -7],
>               [6, -8], [7, -1], [8, -2]]));;
gap> IsCommutativeSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCompletelyRegularSemigroup">
  <ManSection>
    <Prop Name = "IsCompletelyRegularSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsCompletelyRegularSemigroup</C> returns <K>true</K> if every element
      of the semigroup <A>S</A> is contained in a subgroup of <A>S</A>.<P/>

      An inverse semigroup is completely regular if and only if it is a
      Clifford semigroup; see <Ref Prop = "IsCliffordSemigroup"/>.

      <Example><![CDATA[
gap> S := Semigroup(Transformation([1, 2, 4, 3, 6, 5, 4]),
>                   Transformation([1, 2, 5, 6, 3, 4, 5]),
>                   Transformation([2, 1, 2, 2, 2, 2, 2]));;
gap> IsCompletelyRegularSemigroup(S);
true
gap> IsInverseSemigroup(S);
true
gap> T := Range(IsomorphismPartialPermSemigroup(S));;
gap> IsCompletelyRegularSemigroup(T);
true
gap> IsCliffordSemigroup(T);
true
gap> S := Semigroup(
> Bipartition([[1, 3, -4], [2, 4, -1, -2], [-3]]),
> Bipartition([[1, -1], [2, 3, 4, -3], [-2, -4]]));;
gap> IsCompletelyRegularSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRTrivial">
  <ManSection><Heading>IsXTrivial</Heading>
    <Prop Name = "IsRTrivial" Arg = "S"/>
    <Prop Name = "IsLTrivial" Arg = "S"/>
    <Prop Name = "IsHTrivial" Arg = "S"/>
    <Prop Name = "IsDTrivial" Arg = "S"/>
    <Prop Name = "IsAperiodicSemigroup" Arg = "S"/>
    <Prop Name = "IsCombinatorialSemigroup" Arg = "S"/>
    <Returns>
      <K>true</K> or <K>false</K>.
    </Returns>
    <Description>
      <C>IsXTrivial</C> returns <K>true</K> if Green's &R;-relation,
      &L;-relation, &H;-relation, &D;-relation, respectively, on the
      semigroup <A>S</A> is trivial and <K>false</K> if it is not.
      These properties can also be applied to a Green's class instead of a
      semigroup where applicable.
      <P/>

      For inverse semigroups, the properties of being
      &R;-trivial, &L;-trivial, &D;-trivial, and a semilattice are equivalent;
      see <Ref Prop="IsSemilattice"/>.
      <P/>

      A semigroup is <E>aperiodic</E> if its contains no non-trivial
      subgroups (equivalently, all of its group &H;-classes
      are trivial). A finite semigroup is aperiodic if and only if it is
      &H;-trivial. <P/>

      <E>Combinatorial</E> is a synonym for aperiodic in this context.
      <Example><![CDATA[
gap> S := Semigroup(
>  Transformation([1, 5, 1, 3, 7, 10, 6, 2, 7, 10]),
>  Transformation([4, 4, 5, 6, 7, 7, 7, 4, 3, 10]));;
gap> IsHTrivial(S);
true
gap> Size(S);
108
gap> IsRTrivial(S);
false
gap> IsLTrivial(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsEUnitaryInverseSemigroup">
<ManSection>
  <Prop Name = "IsEUnitaryInverseSemigroup" Arg = "S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    As described in Section 5.9 of <Cite Key="Howie1995aa"/>, an inverse semigroup
    <A>S</A> with semilattice of idempotents <A>E</A> is <E>E-unitary</E> if
    for
    <Alt Not = "Text">
      <Display>
        s \in S\textrm{ and }e \in E\textrm{: }es \in E \Rightarrow s \in E.
      </Display>
    </Alt>
    <Alt Only = "Text">
      for s in S and e in E, es in E implies s in E.
    </Alt><P/>
    Equivalently, <A>S</A> is <E>E-unitary</E> if <A>E</A> is closed in the
    natural partial order (see Proposition 5.9.1 in <Cite Key="Howie1995aa"/>):
    <Alt Not = "Text">
      <Display>
        \textrm{for } s \in S\textrm{ and }e \in E\textrm{: }e \le s \Rightarrow s
        \in E.
      </Display>
    </Alt>
    <Alt Only = "Text">
      for s in S and e in E, e less than s implies s in E.
    </Alt><P/>

    This condition is equivalent to <A>E</A> being majorantly closed in
    <A>S</A>.  See <Ref Attr = "IdempotentGeneratedSubsemigroup"/> and <Ref
      Oper = "IsMajorantlyClosed"/>.
    Hence an inverse semigroup of partial permutations, block bijections or
    partial permutation bipartitions is <E>E-unitary</E> if and only if the
    idempotent semilattice is majorantly closed.
    <Example><![CDATA[
gap> S := InverseSemigroup(
>  PartialPerm([1, 2, 3, 4], [2, 3, 1, 6]),
>  PartialPerm([1, 2, 3, 5], [3, 2, 1, 6]));;
gap> IsEUnitaryInverseSemigroup(S);
true
gap> e := IdempotentGeneratedSubsemigroup(S);;
gap> ForAll(Difference(S, e), x -> not ForAny(e, y -> y * x in e));
true
gap> T := InverseSemigroup([
>  PartialPerm([1, 3, 4, 6, 8], [2, 5, 10, 7, 9]),
>  PartialPerm([1, 2, 3, 5, 6, 7, 8], [5, 8, 9, 2, 10, 1, 3]),
>  PartialPerm([1, 2, 3, 5, 6, 7, 9], [9, 8, 4, 1, 6, 7, 2])]);;
gap> IsEUnitaryInverseSemigroup(T);
false
gap> U := InverseSemigroup([
>  PartialPerm([1, 2, 3, 4, 5], [2, 3, 4, 5, 1]),
>  PartialPerm([1, 2, 3, 4, 5], [2, 1, 3, 4, 5])]);;
gap> IsEUnitaryInverseSemigroup(U);
true
gap> IsGroupAsSemigroup(U);
true
gap> StructureDescription(U);
"S5"]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsFactorisableInverseMonoid">
<ManSection>
  <Prop Name = "IsFactorisableInverseMonoid" Arg = "S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    An inverse monoid is <E>factorisable</E> if every element is the product
    of an element of the group of units and an idempotent; see also
    <Ref Attr = "GroupOfUnits"/> and <Ref Attr = "Idempotents"/>. Hence an
    inverse semigroup of partial permutations is factorisable if and only if
    each of its generators is the restriction of some element in the group of
    units.

    <Example><![CDATA[
gap> S := InverseSemigroup(
> PartialPerm([1, 2, 4], [3, 1, 4]),
> PartialPerm([1, 2, 3, 5], [4, 1, 5, 2]));;
gap> IsFactorisableInverseMonoid(S);
false
gap> IsFactorisableInverseMonoid(SymmetricInverseSemigroup(5));
true
gap> IsFactorisableInverseMonoid(DualSymmetricInverseMonoid(5));
false
gap> S := FactorisableDualSymmetricInverseMonoid(5);;
gap> IsFactorisableInverseMonoid(S);
true]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGroupAsSemigroup">
  <ManSection>
    <Prop Name = "IsGroupAsSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsGroupAsSemigroup</C> returns <K>true</K> if and only if the
      semigroup <A>S</A> is mathematically a group.
      <Example><![CDATA[
gap> S := Semigroup(Transformation([2, 4, 5, 3, 7, 8, 6, 9, 1]),
>                   Transformation([3, 5, 6, 7, 8, 1, 9, 2, 4]));;
gap> IsGroupAsSemigroup(S);
true
gap> G := SymmetricGroup(5);;
gap> IsGroupAsSemigroup(G);
true
gap> S := AsSemigroup(IsPartialPermSemigroup, G);
<partial perm group of size 120, rank 5 with 2 generators>
gap> IsGroupAsSemigroup(S);
true
gap> G := SymmetricGroup([1, 2, 10]);;
gap> T := AsSemigroup(IsBlockBijectionSemigroup, G);
<inverse block bijection semigroup of size 6, degree 11 with 2
 generators>
gap> IsGroupAsSemigroup(T);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsIdempotentGenerated">
  <ManSection><Heading>IsIdempotentGenerated</Heading>
    <Prop Name = "IsIdempotentGenerated" Arg = "S"/>
    <Prop Name = "IsSemiband" Arg = "S"/>
    <Returns>
      <K>true</K> or <K>false</K>.
    </Returns>
    <Description>
      <C>IsIdempotentGenerated</C> and <C>IsSemiband</C> return
      <K>true</K> if the semigroup <A>S</A> is generated by its idempotents and
      <K>false</K> if it is not.  See also <Ref Attr = "Idempotents"/> and
      <Ref Attr = "IdempotentGeneratedSubsemigroup"/>. <P/>

      An inverse semigroup is idempotent-generated if and only if it is a
      semilattice; see <Ref Prop = "IsSemilattice"/>.<P/>

      The terms semiband and idempotent-generated are synonymous in this
      context.

      <Example><![CDATA[
gap> S := SingularTransformationSemigroup(4);
<regular transformation semigroup ideal of degree 4 with 1 generator>
gap> IsIdempotentGenerated(S);
true
gap> S := SingularBrauerMonoid(5);
<regular bipartition *-semigroup ideal of degree 5 with 1 generator>
gap> IsIdempotentGenerated(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsInverseSemigroup">
<ManSection>
  <Prop Name="IsInverseSemigroup" Arg="S"/>
  <Prop Name="IsInverseMonoid" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    If <A>S</A> is a semigroup, then <C>IsInverseSemigroup</C> returns
    <K>true</K> if <A>S</A> is an inverse semigroup and <K>false</K> if it is
    not. If <A>S</A> is monoid, then <C>IsInverseMonoid</C> returns <K>true</K>
    if <A>S</A> is an inverse monoid and <K>false</K> if it is not.<P/>

    A semigroup is an <E>inverse semigroup</E> if every element
    <C>x</C> has a unique semigroup inverse, that is, a unique
    element <C>y</C> such that <C>x * y * x = x</C> and <C>y * x * y = y</C>.

    <Example><![CDATA[
gap> S := Semigroup(Transformation([1, 2, 4, 5, 6, 3]),
>                   Transformation([3, 3, 4, 5, 6, 2]),
>                   Transformation([1, 2, 5, 3, 6, 8, 4, 4]));
gap> IsInverseSemigroup(S);
true]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftSimple">
  <ManSection>
    <Prop Name = "IsLeftSimple" Arg = "S"/>
    <Prop Name = "IsRightSimple" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
    <C>IsLeftSimple</C> and <C>IsRightSimple</C> returns <K>true</K> if the
    semigroup <A>S</A> has only one &L;-class or one &R;-class,
    respectively, and returns <K>false</K> if it has more than one. <P/>

    An inverse semigroup is left simple if and only if it is right simple if
    and only if it is a group; see <Ref Prop="IsGroupAsSemigroup"/>.
<Example><![CDATA[
gap> S := Semigroup(Transformation([6, 7, 9, 6, 8, 9, 8, 7, 6]),
>                   Transformation([6, 8, 9, 6, 8, 8, 7, 9, 6]),
>                   Transformation([6, 8, 9, 7, 8, 8, 7, 9, 6]),
>                   Transformation([6, 9, 8, 6, 7, 9, 7, 8, 6]),
>                   Transformation([6, 9, 9, 6, 8, 8, 7, 9, 6]),
>                   Transformation([6, 9, 9, 7, 8, 8, 6, 9, 7]),
>                   Transformation([7, 8, 8, 7, 9, 9, 7, 8, 6]),
>                   Transformation([7, 9, 9, 7, 6, 9, 6, 8, 7]),
>                   Transformation([8, 7, 6, 9, 8, 6, 8, 7, 9]),
>                   Transformation([9, 6, 6, 7, 8, 8, 7, 6, 9]),
>                   Transformation([9, 6, 6, 7, 9, 6, 9, 8, 7]),
>                   Transformation([9, 6, 7, 9, 6, 6, 9, 7, 8]),
>                   Transformation([9, 6, 8, 7, 9, 6, 9, 8, 7]),
>                   Transformation([9, 7, 6, 8, 7, 7, 9, 6, 8]),
>                   Transformation([9, 7, 7, 8, 9, 6, 9, 7, 8]),
>                   Transformation([9, 8, 8, 9, 6, 7, 6, 8, 9]));;
gap> IsRightSimple(S);
false
gap> IsLeftSimple(S);
true
gap> IsGroupAsSemigroup(S);
false
gap> NrRClasses(S);
16
gap> S := BrauerMonoid(6);;
gap> S := Semigroup(RClass(S, Random(MinimalDClass(S))));;
gap> IsLeftSimple(S);
false
gap> IsRightSimple(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftZeroSemigroup">
  <ManSection>
    <Prop Name="IsLeftZeroSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsLeftZeroSemigroup</C> returns  <K>true</K> if the semigroup <A>S</A>
      is a left zero semigroup and <K>false</K> if it is not. <P/>

      A semigroup is a <E>left zero semigroup</E> if <C>x*y=x</C> for
      all <C>x,y</C>. An inverse semigroup is a left zero semigroup if and only
      if it is trivial.

      <Example><![CDATA[
gap> S := Semigroup(Transformation([2, 1, 4, 3, 5]),
>                   Transformation([3, 2, 3, 1, 1]));;
gap> IsRightZeroSemigroup(S);
false
gap> S := Semigroup(Transformation([1, 2, 3, 3, 1]),
>                   Transformation([1, 2, 3, 3, 3]));;
gap> IsLeftZeroSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicSemigroup">
  <ManSection>
    <Prop Name = "IsMonogenicSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
   <Description>
     <C>IsMonogenicSemigroup</C> returns <K>true</K> if the semigroup <A>S</A>
     is monogenic and it returns <K>false</K> if it is not. <P/>

     A semigroup is <E>monogenic</E> if it is generated by a single element.
     See also <Ref Prop = "IsMonogenicMonoid"/>,
     <Ref Prop = "IsMonogenicInverseSemigroup"/>, and
     <Ref Prop = "IsMonogenicInverseMonoid"/>.
<Example><![CDATA[
gap> S := Semigroup(
> Transformation(
>  [2, 2, 2, 11, 10, 8, 10, 11, 2, 11, 10, 2, 11, 11, 10]),
> Transformation(
>  [2, 2, 2, 8, 11, 15, 11, 10, 2, 10, 11, 2, 10, 4, 7]),
> Transformation(
>  [2, 2, 2, 11, 10, 8, 10, 11, 2, 11, 10, 2, 11, 11, 10]),
> Transformation(
>  [2, 2, 12, 7, 8, 14, 8, 11, 2, 11, 10, 2, 11, 15, 4]));;
gap> IsMonogenicSemigroup(S);
true
gap> S := Semigroup(
> Bipartition([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -2, -5, -7, -9],
>              [-1, -10], [-3, -4, -6, -8]]),
>  Bipartition([[1, 4, 7, 8, -2], [2, 3, 5, 10, -5],
>               [6, 9, -7, -9], [-1, -10], [-3, -4, -6, -8]]));;
gap> IsMonogenicSemigroup(S);
true
gap> S := FullTransformationSemigroup(5);;
gap> IsMonogenicSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicInverseSemigroup">
  <ManSection>
    <Prop Name = "IsMonogenicInverseSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
   <Description>
     <C>IsMonogenicInverseSemigroup</C> returns <K>true</K> if the semigroup
     <A>S</A> is a monogenic inverse semigroup and it returns <K>false</K> if
     it is not. <P/>

     A inverse semigroup is <E>monogenic</E> if it is generated as an inverse
     semigroup by a single element.  See also <Ref Prop =
       "IsMonogenicSemigroup"/> and <Ref Prop = "IsMonogenicInverseMonoid"/>.
<Example><![CDATA[
gap> x := PartialPerm([1, 2, 3, 6, 8, 10], [2, 6, 7, 9, 1, 5]);;
gap> S := InverseSemigroup(x, x ^ 2, x ^ 3);;
gap> IsMonogenicSemigroup(S);
false
gap> IsMonogenicInverseSemigroup(S);
true
gap> x := RandomBlockBijection(100);;
gap> S := InverseSemigroup(x, x ^ 2, x ^ 20);;
gap> IsMonogenicInverseSemigroup(S);
true
gap> S := SymmetricInverseSemigroup(5);;
gap> IsMonogenicInverseSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicMonoid">
  <ManSection>
    <Prop Name = "IsMonogenicMonoid" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
   <Description>
     <C>IsMonogenicMonoid</C> returns <K>true</K> if the monoid <A>S</A> is a
     monogenic monoid and it returns <K>false</K> if it is not. <P/>

     A monoid is <E>monogenic</E> if it is generated as a monoid by a single
     element.  See also <Ref Prop = "IsMonogenicSemigroup"/> and <Ref Prop =
       "IsMonogenicInverseMonoid"/>.
<Example><![CDATA[
gap> x := PartialPerm([1, 2, 3, 6, 8, 10], [2, 6, 7, 9, 1, 5]);;
gap> S := Monoid(x, x ^ 2, x ^ 3);;
gap> IsMonogenicSemigroup(S);
false
gap> IsMonogenicMonoid(S);
true
gap> S := FullTransformationMonoid(5);;
gap> IsMonogenicMonoid(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicInverseMonoid">
  <ManSection>
    <Prop Name = "IsMonogenicInverseMonoid" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
   <Description>
     <C>IsMonogenicInverseMonoid</C> returns <K>true</K> if the monoid
     <A>S</A> is a monogenic inverse monoid and it returns <K>false</K> if
     it is not. <P/>

     A inverse monoid is <E>monogenic</E> if it is generated as an inverse
     monoid by a single element.  See also <Ref Prop =
       "IsMonogenicInverseSemigroup"/> and <Ref Prop = "IsMonogenicMonoid"/>.
<Example><![CDATA[
gap> x := PartialPerm([1, 2, 3, 6, 8, 10], [2, 6, 7, 9, 1, 5]);;
gap> S := InverseMonoid(x, x ^ 2, x ^ 3);;
gap> IsMonogenicMonoid(S);
false
gap> IsMonogenicInverseSemigroup(S);
false
gap> IsMonogenicInverseMonoid(S);
true
gap> x := RandomBlockBijection(100);;
gap> S := InverseMonoid(x, x ^ 2, x ^ 20);;
gap> IsMonogenicInverseMonoid(S);
true
gap> S := SymmetricInverseMonoid(5);;
gap> IsMonogenicInverseMonoid(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonoidAsSemigroup">
  <ManSection>
    <Prop Name = "IsMonoidAsSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsMonoidAsSemigroup</C> returns <K>true</K> if and only if the
      semigroup <A>S</A> is mathematically a monoid, i.e. if and only if it
      contains a <Ref Meth = "MultiplicativeNeutralElement" BookName = "ref"/>.
      <P/>

      It is possible that a semigroup which satisfies
      <C>IsMonoidAsSemigroup</C> is not in the &GAP; category <Ref
        Prop = "IsMonoid" BookName = "ref"/>. This is possible if the <Ref
        Meth = "MultiplicativeNeutralElement" BookName = "ref"/> of <A>S</A> is not
      equal to the <Ref Attr = "One" BookName = "ref"/> of any element in <A>S</A>.
      Therefore a semigroup satisfying <C>IsMonoidAsSemigroup</C> may not
      possess the attributes of a monoid (such as, <Ref
        Attr = "GeneratorsOfMonoid" BookName = "ref"/>).<P/>

     See also <Ref Attr = "One" BookName = "ref"/>,
     <Ref Prop = "IsInverseMonoid" BookName = "ref"/>
     and <Ref Oper = "IsomorphismTransformationMonoid" BookName = "ref"/>.
      <Example><![CDATA[
gap> S := Semigroup(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),
>                   Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;
gap> IsMonoidAsSemigroup(S);
true
gap> IsMonoid(S);
false
gap> MultiplicativeNeutralElement(S);
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 9 ] )
gap> T := AsSemigroup(IsBipartitionSemigroup, S);;
gap> IsMonoidAsSemigroup(T);
true
gap> IsMonoid(T);
false
gap> One(T);
fail
gap> S := Monoid(Transformation([8, 2, 8, 9, 10, 6, 2, 8, 7, 8]),
>                Transformation([9, 2, 6, 3, 6, 4, 5, 5, 3, 2]));;
gap> IsMonoidAsSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsOrthodoxSemigroup">
  <ManSection>
    <Prop Name = "IsOrthodoxSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsOrthodoxSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is orthodox and <K>false</K> if it is not.<P/>

      A semigroup is <E>orthodox</E> if it is regular and its idempotent
      elements form a subsemigroup.  Every inverse semigroup is also an
      orthodox semigroup.<P/>

      See also <Ref Prop="IsRegularSemigroup"/> and
      <Ref Prop="IsRegularSemigroup" BookName="ref"/>.

      <Example><![CDATA[
gap> S := Semigroup(Transformation([1, 1, 1, 4, 5, 4]),
>                   Transformation([1, 2, 3, 1, 1, 2]),
>                   Transformation([1, 2, 3, 1, 1, 3]),
>                   Transformation([5, 5, 5, 5, 5, 5]));;
gap> IsOrthodoxSemigroup(S);
true
gap> S := DualSymmetricInverseMonoid(5);;
gap> S := Semigroup(GeneratorsOfSemigroup(S));;
gap> IsOrthodoxSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRectangularBand">
  <ManSection>
    <Prop Name = "IsRectangularBand" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsRectangularBand</C> returns <K>true</K> if the semigroup <A>S</A>
      is a rectangular band and <K>false</K> if it is not.<P/>

      A semigroup <A>S</A> is a <E>rectangular band</E> if for all
      <M>x, y, z</M>  in <A>S</A>
      we have that <M>x ^ 2 = x</M> and <M>xyz = xz</M>.<P/>

      Equivalently, <A>S</A> is a <E>rectangular band</E> if
      <A>S</A> is isomorphic to a semigroup of the form
      <M>I \times \Lambda</M> with multiplication
      <M>(i, \lambda)(j, \mu) = (i, \mu)</M>.
      In this case, <A>S</A> is called an
      <M>|I| \times |\Lambda|</M> <E>rectangular band</E>.<P/>

      An inverse semigroup is a rectangular band if and only if it is a group.
      <Example><![CDATA[
gap> S := Semigroup(
> Transformation([1, 1, 1, 4, 4, 4, 7, 7, 7, 1]),
> Transformation([2, 2, 2, 5, 5, 5, 8, 8, 8, 2]),
> Transformation([3, 3, 3, 6, 6, 6, 9, 9, 9, 3]),
> Transformation([1, 1, 1, 4, 4, 4, 7, 7, 7, 4]),
> Transformation([1, 1, 1, 4, 4, 4, 7, 7, 7, 7]));;
gap> IsRectangularBand(S);
true
gap> IsRectangularBand(MinimalIdeal(PartitionMonoid(4)));
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularSemigroup">
  <ManSection>
    <Prop Name = "IsRegularSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsRegularSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is regular and <K>false</K> if it is not. <P/>

      A semigroup <C>S</C> is <E>regular</E> if for all <C>x</C> in <C>S</C>
      there exists <C>y</C> in <C>S</C> such that <C>x * y * x = x</C>. Every
      inverse semigroup is regular, and a semigroup of partial permutations is
      regular if and only if it is an inverse semigroup.<P/>

      See also <Ref Prop = "IsRegularDClass" BookName = "ref"/>,
      <Ref Prop = "IsRegularGreensClass"/>,
      and <Ref Func = "IsRegularSemigroupElement" BookName = "ref"/>.

      <Example><![CDATA[
gap> IsRegularSemigroup(FullTransformationSemigroup(5));
true
gap> IsRegularSemigroup(JonesMonoid(5));
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRightZeroSemigroup">
  <ManSection>
    <Prop Name = "IsRightZeroSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsRightZeroSemigroup</C> returns <K>true</K> if the <A>S</A> is a
      right zero semigroup and <K>false</K> if it is not.<P/>

      A semigroup <C>S</C> is a <E>right zero semigroup</E> if <C>x * y = y</C>
      for all <C>x, y</C> in <C>S</C>. An inverse semigroup is a right zero
      semigroup if and only if it is trivial.
      <Example><![CDATA[
gap> S := Semigroup(Transformation([2, 1, 4, 3, 5]),
>                   Transformation([3, 2, 3, 1, 1]));;
gap> IsRightZeroSemigroup(S);
false
gap> S := Semigroup(Transformation([1, 2, 3, 3, 1]),
>                   Transformation([1, 2, 4, 4, 1]));;
gap> IsRightZeroSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemigroupWithClosedIdempotents">
  <ManSection>
    <Prop Name = "IsSemigroupWithClosedIdempotents" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsSemigroupWithClosedIdempotents</C> returns <K>true</K> if the
      idempotents of the semigroup <A>S</A> form a subsemigroup of <A>S</S>,
      and <K>false</K> if they do not.

      <Example><![CDATA[
gap> x := Transformation([2, 2]);;
gap> y := Transformation([1, 3, 3]);;
gap> S := Semigroup(x, y);
<transformation semigroup of degree 3 with 2 generators>
gap> IsSemigroupWithClosedIdempotents(S);
true
gap> S := FullTransformationMonoid(4);
<full transformation monoid of degree 4>
gap> IsSemigroupWithClosedIdempotents(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemigroupWithCommutingIdempotents">
  <ManSection>
    <Prop Name = "IsSemigroupWithCommutingIdempotents" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsSemigroupWithCommutingIdempotents</C> returns <K>true</K> if the
      idempotents
      of the semigroup <A>S</A> commute, and <K>false</K> if they do not. Note
      that such an semigroup is also a block group; see <Ref
        Prop="IsBlockGroup"/>. <P/>

      Note that the idempotents commute in any inverse semigroup, in any
      semigroup of partial permutations, and in any semigroup of block
      bijections.
      <Example><![CDATA[
gap> x := Transformation([2, 2]);;
gap> y := Transformation([1, 3, 3]);;
gap> S := Semigroup(x, y);
<transformation semigroup of degree 3 with 2 generators>
gap> IsSemigroupWithCommutingIdempotents(S);
true
gap> S := FullTransformationMonoid(4);
<full transformation monoid of degree 4>
gap> IsSemigroupWithCommutingIdempotents(S);
false
gap> W := Semigroup([
>  Bipartition([[1, 2, 3, -1, -2, -4], [4, -3]]),
>  Bipartition([[1, 2, -4], [3, -3], [4, -1, -2]])]);
<block bijection semigroup of degree 4 with 2 generators>
gap> IsSemigroupWithCommutingIdempotents(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemilattice">
  <ManSection>
    <Prop Name = "IsSemilattice" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsSemilattice</C> returns <K>true</K> if the semigroup
      <A>S</A> is a semilattice and <K>false</K> if it is not. <P/>

      A semigroup is a <E>semilattice</E> if it is commutative and every
      element is an idempotent. The idempotents of an inverse semigroup form a
      semilattice.
      <Example><![CDATA[
gap> S := Semigroup(Transformation([2, 5, 1, 7, 3, 7, 7]),
>                   Transformation([3, 6, 5, 7, 2, 1, 7]));;
gap> Size(S);
631
gap> IsInverseSemigroup(S);
true
gap> A := Semigroup(Idempotents(S));
<transformation semigroup of degree 7 with 32 generators>
gap> IsSemilattice(A);
true
gap> S := FactorisableDualSymmetricInverseMonoid(5);;
gap> S := IdempotentGeneratedSubsemigroup(S);;
gap> IsSemilattice(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSimpleSemigroup">
  <ManSection><Heading>IsSimpleSemigroup</Heading>
    <Prop Name="IsSimpleSemigroup" Arg="S"/>
    <Prop Name="IsCompletelySimpleSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsSimpleSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is simple and <K>false</K> if it is not.<P/>

      A semigroup is <E>simple</E> if it has no proper 2-sided ideals. A
      semigroup is <E>completely simple</E> if it is simple and possesses
      minimal left and right ideals. A finite semigroup is simple if and only
      if it is completely simple.  An inverse semigroup is simple if and only
      if it is a group.
      <Example><![CDATA[
gap> S := Semigroup(
>  Transformation([2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 2]),
>  Transformation([1, 1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 3]),
>  Transformation([1, 7, 3, 9, 5, 11, 7, 1, 9, 3, 11, 5, 5]),
>  Transformation([7, 7, 9, 9, 11, 11, 1, 1, 3, 3, 5, 5, 7]));;
gap> IsSimpleSemigroup(S);
true
gap> IsCompletelySimpleSemigroup(S);
true
gap> IsSimpleSemigroup(MinimalIdeal(BrauerMonoid(6)));
true
gap> R := Range(IsomorphismReesMatrixSemigroup(
> MinimalIdeal(BrauerMonoid(6))));
<Rees matrix semigroup 15x15 over Group(())>]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroGroup">
  <ManSection>
    <Prop Name="IsZeroGroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsZeroGroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is a zero group and <K>false</K> if it is not.<P/>

      A semigroup <C>S</C> is a <E>zero group</E> if there exists an
      element <C>z</C> in <C>S</C> such that <C>S</C> without <C>z</C> is a
      group and <C>x*z=z*x=z</C> for all <C>x</C> in <C>S</C>.
      Every zero group is an inverse semigroup.
      <Example><![CDATA[
gap> S := Semigroup(Transformation([2, 2, 3, 4, 6, 8, 5, 5, 9]),
>                   Transformation([3, 3, 8, 2, 5, 6, 4, 4, 9]),
>                   ConstantTransformation(9, 9));;
gap> IsZeroGroup(S);
true
gap> T := Range(IsomorphismPartialPermSemigroup(S));;
gap> IsZeroGroup(T);
true
gap> IsZeroGroup(JonesMonoid(2));
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroRectangularBand">
  <ManSection>
    <Prop Name = "IsZeroRectangularBand" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsZeroRectangularBand</C> returns <K>true</K> if the semigroup
      <A>S</A> is a zero rectangular band and <K>false</K> if it is not.<P/>

      A semigroup is a <E>0-rectangular band</E> if it is 0-simple and
      &H;-trivial; see also <Ref Prop="IsZeroSimpleSemigroup"/>
      and <Ref Prop="IsHTrivial"/>.
      An inverse semigroup is a 0-rectangular band if and only if it is a
      0-group; see <Ref Prop="IsZeroGroup"/>.
<Example><![CDATA[
gap> S := Semigroup(
>  Transformation([1, 3, 7, 9, 1, 12, 13, 1, 15, 9, 1, 18, 1, 1, 13,
>                  1, 1, 21, 1, 1, 1, 1, 1, 25, 26, 1]),
> Transformation([1, 5, 1, 5, 11, 1, 1, 14, 1, 16, 17, 1, 1, 19, 1,
>                 11, 1, 1, 1, 23, 1, 16, 19, 1, 1, 1]),
> Transformation([1, 4, 8, 1, 10, 1, 8, 1, 1, 1, 10, 1, 8, 10, 1, 1,
>                 20, 1, 22, 1, 8, 1, 1, 1, 1, 1]),
> Transformation([1, 6, 6, 1, 1, 1, 6, 1, 1, 1, 1, 1, 6, 1, 6, 1, 1,
>                 6, 1, 1, 24, 1, 1, 1, 1, 6]));;
gap> D := DClass(S,
> Transformation([1, 8, 1, 1, 8, 1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 1,
>                 1, 1, 1, 1, 1, 1, 1, 1, 1]));;
gap> IsZeroRectangularBand(Semigroup(D));
true
gap> IsZeroRectangularBand(Semigroup(GreensDClasses(S)[1]));
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroSemigroup">
  <ManSection>
    <Prop Name = "IsZeroSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsZeroSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is a zero semigroup and <K>false</K> if it is not.<P/>

      A semigroup <C>S</C> is a <E>zero semigroup</E> if there exists an
      element <C>z</C> in <C>S</C> such that <C>x*y=z</C> for all <C>x,y</C>
      in <C>S</C>. An inverse semigroup is a zero semigroup if and only if it
      is trivial.

      <Example><![CDATA[
gap> S := Semigroup(
> Transformation([4, 7, 6, 3, 1, 5, 3, 6, 5, 9]),
> Transformation([5, 3, 5, 1, 9, 3, 8, 7, 4, 3]));;
gap> IsZeroSemigroup(S);
false
gap> S := Semigroup(
>  Transformation([7, 8, 8, 8, 5, 8, 8, 8]),
>  Transformation([8, 8, 8, 8, 5, 7, 8, 8]),
>  Transformation([8, 7, 8, 8, 5, 8, 8, 8]),
>  Transformation([8, 8, 8, 7, 5, 8, 8, 8]),
>  Transformation([8, 8, 7, 8, 5, 8, 8, 8]));;
gap> IsZeroSemigroup(S);
true
gap> MultiplicativeZero(S);
Transformation( [ 8, 8, 8, 8, 5, 8, 8, 8 ] )]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroSimpleSemigroup">
  <ManSection>
    <Prop Name = "IsZeroSimpleSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsZeroSimpleSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is 0-simple and <K>false</K> if it is not.<P/>

      A semigroup is a <E>0-simple</E> if it has no two-sided ideals other than
      itself and the set containing the zero element; see also <Ref
        Attr = "MultiplicativeZero"/>. An inverse semigroup is 0-simple if and
      only if it is a Brandt semigroup; see <Ref Prop = "IsBrandtSemigroup"/>.

      <Example><![CDATA[
gap> S := Semigroup(
>  Transformation([1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 5, 17,
>                  17, 17, 17, 17, 17]),
>  Transformation([1, 17, 17, 17, 11, 17, 17, 17, 17, 17, 17, 17,
>                  17, 17, 17, 17, 17]),
>  Transformation([1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 4, 17,
>                  17, 17, 17, 17, 17]),
>  Transformation([1, 17, 17, 5, 17, 17, 17, 17, 17, 17, 17, 17,
>                  17, 17, 17, 17, 17]));;
gap> IsZeroSimpleSemigroup(S);
true
gap> S := Semigroup(
> Transformation([2, 3, 4, 5, 1, 8, 7, 6, 2, 7]),
> Transformation([2, 3, 4, 5, 6, 8, 7, 1, 2, 2]));;
gap> IsZeroSimpleSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCongruenceFreeSemigroup">
  <ManSection>
    <Prop Name = "IsCongruenceFreeSemigroup" Arg = "S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsCongruenceFreeSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is a congruence-free semigroup and <K>false</K> if it is
      not.<P/>

      A semigroup <A>S</A> is <E>congruence-free</E> if it has no non-trivial
      proper congruences.<P/>

      A semigroup with zero is congruence-free if and only if it is isomorphic
      to a regular Rees 0-matrix semigroup <C>R</C> whose underlying semigroup
      is the trivial group, no two rows of the matrix of <C>R</C> are identical,
      and no two columns are identical; see Theorem 3.7.1 in
      <Cite Key = "Howie1995aa"/>.<P/>

      A semigroup without zero is congruence-free if and only if it is a simple
      group or has order 2; see Theorem 3.7.2 in <Cite Key = "Howie1995aa"/>.

      <Example><![CDATA[
gap> S := Semigroup(Transformation([4, 2, 3, 3, 4]));;
gap> IsCongruenceFreeSemigroup(S);
true
gap> S := Semigroup(Transformation([2, 2, 4, 4]),
>                   Transformation([5, 3, 4, 4, 6, 6]));;
gap> IsCongruenceFreeSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemigroupWithAdjoinedZero">
  <ManSection>
    <Prop Name="IsSemigroupWithAdjoinedZero" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsSemigroupWithAdjoinedZero</C> returns <K>true</K> if the semigroup
      <A>S</A> can be expressed as the disjoint union of subsemigroups
      <M><A>S</A> \setminus \{ 0 \}</M> and <M>\{ 0 \}</M> (where <M>0</M> is
      the <Ref Attr="MultiplicativeZero"/> of <A>S</A>). <P/>

      If this is not the case, then either <A>S</A> lacks a multiplicative
      zero, or the set <M><A>S</A> \setminus \{ 0 \}</M> is not a subsemigroup
      of <A>S</A>, and so <C>IsSemigroupWithAdjoinedZero</C> returns
      <K>false</K>.

      <Example><![CDATA[
gap> S := Semigroup(Transformation([2, 3, 4, 5, 1, 6]),
>                   Transformation([2, 1, 3, 4, 5, 6]),
>                   Transformation([6, 6, 6, 6, 6, 6]));
<transformation semigroup of degree 6 with 3 generators>
gap> IsZeroGroup(S);
true
gap> IsSemigroupWithAdjoinedZero(S);
true
gap> S := FullTransformationMonoid(4);;
gap> IsSemigroupWithAdjoinedZero(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSurjectiveSemigroup">
  <ManSection>
    <Prop Name="IsSurjectiveSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      A semigroup is <E>surjective</E> if each of its elements can be written as
      a product of two elements in the semigroup.
      <C>IsSurjectiveSemigroup(<A>S</A>)</C> returns <K>true</K> if the
      semigroup <A>S</A> is surjective, and <K>false</K> if it is not. <P/>

      See also <Ref Attr="IndecomposableElements" />. <P/>

      Note that every monoid, and every regular semigroup, is surjective.

      <Example><![CDATA[
gap> S := FullTransformationMonoid(100);
<full transformation monoid of degree 100>
gap> IsSurjectiveSemigroup(S);
true
gap> F := FreeSemigroup(3);;
gap> P := F / [[F.1, F.2 * F.1], [F.3 ^ 3, F.3]];
<fp semigroup with 3 generators and 2 relations of length 10>
gap> IsSurjectiveSemigroup(P);
false
gap> I := SingularTransformationMonoid(5);
<regular transformation semigroup ideal of degree 5 with 1 generator>
gap> IsSurjectiveSemigroup(I);
true
gap> M := MonogenicSemigroup(IsBipartitionSemigroup, 3, 2);
<commutative non-regular block bijection semigroup of size 4,
 degree 6 with 1 generator>
gap> IsSurjectiveSemigroup(M);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSelfDualSemigroup">
  <ManSection>
    <Prop Name="IsSelfDualSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      Returns <K>true</K> if the semigroup <A>S</A> is self dual and
      <K>false</K> otherwise.
      <P/>

      A semigroup is <E>self dual</E> if it is isomorphic to its dual,
      that is, the semigroup <C>T</C> with multiplication <C>*</C> defined
      by <C>x*y=yx</C> where <C>yx</C> denotes the product in <A>S</A>.

      <Example><![CDATA[
gap> F := FreeSemigroup("a", "b");
<free semigroup on the generators [ a, b ]>
gap> AssignGeneratorVariables(F);
gap> R := [[a ^ 3, a], [b ^ 2, b], [(a * b) ^ 2, a]];
[ [ a^3, a ], [ b^2, b ], [ (a*b)^2, a ] ]
gap> S := F / R;
<fp semigroup with 2 generators and 3 relations of length 14>
gap> IsSelfDualSemigroup(S);
false
gap> IsSelfDualSemigroup(FreeBand(3));
true
gap> S := DualSymmetricInverseMonoid(3);
<inverse block bijection monoid of degree 3 with 3 generators>
gap> IsSelfDualSemigroup(S);
true]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCryptoGroup">
  <ManSection>
    <Prop Name="IsCryptoGroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      A semigroup <A>S</A> is a <E>crypto group</E> if it is completely regular
      and Green's &H;-relation is a congruence. <C>IsCryptoGroup(<A>S</A>)</C>
      returns <K>true</K> if the semigroup <A>S</A> is a crypto group, and
      <K>false</K> if it is not. <P/>

      <Example><![CDATA[
gap> G := SymmetricGroup(5);;
gap> M := [[(1, 2), (2, 4)], [(1, 4), (1, 2, 3, 4, 5)]];;
gap> R := ReesMatrixSemigroup(G, M);;
gap> IsCryptoGroup(R);
true
gap> S := FullTransformationMonoid(2);;
gap> IsCryptoGroup(S);
false
gap> G1 := AlternatingGroup(4);;
gap> G2 := SymmetricGroup(3);;
gap> G3 := AlternatingGroup(5);;
gap> gr := Digraph([[1, 3], [2, 3], [3]]);;
gap> sgn := function(x)
> if SignPerm(x) = 1 then
> return ();
> fi;
> return (1, 2);
> end;;
gap> hom13 := GroupHomomorphismByFunction(G1, G3, sgn);;
gap> hom23 := GroupHomomorphismByFunction(G2, G3, sgn);;
gap> S := AsSemigroup(IsPartialPermSemigroup,
> gr,
> [G1, G2, G3], [[1, 3, hom13], [2, 3, hom23]]);;
gap> IsCryptoGroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>
