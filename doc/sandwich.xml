#############################################################################
##
#W  sandwich.xml
#Y  Copyright (C) 2024                                    Murray T. Whyte
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="SandwichSemigroup">
  <ManSection>
    <Oper Name = "DualSemigroup" Arg = "S, a"/>
    <Returns>The sandwich variant semigroup of the given semigroup, with respect
        to the given element.</Returns>
    <Description>
        The sandwich semigroup of a semigroup <A>S</A> with respect to an element
        <A>a</A> of <A>S</A> is the semigroup with the
        same underlying set as <A>S</A>, but with multiplication *
        defined as x * y = x a y.

        This operation returns a semigroup isomorphic to the sandwich semigroup
        of <A>S</A> with respect to <A>a</A>.
<Example>
<![CDATA[
gap> T := FullTransformationMonoid(5);
<full transformation monoid of degree 5>
gap> S := SandwichSemigroup(T, Transformation([1, 1]));
    <sandwich semigroup of size 3125 and sandwich element Transformation( [ 1, 1 ] )
]]></Example> </Description> </ManSection>
<#/GAPDoc>

<#GAPDoc Label="BijectionSandwichSemigroup">
  <ManSection>
    <Attr Name= "BijectionSandwichSemigroup" Arg = "S, a"/>
    <Returns>
        An isomorphism from semigroup <A>S</A> to the sandwich semigroup of
        <A>S</A> with respect to <A>a</A>.
    </Returns>
    <Description>
        The sandwich semigroup of <A>S</A> with respect to <A>a</A>
        mathematically has the same underlying  set as <A>S</A>,
        but is represented with a different set of elements in
        &SEMIGROUPS;. This function returns a mapping which is an isomorphism
        from <A>S</A> to the sandwich semigroup of <A>S</A> with respect
        <A>a</A>.
      <Example>
          <![CDATA[
gap> T := FullTransformationMonoid(5);
<full transformation monoid of degree 5>
f := BijectionSandwichSemigroup(T, Transformation([1, 1]));
MappingByFunction( <full transformation monoid of degree 5>, <sandwich semigroup of si\
ze 3125 and sandwich element Transformation( [ 1, 1 ] ) >, function( s ) ... end, function( s ) ... end)
gap> Transformation([3, 2, 2]) ^ f;
<Transformation( [ 3, 2, 2 ] ) in sandwich semigroup>]]></Example> </Description> </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSandwichSemigroupElement">
  <ManSection>
    <Filt Name = "IsSandwichSemigroupElement" Type = "Category" Arg="elt"/>
    <Returns>Returns <K>true</K> if <A>elt</A> has the representation of a
     sandwich semigroup element.</Returns>
    <Description>
      Elements of a sandwich semigroup obtained using
      <Ref Attr = "AntiIsomorphismDualSemigroup"/> normally lie in this
      category. The exception is elements obtained by applying
      the map <Ref Attr = "AntiIsomorphismDualSemigroup"/> to elements already
      in this category. That is, the elements of a semigroup lie in the
      category <Ref Filt="IsDualSemigroupElement"/> if and only if the
      elements of the corresponding dual semigroup do not.
<Example>
<![CDATA[
gap> S := SingularPartitionMonoid(4);;
gap> D := DualSemigroup(S);;
gap> s := GeneratorsOfSemigroup(S)[1];;
gap> map := AntiIsomorphismDualSemigroup(S);;
gap> t := s ^ map;
<<block bijection: [ 1, 2, -1, -2 ], [ 3, -3 ], [ 4, -4 ]>
  in the dual semigroup>
gap> IsDualSemigroupElement(t);
true
gap> inv := InverseGeneralMapping(map);;
gap> x := t ^ inv;
<block bijection: [ 1, 2, -1, -2 ], [ 3, -3 ], [ 4, -4 ]>
gap> IsDualSemigroupElement(x);
false]]></Example> </Description> </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsDualSemigroupRep">
  <ManSection>
    <Filt Name = "IsDualSemigroupRep" Type = "Category" Arg="sgrp"/>
    <Returns>Returns <K>true</K> if <A>sgrp</A> lies in the category of
      dual semigroups.</Returns>
    <Description>
      Semigroups created using <Ref Func="DualSemigroup"/>
      normally lie in this category. The exception is semigroups
      which are the dual of semigroups already lying in this category.
      That is, a semigroup lies in the category
      <Ref Filt="IsDualSemigroupRep"/> if and only if the corresponding
      dual semigroup does not. Note that this is not a Representation in the
      GAP sense, and will likely be renamed in a future major release of the
      package.
<Example>
<![CDATA[
gap> S := Semigroup([Transformation([3, 5, 1, 1, 2]),
> Transformation([1, 2, 4, 4, 3])]);
<transformation semigroup of degree 5 with 2 generators>
gap> D := DualSemigroup(S);
<dual semigroup of <transformation semigroup of degree 5 with 2
 generators>>
gap> IsDualSemigroupRep(D);
true
gap> R := DualSemigroup(D);
<transformation semigroup of degree 5 with 2 generators>
gap> IsDualSemigroupRep(R);
false
gap> R = S;
true
gap> T := Range(IsomorphismTransformationSemigroup(D));
<transformation semigroup of size 16, degree 17 with 2 generators>
gap> IsDualSemigroupRep(T);
false
gap> x := Representative(D);
<Transformation( [ 3, 5, 1, 1, 2 ] ) in the dual semigroup>
gap> V := Semigroup(x);
<dual semigroup of <commutative transformation semigroup of degree 5
 with 1 generator>>
gap> IsDualSemigroupRep(V);
true]]></Example> </Description> </ManSection>
<#/GAPDoc>
